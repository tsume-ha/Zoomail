(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~sound"],{

/***/ "./node_modules/v-calendar/lib/components/date-picker.umd.js":
/*!*******************************************************************!*\
  !*** ./node_modules/v-calendar/lib/components/date-picker.umd.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.js\"));\n\telse {}\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__8bbf__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"fb15\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"00fd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(\"9e69\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n/***/ }),\n\n/***/ \"03dd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isPrototype = __webpack_require__(\"eac5\"),\n    nativeKeys = __webpack_require__(\"57a5\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n/***/ }),\n\n/***/ \"0621\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(\"9e69\"),\n    isArguments = __webpack_require__(\"d370\"),\n    isArray = __webpack_require__(\"6747\");\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n\n\n/***/ }),\n\n/***/ \"06cf\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"83ab\");\nvar propertyIsEnumerableModule = __webpack_require__(\"d1e7\");\nvar createPropertyDescriptor = __webpack_require__(\"5c6c\");\nvar toIndexedObject = __webpack_require__(\"fc6a\");\nvar toPrimitive = __webpack_require__(\"c04e\");\nvar has = __webpack_require__(\"5135\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"0cfb\");\n\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n\n\n/***/ }),\n\n/***/ \"07c7\":\n/***/ (function(module, exports) {\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n/***/ }),\n\n/***/ \"087d\":\n/***/ (function(module, exports) {\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n/***/ }),\n\n/***/ \"08cc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"1a8c\");\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n\n\n/***/ }),\n\n/***/ \"0a6b\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"b7fe\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"3929953f\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"0b07\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsNative = __webpack_require__(\"34ac\"),\n    getValue = __webpack_require__(\"3698\");\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n/***/ }),\n\n/***/ \"0cfb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"83ab\");\nvar fails = __webpack_require__(\"d039\");\nvar createElement = __webpack_require__(\"cc12\");\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"0d24\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(\"2b3e\"),\n    stubFalse = __webpack_require__(\"07c7\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"62e4\")(module)))\n\n/***/ }),\n\n/***/ \"0da5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-nav-arrow{display:flex;justify-content:center;align-items:center;line-height:var(--leading-snug);border-width:2px;border-color:transparent;border-radius:var(--rounded)}.vc-nav-arrow.is-left{margin-right:auto}.vc-nav-arrow.is-right{margin-left:auto}.vc-nav-arrow:hover{background-color:var(--gray-900)}.vc-nav-arrow:focus{border-color:var(--accent-600)}.vc-nav-title{color:var(--accent-100);font-weight:var(--font-bold);line-height:var(--leading-snug);padding:4px 8px;border-radius:var(--rounded);border-width:2px;border-color:transparent}.vc-nav-title:hover{background-color:var(--gray-900)}.vc-nav-title:focus{border-color:var(--accent-600)}.vc-nav-item{width:48px;text-align:center;line-height:var(--leading-snug);font-weight:var(--font-semibold);padding:4px 0;cursor:pointer;border-color:transparent;border-width:2px;border-radius:var(--rounded)}.vc-nav-item:hover{color:var(--white);background-color:var(--gray-900);box-shadow:var(--shadow-inner)}.vc-nav-item:focus{border-color:var(--accent-600)}.vc-nav-item.is-active{color:var(--accent-900);background:var(--accent-100);font-weight:var(--font-bold);box-shadow:var(--shadow)}.vc-nav-item.is-active,.vc-nav-item.is-inactive{border-color:transparent}.vc-nav-item:is-inactive-current{color:var(--accent-100);font-weight:var(--bold);border-color:var(--accent-100)}.vc-nav-item.is-disabled{opacity:.25;pointer-events:none}.vc-is-dark .vc-nav-title{color:var(--gray-900)}.vc-is-dark .vc-nav-title:hover{background-color:var(--gray-200)}.vc-is-dark .vc-nav-title:focus{border-color:var(--accent-400)}.vc-is-dark .vc-nav-arrow:hover{background-color:var(--gray-200)}.vc-is-dark .vc-nav-arrow:focus{border-color:var(--accent-400)}.vc-is-dark .vc-nav-item:hover{color:var(--gray-900);background-color:var(--gray-200);box-shadow:none}.vc-is-dark .vc-nav-item:focus{border-color:var(--accent-400)}.vc-is-dark .vc-nav-item.is-active{color:var(--white);background:var(--accent-500)}.vc-is-dark .vc-nav-item.is-inactive-current{color:var(--accent-600);border-color:var(--accent-500)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"0f0f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(\"8eeb\"),\n    keysIn = __webpack_require__(\"9934\");\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n\n\n/***/ }),\n\n/***/ \"0f5c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseSet = __webpack_require__(\"159a\");\n\n/**\n * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n * it's created. Arrays are created for missing index properties while objects\n * are created for all other missing properties. Use `_.setWith` to customize\n * `path` creation.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.set(object, 'a[0].b.c', 4);\n * console.log(object.a[0].b.c);\n * // => 4\n *\n * _.set(object, ['x', '0', 'y', 'z'], 5);\n * console.log(object.x[0].y.z);\n * // => 5\n */\nfunction set(object, path, value) {\n  return object == null ? object : baseSet(object, path, value);\n}\n\nmodule.exports = set;\n\n\n/***/ }),\n\n/***/ \"0f62\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"a997\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"2f369234\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"100e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar identity = __webpack_require__(\"cd9d\"),\n    overRest = __webpack_require__(\"2286\"),\n    setToString = __webpack_require__(\"c1c9\");\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n\n\n/***/ }),\n\n/***/ \"1041\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(\"8eeb\"),\n    getSymbolsIn = __webpack_require__(\"a029\");\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n\n\n/***/ }),\n\n/***/ \"1290\":\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n/***/ }),\n\n/***/ \"1310\":\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n/***/ }),\n\n/***/ \"1368\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar coreJsData = __webpack_require__(\"da03\");\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n/***/ }),\n\n/***/ \"1497\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-svg-icon[data-v-19b6cf78]{display:inline-block;stroke:currentColor;stroke-width:0}.vc-svg-icon path[data-v-19b6cf78]{fill:currentColor}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"14c3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(\"c6b6\");\nvar regexpExec = __webpack_require__(\"9263\");\n\n// `RegExpExec` abstract operation\n// https://tc39.github.io/ecma262/#sec-regexpexec\nmodule.exports = function (R, S) {\n  var exec = R.exec;\n  if (typeof exec === 'function') {\n    var result = exec.call(R, S);\n    if (typeof result !== 'object') {\n      throw TypeError('RegExp exec method returned something other than an Object or null');\n    }\n    return result;\n  }\n\n  if (classof(R) !== 'RegExp') {\n    throw TypeError('RegExp#exec called on incompatible receiver');\n  }\n\n  return regexpExec.call(R, S);\n};\n\n\n\n/***/ }),\n\n/***/ \"159a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignValue = __webpack_require__(\"32b3\"),\n    castPath = __webpack_require__(\"e2e4\"),\n    isIndex = __webpack_require__(\"c098\"),\n    isObject = __webpack_require__(\"1a8c\"),\n    toKey = __webpack_require__(\"f4d6\");\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nmodule.exports = baseSet;\n\n\n/***/ }),\n\n/***/ \"15f3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar basePickBy = __webpack_require__(\"89d9\"),\n    hasIn = __webpack_require__(\"8604\");\n\n/**\n * The base implementation of `_.pick` without support for individual\n * property identifiers.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @returns {Object} Returns the new object.\n */\nfunction basePick(object, paths) {\n  return basePickBy(object, paths, function(value, path) {\n    return hasIn(object, path);\n  });\n}\n\nmodule.exports = basePick;\n\n\n/***/ }),\n\n/***/ \"1838\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsEqual = __webpack_require__(\"c05f\"),\n    get = __webpack_require__(\"9b02\"),\n    hasIn = __webpack_require__(\"8604\"),\n    isKey = __webpack_require__(\"f608\"),\n    isStrictComparable = __webpack_require__(\"08cc\"),\n    matchesStrictComparable = __webpack_require__(\"20ec\"),\n    toKey = __webpack_require__(\"f4d6\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n\n\n/***/ }),\n\n/***/ \"18d8\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar memoizeCapped = __webpack_require__(\"234d\");\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n\n\n/***/ }),\n\n/***/ \"1a2d\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getTag = __webpack_require__(\"42a2\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n\n\n/***/ }),\n\n/***/ \"1a8c\":\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n/***/ }),\n\n/***/ \"1b23\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"2e1d\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"b273ba04\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"1bac\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetAllKeys = __webpack_require__(\"7d1f\"),\n    getSymbolsIn = __webpack_require__(\"a029\"),\n    keysIn = __webpack_require__(\"9934\");\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n\n\n/***/ }),\n\n/***/ \"1be4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(\"d066\");\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n\n/***/ }),\n\n/***/ \"1c3c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(\"9e69\"),\n    Uint8Array = __webpack_require__(\"2474\"),\n    eq = __webpack_require__(\"9638\"),\n    equalArrays = __webpack_require__(\"a2be\"),\n    mapToArray = __webpack_require__(\"edfa\"),\n    setToArray = __webpack_require__(\"ac41\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n\n\n/***/ }),\n\n/***/ \"1cec\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(\"0b07\"),\n    root = __webpack_require__(\"2b3e\");\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n\n\n/***/ }),\n\n/***/ \"1d80\":\n/***/ (function(module, exports) {\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"1efc\":\n/***/ (function(module, exports) {\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n\n/***/ }),\n\n/***/ \"1fc8\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(\"4245\");\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n/***/ }),\n\n/***/ \"20ec\":\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n\n\n/***/ }),\n\n/***/ \"2286\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = __webpack_require__(\"85e3\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n\n\n/***/ }),\n\n/***/ \"234d\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar memoize = __webpack_require__(\"e380\");\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n\n\n/***/ }),\n\n/***/ \"23a5\":\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"maxSwipeTime\\\":300,\\\"minHorizontalSwipeDistance\\\":60,\\\"maxVerticalSwipeDistance\\\":80}\");\n\n/***/ }),\n\n/***/ \"23cb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"a691\");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n/***/ }),\n\n/***/ \"23e7\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"da84\");\nvar getOwnPropertyDescriptor = __webpack_require__(\"06cf\").f;\nvar createNonEnumerableProperty = __webpack_require__(\"9112\");\nvar redefine = __webpack_require__(\"6eeb\");\nvar setGlobal = __webpack_require__(\"ce4e\");\nvar copyConstructorProperties = __webpack_require__(\"e893\");\nvar isForced = __webpack_require__(\"94ca\");\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n\n\n/***/ }),\n\n/***/ \"2411\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseMerge = __webpack_require__(\"f909\"),\n    createAssigner = __webpack_require__(\"2ec1\");\n\n/**\n * This method is like `_.merge` except that it accepts `customizer` which\n * is invoked to produce the merged values of the destination and source\n * properties. If `customizer` returns `undefined`, merging is handled by the\n * method instead. The `customizer` is invoked with six arguments:\n * (objValue, srcValue, key, object, source, stack).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} customizer The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   if (_.isArray(objValue)) {\n *     return objValue.concat(srcValue);\n *   }\n * }\n *\n * var object = { 'a': [1], 'b': [2] };\n * var other = { 'a': [3], 'b': [4] };\n *\n * _.mergeWith(object, other, customizer);\n * // => { 'a': [1, 3], 'b': [2, 4] }\n */\nvar mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n  baseMerge(object, source, srcIndex, customizer);\n});\n\nmodule.exports = mergeWith;\n\n\n/***/ }),\n\n/***/ \"241c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(\"ca84\");\nvar enumBugKeys = __webpack_require__(\"7839\");\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertynames\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n/***/ }),\n\n/***/ \"242e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFor = __webpack_require__(\"72af\"),\n    keys = __webpack_require__(\"ec69\");\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n\n/***/ }),\n\n/***/ \"2474\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(\"2b3e\");\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n\n\n/***/ }),\n\n/***/ \"2478\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(\"4245\");\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n/***/ }),\n\n/***/ \"24fb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}\n\n/***/ }),\n\n/***/ \"2524\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(\"6044\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n/***/ }),\n\n/***/ \"253c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(\"3729\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n/***/ }),\n\n/***/ \"255e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"5905\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"4d4bd8d9\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"2593\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar basePick = __webpack_require__(\"15f3\"),\n    flatRest = __webpack_require__(\"c6cf\");\n\n/**\n * Creates an object composed of the picked `object` properties.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to pick.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pick(object, ['a', 'c']);\n * // => { 'a': 1, 'c': 3 }\n */\nvar pick = flatRest(function(object, paths) {\n  return object == null ? {} : basePick(object, paths);\n});\n\nmodule.exports = pick;\n\n\n/***/ }),\n\n/***/ \"26e8\":\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n\n\n/***/ }),\n\n/***/ \"28c9\":\n/***/ (function(module, exports) {\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n\n/***/ }),\n\n/***/ \"29f3\":\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n/***/ }),\n\n/***/ \"2b10\":\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n\n\n/***/ }),\n\n/***/ \"2b27\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PopoverRow_vue_vue_type_style_index_0_id_4975d69e_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"5849\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PopoverRow_vue_vue_type_style_index_0_id_4975d69e_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PopoverRow_vue_vue_type_style_index_0_id_4975d69e_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PopoverRow_vue_vue_type_style_index_0_id_4975d69e_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"2b3e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar freeGlobal = __webpack_require__(\"585a\");\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n/***/ }),\n\n/***/ \"2d7c\":\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n\n\n/***/ }),\n\n/***/ \"2dcb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar overArg = __webpack_require__(\"91e9\");\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n\n\n/***/ }),\n\n/***/ \"2e1d\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-day[data-v-a1110b40]{position:relative;min-height:28px;width:100%;height:100%;z-index:1}.vc-day.is-not-in-month *[data-v-a1110b40]{opacity:0;pointer-events:none}.vc-day-layer[data-v-a1110b40]{position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none}.vc-day-box-center-center[data-v-a1110b40]{display:flex;justify-content:center;align-items:center;height:100%;transform-origin:50% 50%}.vc-day-box-left-center[data-v-a1110b40]{display:flex;justify-content:flex-start;align-items:center;height:100%;transform-origin:0 50%}.vc-day-box-right-center[data-v-a1110b40]{display:flex;justify-content:flex-end;align-items:center;height:100%;transform-origin:100% 50%}.vc-day-box-center-bottom[data-v-a1110b40]{display:flex;justify-content:center;align-items:flex-end}.vc-day-content[data-v-a1110b40]{display:flex;justify-content:center;align-items:center;font-size:var(--text-sm);font-weight:var(--font-medium);width:28px;height:28px;margin:1.6px auto;border-radius:var(--rounded-full);-webkit-user-select:none;user-select:none;cursor:pointer}.vc-day-content[data-v-a1110b40]:hover{background-color:rgba(204,214,224,.3)}.vc-day-content[data-v-a1110b40]:focus{font-weight:var(--font-bold);background-color:rgba(204,214,224,.4)}.vc-day-content.is-disabled[data-v-a1110b40]{color:var(--gray-400)}.vc-is-dark .vc-day-content[data-v-a1110b40]:hover{background-color:rgba(114,129,151,.3)}.vc-is-dark .vc-day-content[data-v-a1110b40]:focus{background-color:rgba(114,129,151,.4)}.vc-is-dark .vc-day-content.is-disabled[data-v-a1110b40]{color:var(--gray-600)}.vc-highlights[data-v-a1110b40]{overflow:hidden;pointer-events:none;z-index:-1}.vc-highlight[data-v-a1110b40]{width:28px;height:28px}.vc-highlight.vc-highlight-base-start[data-v-a1110b40]{width:50%!important;border-radius:0!important;border-right-width:0!important}.vc-highlight.vc-highlight-base-end[data-v-a1110b40]{width:50%!important;border-radius:0!important;border-left-width:0!important}.vc-highlight.vc-highlight-base-middle[data-v-a1110b40]{width:100%;border-radius:0!important;border-left-width:0!important;border-right-width:0!important;margin:0 -1px}.vc-dots[data-v-a1110b40]{display:flex;justify-content:center;align-items:center}.vc-dot[data-v-a1110b40]{width:5px;height:5px;border-radius:50%;transition:all var(--day-content-transition-time)}.vc-dot[data-v-a1110b40]:not(:last-child){margin-right:3px}.vc-bars[data-v-a1110b40]{display:flex;justify-content:flex-start;align-items:center;width:75%}.vc-bar[data-v-a1110b40]{flex-grow:1;height:3px;transition:all var(--day-content-transition-time)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"2ec1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseRest = __webpack_require__(\"100e\"),\n    isIterateeCall = __webpack_require__(\"9aff\");\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n\n\n/***/ }),\n\n/***/ \"2fcc\":\n/***/ (function(module, exports) {\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n\n\n/***/ }),\n\n/***/ \"3092\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arraySome = __webpack_require__(\"4284\"),\n    baseIteratee = __webpack_require__(\"badf\"),\n    baseSome = __webpack_require__(\"361d\"),\n    isArray = __webpack_require__(\"6747\"),\n    isIterateeCall = __webpack_require__(\"9aff\");\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * Iteration is stopped once `predicate` returns truthy. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, 'yes', false], Boolean);\n * // => true\n *\n * var users = [\n *   { 'user': 'barney', 'active': true },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.some(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.some(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.some(users, 'active');\n * // => true\n */\nfunction some(collection, predicate, guard) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = some;\n\n\n/***/ }),\n\n/***/ \"30c9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(\"9520\"),\n    isLength = __webpack_require__(\"b218\");\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n/***/ }),\n\n/***/ \"32b3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(\"872a\"),\n    eq = __webpack_require__(\"9638\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n\n\n/***/ }),\n\n/***/ \"32f4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayFilter = __webpack_require__(\"2d7c\"),\n    stubArray = __webpack_require__(\"d327\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n\n\n/***/ }),\n\n/***/ \"34ac\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(\"9520\"),\n    isMasked = __webpack_require__(\"1368\"),\n    isObject = __webpack_require__(\"1a8c\"),\n    toSource = __webpack_require__(\"dc57\");\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n/***/ }),\n\n/***/ \"361d\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseEach = __webpack_require__(\"48a0\");\n\n/**\n * The base implementation of `_.some` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  baseEach(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\nmodule.exports = baseSome;\n\n\n/***/ }),\n\n/***/ \"3698\":\n/***/ (function(module, exports) {\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n/***/ }),\n\n/***/ \"3729\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(\"9e69\"),\n    getRawTag = __webpack_require__(\"00fd\"),\n    objectToString = __webpack_require__(\"29f3\");\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n/***/ }),\n\n/***/ \"37e8\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"83ab\");\nvar definePropertyModule = __webpack_require__(\"9bf2\");\nvar anObject = __webpack_require__(\"825a\");\nvar objectKeys = __webpack_require__(\"df75\");\n\n// `Object.defineProperties` method\n// https://tc39.github.io/ecma262/#sec-object.defineproperties\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"3818\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(\"7e64\"),\n    arrayEach = __webpack_require__(\"8057\"),\n    assignValue = __webpack_require__(\"32b3\"),\n    baseAssign = __webpack_require__(\"5b01\"),\n    baseAssignIn = __webpack_require__(\"0f0f\"),\n    cloneBuffer = __webpack_require__(\"e538\"),\n    copyArray = __webpack_require__(\"4359\"),\n    copySymbols = __webpack_require__(\"54eb\"),\n    copySymbolsIn = __webpack_require__(\"1041\"),\n    getAllKeys = __webpack_require__(\"a994\"),\n    getAllKeysIn = __webpack_require__(\"1bac\"),\n    getTag = __webpack_require__(\"42a2\"),\n    initCloneArray = __webpack_require__(\"c87c\"),\n    initCloneByTag = __webpack_require__(\"c2b6\"),\n    initCloneObject = __webpack_require__(\"fa21\"),\n    isArray = __webpack_require__(\"6747\"),\n    isBuffer = __webpack_require__(\"0d24\"),\n    isMap = __webpack_require__(\"cc45\"),\n    isObject = __webpack_require__(\"1a8c\"),\n    isSet = __webpack_require__(\"d7ee\"),\n    keys = __webpack_require__(\"ec69\"),\n    keysIn = __webpack_require__(\"9934\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n\n\n/***/ }),\n\n/***/ \"3852\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseHas = __webpack_require__(\"96f3\"),\n    hasPath = __webpack_require__(\"e2c0\");\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nmodule.exports = has;\n\n\n/***/ }),\n\n/***/ \"38ea\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarDay_vue_vue_type_style_index_0_id_a1110b40_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"1b23\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarDay_vue_vue_type_style_index_0_id_a1110b40_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarDay_vue_vue_type_style_index_0_id_a1110b40_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarDay_vue_vue_type_style_index_0_id_a1110b40_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"39ff\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(\"0b07\"),\n    root = __webpack_require__(\"2b3e\");\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n\n\n/***/ }),\n\n/***/ \"3b4a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(\"0b07\");\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n\n\n/***/ }),\n\n/***/ \"3bb4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isStrictComparable = __webpack_require__(\"08cc\"),\n    keys = __webpack_require__(\"ec69\");\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n\n\n/***/ }),\n\n/***/ \"3bbe\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"861d\");\n\nmodule.exports = function (it) {\n  if (!isObject(it) && it !== null) {\n    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ \"3c55\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarNav_vue_vue_type_style_index_0_lang_postcss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"e969\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarNav_vue_vue_type_style_index_0_lang_postcss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarNav_vue_vue_type_style_index_0_lang_postcss___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarNav_vue_vue_type_style_index_0_lang_postcss___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"3ee2\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"dc8c\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"13d41af5\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"3eea\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(\"7948\"),\n    baseClone = __webpack_require__(\"3818\"),\n    baseUnset = __webpack_require__(\"4bb5\"),\n    castPath = __webpack_require__(\"e2e4\"),\n    copyObject = __webpack_require__(\"8eeb\"),\n    customOmitClone = __webpack_require__(\"e0e7\"),\n    flatRest = __webpack_require__(\"c6cf\"),\n    getAllKeysIn = __webpack_require__(\"1bac\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable property paths of `object` that are not omitted.\n *\n * **Note:** This method is considerably slower than `_.pick`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to omit.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omit(object, ['a', 'c']);\n * // => { 'b': '2' }\n */\nvar omit = flatRest(function(object, paths) {\n  var result = {};\n  if (object == null) {\n    return result;\n  }\n  var isDeep = false;\n  paths = arrayMap(paths, function(path) {\n    path = castPath(path, object);\n    isDeep || (isDeep = path.length > 1);\n    return path;\n  });\n  copyObject(object, getAllKeysIn(object), result);\n  if (isDeep) {\n    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n  }\n  var length = paths.length;\n  while (length--) {\n    baseUnset(result, paths[length]);\n  }\n  return result;\n});\n\nmodule.exports = omit;\n\n\n/***/ }),\n\n/***/ \"3f84\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = __webpack_require__(\"85e3\"),\n    baseRest = __webpack_require__(\"100e\"),\n    customDefaultsMerge = __webpack_require__(\"e031\"),\n    mergeWith = __webpack_require__(\"2411\");\n\n/**\n * This method is like `_.defaults` except that it recursively assigns\n * default properties.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaults\n * @example\n *\n * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n * // => { 'a': { 'b': 2, 'c': 3 } }\n */\nvar defaultsDeep = baseRest(function(args) {\n  args.push(undefined, customDefaultsMerge);\n  return apply(mergeWith, undefined, args);\n});\n\nmodule.exports = defaultsDeep;\n\n\n/***/ }),\n\n/***/ \"3f8c\":\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ \"41c3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"1a8c\"),\n    isPrototype = __webpack_require__(\"eac5\"),\n    nativeKeysIn = __webpack_require__(\"ec8c\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n\n\n/***/ }),\n\n/***/ \"4245\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isKeyable = __webpack_require__(\"1290\");\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n/***/ }),\n\n/***/ \"4284\":\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n\n\n/***/ }),\n\n/***/ \"428f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"da84\");\n\nmodule.exports = global;\n\n\n/***/ }),\n\n/***/ \"42a2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataView = __webpack_require__(\"b5a7\"),\n    Map = __webpack_require__(\"79bc\"),\n    Promise = __webpack_require__(\"1cec\"),\n    Set = __webpack_require__(\"c869\"),\n    WeakMap = __webpack_require__(\"39ff\"),\n    baseGetTag = __webpack_require__(\"3729\"),\n    toSource = __webpack_require__(\"dc57\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n\n\n/***/ }),\n\n/***/ \"4359\":\n/***/ (function(module, exports) {\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n\n\n/***/ }),\n\n/***/ \"4416\":\n/***/ (function(module, exports) {\n\n/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n\n\n/***/ }),\n\n/***/ \"44ad\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"d039\");\nvar classof = __webpack_require__(\"c6b6\");\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n\n\n/***/ }),\n\n/***/ \"44d2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(\"b622\");\nvar create = __webpack_require__(\"7c73\");\nvar definePropertyModule = __webpack_require__(\"9bf2\");\n\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n\n/***/ }),\n\n/***/ \"4889\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarPane_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"df9e\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarPane_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarPane_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarPane_vue_vue_type_style_index_1_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"48a0\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseForOwn = __webpack_require__(\"242e\"),\n    createBaseEach = __webpack_require__(\"950a\");\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n\n\n/***/ }),\n\n/***/ \"4930\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"d039\");\n\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  // Chrome 38 Symbol has incorrect toString conversion\n  // eslint-disable-next-line no-undef\n  return !String(Symbol());\n});\n\n\n/***/ }),\n\n/***/ \"499e\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"default\", function() { return /* binding */ addStylesClient; });\n\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nfunction listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\n\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nfunction addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n/***/ }),\n\n/***/ \"49f4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(\"6044\");\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n\n/***/ }),\n\n/***/ \"4bb5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar castPath = __webpack_require__(\"e2e4\"),\n    last = __webpack_require__(\"4416\"),\n    parent = __webpack_require__(\"8296\"),\n    toKey = __webpack_require__(\"f4d6\");\n\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\nfunction baseUnset(object, path) {\n  path = castPath(path, object);\n  object = parent(object, path);\n  return object == null || delete object[toKey(last(path))];\n}\n\nmodule.exports = baseUnset;\n\n\n/***/ }),\n\n/***/ \"4cfe\":\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is `undefined`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n * @example\n *\n * _.isUndefined(void 0);\n * // => true\n *\n * _.isUndefined(null);\n * // => false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nmodule.exports = isUndefined;\n\n\n/***/ }),\n\n/***/ \"4d64\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toIndexedObject = __webpack_require__(\"fc6a\");\nvar toLength = __webpack_require__(\"50c4\");\nvar toAbsoluteIndex = __webpack_require__(\"23cb\");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n/***/ }),\n\n/***/ \"4d8c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFlatten = __webpack_require__(\"5c69\");\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n\n\n/***/ }),\n\n/***/ \"4f50\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignMergeValue = __webpack_require__(\"b760\"),\n    cloneBuffer = __webpack_require__(\"e538\"),\n    cloneTypedArray = __webpack_require__(\"c8fe\"),\n    copyArray = __webpack_require__(\"4359\"),\n    initCloneObject = __webpack_require__(\"fa21\"),\n    isArguments = __webpack_require__(\"d370\"),\n    isArray = __webpack_require__(\"6747\"),\n    isArrayLikeObject = __webpack_require__(\"dcbe\"),\n    isBuffer = __webpack_require__(\"0d24\"),\n    isFunction = __webpack_require__(\"9520\"),\n    isObject = __webpack_require__(\"1a8c\"),\n    isPlainObject = __webpack_require__(\"60ed\"),\n    isTypedArray = __webpack_require__(\"73ac\"),\n    safeGet = __webpack_require__(\"8adb\"),\n    toPlainObject = __webpack_require__(\"8de2\");\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n\n\n/***/ }),\n\n/***/ \"501e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(\"3729\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n * classified as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && baseGetTag(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n\n\n/***/ }),\n\n/***/ \"50c4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"a691\");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.github.io/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ \"50d8\":\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n/***/ }),\n\n/***/ \"5135\":\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n\n/***/ \"5319\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fixRegExpWellKnownSymbolLogic = __webpack_require__(\"d784\");\nvar anObject = __webpack_require__(\"825a\");\nvar toObject = __webpack_require__(\"7b0b\");\nvar toLength = __webpack_require__(\"50c4\");\nvar toInteger = __webpack_require__(\"a691\");\nvar requireObjectCoercible = __webpack_require__(\"1d80\");\nvar advanceStringIndex = __webpack_require__(\"8aa5\");\nvar regExpExec = __webpack_require__(\"14c3\");\n\nvar max = Math.max;\nvar min = Math.min;\nvar floor = Math.floor;\nvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d\\d?|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d\\d?)/g;\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// @@replace logic\nfixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {\n  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;\n  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;\n  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';\n\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = requireObjectCoercible(this);\n      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];\n      return replacer !== undefined\n        ? replacer.call(searchValue, O, replaceValue)\n        : nativeReplace.call(String(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace\n    function (regexp, replaceValue) {\n      if (\n        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||\n        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)\n      ) {\n        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);\n        if (res.done) return res.value;\n      }\n\n      var rx = anObject(regexp);\n      var S = String(this);\n\n      var functionalReplace = typeof replaceValue === 'function';\n      if (!functionalReplace) replaceValue = String(replaceValue);\n\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n\n        results.push(result);\n        if (!global) break;\n\n        var matchStr = String(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n\n        var matched = String(result[0]);\n        var position = max(min(toInteger(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = [matched].concat(captures, position, S);\n          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\n          var replacement = String(replaceValue.apply(undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + S.slice(nextSourcePosition);\n    }\n  ];\n\n  // https://tc39.github.io/ecma262/#sec-getsubstitution\n  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {\n    var tailPos = position + matched.length;\n    var m = captures.length;\n    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n    if (namedCaptures !== undefined) {\n      namedCaptures = toObject(namedCaptures);\n      symbols = SUBSTITUTION_SYMBOLS;\n    }\n    return nativeReplace.call(replacement, symbols, function (match, ch) {\n      var capture;\n      switch (ch.charAt(0)) {\n        case '$': return '$';\n        case '&': return matched;\n        case '`': return str.slice(0, position);\n        case \"'\": return str.slice(tailPos);\n        case '<':\n          capture = namedCaptures[ch.slice(1, -1)];\n          break;\n        default: // \\d\\d?\n          var n = +ch;\n          if (n === 0) return match;\n          if (n > m) {\n            var f = floor(n / 10);\n            if (f === 0) return match;\n            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n            return match;\n          }\n          capture = captures[n - 1];\n      }\n      return capture === undefined ? '' : capture;\n    });\n  }\n});\n\n\n/***/ }),\n\n/***/ \"54eb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(\"8eeb\"),\n    getSymbols = __webpack_require__(\"32f4\");\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n\n\n/***/ }),\n\n/***/ \"55a3\":\n/***/ (function(module, exports) {\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n\n\n/***/ }),\n\n/***/ \"5692\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar IS_PURE = __webpack_require__(\"c430\");\nvar store = __webpack_require__(\"c6cd\");\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.6.5',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2020 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n\n/***/ \"56ef\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(\"d066\");\nvar getOwnPropertyNamesModule = __webpack_require__(\"241c\");\nvar getOwnPropertySymbolsModule = __webpack_require__(\"7418\");\nvar anObject = __webpack_require__(\"825a\");\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\n\n/***/ }),\n\n/***/ \"57a5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar overArg = __webpack_require__(\"91e9\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n/***/ }),\n\n/***/ \"5849\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"b803\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"0a9763a7\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"585a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"c8ba\")))\n\n/***/ }),\n\n/***/ \"5905\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".none-enter-active[data-v-8466592e],.none-leave-active[data-v-8466592e]{transition-duration:0s}.fade-enter-active[data-v-8466592e],.fade-leave-active[data-v-8466592e],.slide-down-enter-active[data-v-8466592e],.slide-down-leave-active[data-v-8466592e],.slide-left-enter-active[data-v-8466592e],.slide-left-leave-active[data-v-8466592e],.slide-right-enter-active[data-v-8466592e],.slide-right-leave-active[data-v-8466592e],.slide-up-enter-active[data-v-8466592e],.slide-up-leave-active[data-v-8466592e]{transition:transform var(--slide-duration) var(--slide-timing),opacity var(--slide-duration) var(--slide-timing);-webkit-backface-visibility:hidden;backface-visibility:hidden}.fade-leave-active[data-v-8466592e],.none-leave-active[data-v-8466592e],.slide-down-leave-active[data-v-8466592e],.slide-left-leave-active[data-v-8466592e],.slide-right-leave-active[data-v-8466592e],.slide-up-leave-active[data-v-8466592e]{position:absolute;width:100%}.fade-enter[data-v-8466592e],.fade-leave-to[data-v-8466592e],.none-enter[data-v-8466592e],.none-leave-to[data-v-8466592e],.slide-down-enter[data-v-8466592e],.slide-down-leave-to[data-v-8466592e],.slide-left-enter[data-v-8466592e],.slide-left-leave-to[data-v-8466592e],.slide-right-enter[data-v-8466592e],.slide-right-leave-to[data-v-8466592e],.slide-up-enter[data-v-8466592e],.slide-up-leave-to[data-v-8466592e]{opacity:0}.slide-left-enter[data-v-8466592e],.slide-right-leave-to[data-v-8466592e]{transform:translateX(var(--slide-translate))}.slide-left-leave-to[data-v-8466592e],.slide-right-enter[data-v-8466592e]{transform:translateX(calc(var(--slide-translate)*-1))}.slide-down-leave-to[data-v-8466592e],.slide-up-enter[data-v-8466592e]{transform:translateY(var(--slide-translate))}.slide-down-enter[data-v-8466592e],.slide-up-leave-to[data-v-8466592e]{transform:translateY(calc(var(--slide-translate)*-1))}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"5b01\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(\"8eeb\"),\n    keys = __webpack_require__(\"ec69\");\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n\n/***/ }),\n\n/***/ \"5c69\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(\"087d\"),\n    isFlattenable = __webpack_require__(\"0621\");\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n\n\n/***/ }),\n\n/***/ \"5c6c\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ \"5d89\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cloneArrayBuffer = __webpack_require__(\"f8af\");\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n\n\n/***/ }),\n\n/***/ \"5e2e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar listCacheClear = __webpack_require__(\"28c9\"),\n    listCacheDelete = __webpack_require__(\"69d5\"),\n    listCacheGet = __webpack_require__(\"b4c0\"),\n    listCacheHas = __webpack_require__(\"fba5\"),\n    listCacheSet = __webpack_require__(\"67ca\");\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n/***/ }),\n\n/***/ \"6044\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(\"0b07\");\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n/***/ }),\n\n/***/ \"60ed\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(\"3729\"),\n    getPrototype = __webpack_require__(\"2dcb\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n\n\n/***/ }),\n\n/***/ \"6220\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsDate = __webpack_require__(\"b1d2\"),\n    baseUnary = __webpack_require__(\"b047\"),\n    nodeUtil = __webpack_require__(\"99d3\");\n\n/* Node.js helper references. */\nvar nodeIsDate = nodeUtil && nodeUtil.isDate;\n\n/**\n * Checks if `value` is classified as a `Date` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n * @example\n *\n * _.isDate(new Date);\n * // => true\n *\n * _.isDate('Mon April 23 2012');\n * // => false\n */\nvar isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\nmodule.exports = isDate;\n\n\n/***/ }),\n\n/***/ \"62e4\":\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ }),\n\n/***/ \"642a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsMatch = __webpack_require__(\"966f\"),\n    getMatchData = __webpack_require__(\"3bb4\"),\n    matchesStrictComparable = __webpack_require__(\"20ec\");\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n\n\n/***/ }),\n\n/***/ \"6547\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"a691\");\nvar requireObjectCoercible = __webpack_require__(\"1d80\");\n\n// `String.prototype.{ codePointAt, at }` methods implementation\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = String(requireObjectCoercible($this));\n    var position = toInteger(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = S.charCodeAt(position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING ? S.charAt(position) : first\n        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\n\n/***/ }),\n\n/***/ \"656b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar castPath = __webpack_require__(\"e2e4\"),\n    toKey = __webpack_require__(\"f4d6\");\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n\n/***/ }),\n\n/***/ \"6679\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(\"3729\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]';\n\n/**\n * Checks if `value` is classified as a boolean primitive or object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n * @example\n *\n * _.isBoolean(false);\n * // => true\n *\n * _.isBoolean(null);\n * // => false\n */\nfunction isBoolean(value) {\n  return value === true || value === false ||\n    (isObjectLike(value) && baseGetTag(value) == boolTag);\n}\n\nmodule.exports = isBoolean;\n\n\n/***/ }),\n\n/***/ \"6747\":\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n/***/ }),\n\n/***/ \"67ca\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(\"cb5a\");\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n/***/ }),\n\n/***/ \"69d5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(\"cb5a\");\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n/***/ }),\n\n/***/ \"69f3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar NATIVE_WEAK_MAP = __webpack_require__(\"7f9a\");\nvar global = __webpack_require__(\"da84\");\nvar isObject = __webpack_require__(\"861d\");\nvar createNonEnumerableProperty = __webpack_require__(\"9112\");\nvar objectHas = __webpack_require__(\"5135\");\nvar sharedKey = __webpack_require__(\"f772\");\nvar hiddenKeys = __webpack_require__(\"d012\");\n\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP) {\n  var store = new WeakMap();\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n/***/ }),\n\n/***/ \"6eeb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"da84\");\nvar createNonEnumerableProperty = __webpack_require__(\"9112\");\nvar has = __webpack_require__(\"5135\");\nvar setGlobal = __webpack_require__(\"ce4e\");\nvar inspectSource = __webpack_require__(\"8925\");\nvar InternalStateModule = __webpack_require__(\"69f3\");\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  if (typeof value == 'function') {\n    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);\n    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n});\n\n\n/***/ }),\n\n/***/ \"6f6c\":\n/***/ (function(module, exports) {\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n\n\n/***/ }),\n\n/***/ \"6fcd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseTimes = __webpack_require__(\"50d8\"),\n    isArguments = __webpack_require__(\"d370\"),\n    isArray = __webpack_require__(\"6747\"),\n    isBuffer = __webpack_require__(\"0d24\"),\n    isIndex = __webpack_require__(\"c098\"),\n    isTypedArray = __webpack_require__(\"73ac\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n/***/ }),\n\n/***/ \"72af\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createBaseFor = __webpack_require__(\"99cd\");\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n\n/***/ }),\n\n/***/ \"72f0\":\n/***/ (function(module, exports) {\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n\n\n/***/ }),\n\n/***/ \"72f5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"9e2e\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"2997fbdf\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"73ac\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsTypedArray = __webpack_require__(\"743f\"),\n    baseUnary = __webpack_require__(\"b047\"),\n    nodeUtil = __webpack_require__(\"99d3\");\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n/***/ }),\n\n/***/ \"7418\":\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n\n/***/ \"743f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(\"3729\"),\n    isLength = __webpack_require__(\"b218\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n/***/ }),\n\n/***/ \"7530\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"1a8c\");\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n\n\n/***/ }),\n\n/***/ \"76dd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseToString = __webpack_require__(\"ce86\");\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n\n\n/***/ }),\n\n/***/ \"7839\":\n/***/ (function(module, exports) {\n\n// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n/***/ }),\n\n/***/ \"7948\":\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n\n\n/***/ }),\n\n/***/ \"79bc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(\"0b07\"),\n    root = __webpack_require__(\"2b3e\");\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n/***/ }),\n\n/***/ \"7a48\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(\"6044\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n/***/ }),\n\n/***/ \"7b0b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar requireObjectCoercible = __webpack_require__(\"1d80\");\n\n// `ToObject` abstract operation\n// https://tc39.github.io/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\n\n/***/ }),\n\n/***/ \"7b83\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar mapCacheClear = __webpack_require__(\"7c64\"),\n    mapCacheDelete = __webpack_require__(\"93ed\"),\n    mapCacheGet = __webpack_require__(\"2478\"),\n    mapCacheHas = __webpack_require__(\"a524\"),\n    mapCacheSet = __webpack_require__(\"1fc8\");\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n/***/ }),\n\n/***/ \"7b97\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(\"7e64\"),\n    equalArrays = __webpack_require__(\"a2be\"),\n    equalByTag = __webpack_require__(\"1c3c\"),\n    equalObjects = __webpack_require__(\"b1e5\"),\n    getTag = __webpack_require__(\"42a2\"),\n    isArray = __webpack_require__(\"6747\"),\n    isBuffer = __webpack_require__(\"0d24\"),\n    isTypedArray = __webpack_require__(\"73ac\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n\n\n/***/ }),\n\n/***/ \"7c64\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Hash = __webpack_require__(\"e24b\"),\n    ListCache = __webpack_require__(\"5e2e\"),\n    Map = __webpack_require__(\"79bc\");\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n/***/ }),\n\n/***/ \"7c73\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"825a\");\nvar defineProperties = __webpack_require__(\"37e8\");\nvar enumBugKeys = __webpack_require__(\"7839\");\nvar hiddenKeys = __webpack_require__(\"d012\");\nvar html = __webpack_require__(\"1be4\");\nvar documentCreateElement = __webpack_require__(\"cc12\");\nvar sharedKey = __webpack_require__(\"f772\");\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    /* global ActiveXObject */\n    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.github.io/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\n\n/***/ }),\n\n/***/ \"7d1f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(\"087d\"),\n    isArray = __webpack_require__(\"6747\");\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n\n\n/***/ }),\n\n/***/ \"7dd0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"23e7\");\nvar createIteratorConstructor = __webpack_require__(\"9ed3\");\nvar getPrototypeOf = __webpack_require__(\"e163\");\nvar setPrototypeOf = __webpack_require__(\"d2bb\");\nvar setToStringTag = __webpack_require__(\"d44e\");\nvar createNonEnumerableProperty = __webpack_require__(\"9112\");\nvar redefine = __webpack_require__(\"6eeb\");\nvar wellKnownSymbol = __webpack_require__(\"b622\");\nvar IS_PURE = __webpack_require__(\"c430\");\nvar Iterators = __webpack_require__(\"3f8c\");\nvar IteratorsCore = __webpack_require__(\"ae93\");\n\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {\n          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    INCORRECT_VALUES_NAME = true;\n    defaultIterator = function values() { return nativeIterator.call(this); };\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\n  }\n  Iterators[NAME] = defaultIterator;\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  return methods;\n};\n\n\n/***/ }),\n\n/***/ \"7e64\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ListCache = __webpack_require__(\"5e2e\"),\n    stackClear = __webpack_require__(\"efb6\"),\n    stackDelete = __webpack_require__(\"2fcc\"),\n    stackGet = __webpack_require__(\"802a\"),\n    stackHas = __webpack_require__(\"55a3\"),\n    stackSet = __webpack_require__(\"d02c\");\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n\n\n/***/ }),\n\n/***/ \"7ed2\":\n/***/ (function(module, exports) {\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n\n\n/***/ }),\n\n/***/ \"7efe\":\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"title\\\":\\\"MMMM YYYY\\\",\\\"weekdays\\\":\\\"W\\\",\\\"navMonths\\\":\\\"MMM\\\",\\\"input\\\":[\\\"L\\\",\\\"YYYY-MM-DD\\\",\\\"YYYY/MM/DD\\\"],\\\"dayPopover\\\":\\\"WWW, MMM D, YYYY\\\",\\\"data\\\":[\\\"L\\\",\\\"YYYY-MM-DD\\\",\\\"YYYY/MM/DD\\\"],\\\"model\\\":\\\"iso\\\",\\\"iso\\\":\\\"YYYY-MM-DDTHH:mm:ssXXX\\\"}\");\n\n/***/ }),\n\n/***/ \"7f9a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"da84\");\nvar inspectSource = __webpack_require__(\"8925\");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\n\n\n/***/ }),\n\n/***/ \"802a\":\n/***/ (function(module, exports) {\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n\n\n/***/ }),\n\n/***/ \"8057\":\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n/***/ }),\n\n/***/ \"825a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"861d\");\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ \"8296\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(\"656b\"),\n    baseSlice = __webpack_require__(\"2b10\");\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\n\nmodule.exports = parent;\n\n\n/***/ }),\n\n/***/ \"8384\":\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\nmodule.exports = baseClamp;\n\n\n/***/ }),\n\n/***/ \"83ab\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"d039\");\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !fails(function () {\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\n\n/***/ }),\n\n/***/ \"85a9\":\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"sm\\\":\\\"640px\\\",\\\"md\\\":\\\"768px\\\",\\\"lg\\\":\\\"1024px\\\",\\\"xl\\\":\\\"1280px\\\"}\");\n\n/***/ }),\n\n/***/ \"85e3\":\n/***/ (function(module, exports) {\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n\n\n/***/ }),\n\n/***/ \"8604\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseHasIn = __webpack_require__(\"26e8\"),\n    hasPath = __webpack_require__(\"e2c0\");\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n\n\n/***/ }),\n\n/***/ \"861d\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n\n/***/ \"872a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(\"3b4a\");\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n\n\n/***/ }),\n\n/***/ \"8925\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar store = __webpack_require__(\"c6cd\");\n\nvar functionToString = Function.toString;\n\n// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\nif (typeof store.inspectSource != 'function') {\n  store.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n/***/ }),\n\n/***/ \"89d9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(\"656b\"),\n    baseSet = __webpack_require__(\"159a\"),\n    castPath = __webpack_require__(\"e2e4\");\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, paths, predicate) {\n  var index = -1,\n      length = paths.length,\n      result = {};\n\n  while (++index < length) {\n    var path = paths[index],\n        value = baseGet(object, path);\n\n    if (predicate(value, path)) {\n      baseSet(result, castPath(path, object), value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = basePickBy;\n\n\n/***/ }),\n\n/***/ \"8aa5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar charAt = __webpack_require__(\"6547\").charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.github.io/ecma262/#sec-advancestringindex\nmodule.exports = function (S, index, unicode) {\n  return index + (unicode ? charAt(S, index).length : 1);\n};\n\n\n/***/ }),\n\n/***/ \"8adb\":\n/***/ (function(module, exports) {\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n\n\n/***/ }),\n\n/***/ \"8bbf\":\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;\n\n/***/ }),\n\n/***/ \"8dad\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"1497\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"e59e570c\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"8de2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(\"8eeb\"),\n    keysIn = __webpack_require__(\"9934\");\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n\n\n/***/ }),\n\n/***/ \"8e2e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"c547\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"348d7855\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"8eeb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignValue = __webpack_require__(\"32b3\"),\n    baseAssignValue = __webpack_require__(\"872a\");\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n\n\n/***/ }),\n\n/***/ \"90e3\":\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n\n\n/***/ }),\n\n/***/ \"9112\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"83ab\");\nvar definePropertyModule = __webpack_require__(\"9bf2\");\nvar createPropertyDescriptor = __webpack_require__(\"5c6c\");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ \"91e9\":\n/***/ (function(module, exports) {\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n/***/ }),\n\n/***/ \"9263\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar regexpFlags = __webpack_require__(\"ad6d\");\nvar stickyHelpers = __webpack_require__(\"9f7f\");\n\nvar nativeExec = RegExp.prototype.exec;\n// This always refers to the native implementation, because the\n// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n// which loads this file before patching the method.\nvar nativeReplace = String.prototype.replace;\n\nvar patchedExec = nativeExec;\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  nativeExec.call(re1, 'a');\n  nativeExec.call(re2, 'a');\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n})();\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;\n\nif (PATCH) {\n  patchedExec = function exec(str) {\n    var re = this;\n    var lastIndex, reCopy, match, i;\n    var sticky = UNSUPPORTED_Y && re.sticky;\n    var flags = regexpFlags.call(re);\n    var source = re.source;\n    var charsAdded = 0;\n    var strCopy = str;\n\n    if (sticky) {\n      flags = flags.replace('y', '');\n      if (flags.indexOf('g') === -1) {\n        flags += 'g';\n      }\n\n      strCopy = String(str).slice(re.lastIndex);\n      // Support anchored sticky behavior.\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\\n')) {\n        source = '(?: ' + source + ')';\n        strCopy = ' ' + strCopy;\n        charsAdded++;\n      }\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\n      // simulate the 'y' flag.\n      reCopy = new RegExp('^(?:' + source + ')', flags);\n    }\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n    match = nativeExec.call(sticky ? reCopy : re, strCopy);\n\n    if (sticky) {\n      if (match) {\n        match.input = match.input.slice(charsAdded);\n        match[0] = match[0].slice(charsAdded);\n        match.index = re.lastIndex;\n        re.lastIndex += match[0].length;\n      } else re.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      nativeReplace.call(match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    return match;\n  };\n}\n\nmodule.exports = patchedExec;\n\n\n/***/ }),\n\n/***/ \"93ed\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(\"4245\");\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n\n/***/ }),\n\n/***/ \"94ca\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"d039\");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == 'function' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n/***/ }),\n\n/***/ \"950a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(\"30c9\");\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n\n\n/***/ }),\n\n/***/ \"9520\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(\"3729\"),\n    isObject = __webpack_require__(\"1a8c\");\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n\n/***/ \"95ae\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseRest = __webpack_require__(\"100e\"),\n    eq = __webpack_require__(\"9638\"),\n    isIterateeCall = __webpack_require__(\"9aff\"),\n    keysIn = __webpack_require__(\"9934\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nmodule.exports = defaults;\n\n\n/***/ }),\n\n/***/ \"9638\":\n/***/ (function(module, exports) {\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n/***/ }),\n\n/***/ \"966f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(\"7e64\"),\n    baseIsEqual = __webpack_require__(\"c05f\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n\n\n/***/ }),\n\n/***/ \"96f3\":\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\nmodule.exports = baseHas;\n\n\n/***/ }),\n\n/***/ \"97d3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseEach = __webpack_require__(\"48a0\"),\n    isArrayLike = __webpack_require__(\"30c9\");\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n\n\n/***/ }),\n\n/***/ \"9934\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayLikeKeys = __webpack_require__(\"6fcd\"),\n    baseKeysIn = __webpack_require__(\"41c3\"),\n    isArrayLike = __webpack_require__(\"30c9\");\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n\n\n/***/ }),\n\n/***/ \"99cd\":\n/***/ (function(module, exports) {\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n\n/***/ }),\n\n/***/ \"99d3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(\"585a\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"62e4\")(module)))\n\n/***/ }),\n\n/***/ \"9aff\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar eq = __webpack_require__(\"9638\"),\n    isArrayLike = __webpack_require__(\"30c9\"),\n    isIndex = __webpack_require__(\"c098\"),\n    isObject = __webpack_require__(\"1a8c\");\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n\n/***/ }),\n\n/***/ \"9b02\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(\"656b\");\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n\n/***/ }),\n\n/***/ \"9b5f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-grid-container[data-v-5e82e7ed]{position:relative;flex-shrink:1;display:grid;overflow:auto;-webkit-overflow-scrolling:touch}.vc-grid-cell[data-v-5e82e7ed]{display:flex;justify-content:center;align-items:center}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"9bf2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"83ab\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"0cfb\");\nvar anObject = __webpack_require__(\"825a\");\nvar toPrimitive = __webpack_require__(\"c04e\");\n\nvar nativeDefineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.github.io/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return nativeDefineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"9e2e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-pane-container{width:100%;position:relative}.vc-pane-container.in-transition{overflow:hidden}.vc-arrow{display:flex;justify-content:center;align-items:center;cursor:pointer;-webkit-user-select:none;user-select:none;pointer-events:auto;color:var(--gray-600);border-width:2px;border-radius:var(--rounded);border-color:transparent}.vc-arrow:hover{background:var(--gray-200)}.vc-arrow:focus{border-color:var(--gray-300)}.vc-arrow.is-disabled{opacity:.25;pointer-events:none;cursor:not-allowed}.vc-day-popover-container{color:var(--white);background-color:var(--gray-800);border:1px solid;border-color:var(--gray-700);border-radius:var(--rounded);font-size:var(--text-xs);font-weight:var(--font-medium);padding:4px 8px;box-shadow:var(--shadow)}.vc-day-popover-header{font-size:var(--text-xs);color:var(--gray-300);font-weight:var(--font-semibold);text-align:center}.vc-arrows-container{width:100%;position:absolute;top:0;display:flex;justify-content:space-between;padding:8px 10px;pointer-events:none}.vc-arrows-container.title-left{justify-content:flex-end}.vc-arrows-container.title-right{justify-content:flex-start}.vc-is-dark .vc-arrow{color:var(--white)}.vc-is-dark .vc-arrow:hover{background:var(--gray-800)}.vc-is-dark .vc-arrow:focus{border-color:var(--gray-700)}.vc-is-dark .vc-day-popover-container{color:var(--gray-800);background-color:var(--white);border-color:var(--gray-100)}.vc-is-dark .vc-day-popover-header{color:var(--gray-700)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"9e69\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(\"2b3e\");\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n/***/ }),\n\n/***/ \"9e83\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-nav-popover-container{color:var(--white);font-size:var(--text-sm);font-weight:var(--font-semibold);background-color:var(--gray-800);border:1px solid;border-color:var(--gray-700);border-radius:var(--rounded-lg);padding:4px;box-shadow:var(--shadow)}.vc-is-dark .vc-nav-popover-container{color:var(--gray-800);background-color:var(--white);border-color:var(--gray-100)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"9e86\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(\"872a\"),\n    baseForOwn = __webpack_require__(\"242e\"),\n    baseIteratee = __webpack_require__(\"badf\");\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nmodule.exports = mapValues;\n\n\n/***/ }),\n\n/***/ \"9ed3\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar IteratorPrototype = __webpack_require__(\"ae93\").IteratorPrototype;\nvar create = __webpack_require__(\"7c73\");\nvar createPropertyDescriptor = __webpack_require__(\"5c6c\");\nvar setToStringTag = __webpack_require__(\"d44e\");\nvar Iterators = __webpack_require__(\"3f8c\");\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\n\n/***/ }),\n\n/***/ \"9f7f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar fails = __webpack_require__(\"d039\");\n\n// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,\n// so we use an intermediate function.\nfunction RE(s, f) {\n  return RegExp(s, f);\n}\n\nexports.UNSUPPORTED_Y = fails(function () {\n  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\n  var re = RE('a', 'y');\n  re.lastIndex = 2;\n  return re.exec('abcd') != null;\n});\n\nexports.BROKEN_CARET = fails(function () {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n  var re = RE('^r', 'gy');\n  re.lastIndex = 2;\n  return re.exec('str') != null;\n});\n\n\n/***/ }),\n\n/***/ \"a029\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(\"087d\"),\n    getPrototype = __webpack_require__(\"2dcb\"),\n    getSymbols = __webpack_require__(\"32f4\"),\n    stubArray = __webpack_require__(\"d327\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n\n\n/***/ }),\n\n/***/ \"a2be\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SetCache = __webpack_require__(\"d612\"),\n    arraySome = __webpack_require__(\"4284\"),\n    cacheHas = __webpack_require__(\"c584\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Check that cyclic values are equal.\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n\n\n/***/ }),\n\n/***/ \"a2db\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(\"9e69\");\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n\n\n/***/ }),\n\n/***/ \"a3fd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(\"7948\");\n\n/**\n * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n * of key-value pairs for `object` corresponding to the property names of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the key-value pairs.\n */\nfunction baseToPairs(object, props) {\n  return arrayMap(props, function(key) {\n    return [key, object[key]];\n  });\n}\n\nmodule.exports = baseToPairs;\n\n\n/***/ }),\n\n/***/ \"a454\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar constant = __webpack_require__(\"72f0\"),\n    defineProperty = __webpack_require__(\"3b4a\"),\n    identity = __webpack_require__(\"cd9d\");\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n\n\n/***/ }),\n\n/***/ \"a524\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(\"4245\");\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n/***/ }),\n\n/***/ \"a59b\":\n/***/ (function(module, exports) {\n\n/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\nmodule.exports = head;\n\n\n/***/ }),\n\n/***/ \"a691\":\n/***/ (function(module, exports) {\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.github.io/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\n\n/***/ }),\n\n/***/ \"a994\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetAllKeys = __webpack_require__(\"7d1f\"),\n    getSymbols = __webpack_require__(\"32f4\"),\n    keys = __webpack_require__(\"ec69\");\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n\n\n/***/ }),\n\n/***/ \"a997\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-pane[data-v-3491b290]{flex-grow:1;flex-shrink:1;display:flex;flex-direction:column;justify-content:center;align-items:stretch}.vc-horizontal-divider[data-v-3491b290]{align-self:center}.vc-header[data-v-3491b290]{flex-shrink:0;display:flex;align-items:stretch;color:var(--gray-900);-webkit-user-select:none;user-select:none;padding:10px 10px 0 10px}.vc-header.align-left[data-v-3491b290]{order:-1;justify-content:flex-start}.vc-header.align-right[data-v-3491b290]{order:1;justify-content:flex-end}.vc-title-layout[data-v-3491b290]{display:flex;justify-content:center;align-items:center;flex-grow:1}.vc-title-layout.align-left[data-v-3491b290]{justify-content:flex-start}.vc-title-layout.align-right[data-v-3491b290]{justify-content:flex-end}.vc-title-wrapper[data-v-3491b290]{position:relative}.vc-title[data-v-3491b290]{font-size:var(--text-lg);color:var(--gray-800);font-weight:var(--font-semibold);cursor:pointer;-webkit-user-select:none;user-select:none;white-space:nowrap;padding:0 8px}.vc-title[data-v-3491b290]:hover{opacity:.75}.vc-weekday[data-v-3491b290]{display:flex;justify-content:center;align-items:center;flex:1;color:var(--gray-500);font-size:var(--text-sm);font-weight:var(--font-bold);padding:5px 0;cursor:default;-webkit-user-select:none;user-select:none}.vc-weeks[data-v-3491b290]{flex-shrink:1;flex-grow:1;padding:5px 6px 7px 6px}.vc-is-dark .vc-header[data-v-3491b290]{color:var(--gray-200)}.vc-is-dark .vc-title[data-v-3491b290]{color:var(--gray-100)}.vc-is-dark .vc-weekday[data-v-3491b290]{color:var(--accent-200)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"ac1f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"23e7\");\nvar exec = __webpack_require__(\"9263\");\n\n$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {\n  exec: exec\n});\n\n\n/***/ }),\n\n/***/ \"ac41\":\n/***/ (function(module, exports) {\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n\n\n/***/ }),\n\n/***/ \"ad6d\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar anObject = __webpack_require__(\"825a\");\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"ae93\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar getPrototypeOf = __webpack_require__(\"e163\");\nvar createNonEnumerableProperty = __webpack_require__(\"9112\");\nvar has = __webpack_require__(\"5135\");\nvar wellKnownSymbol = __webpack_require__(\"b622\");\nvar IS_PURE = __webpack_require__(\"c430\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false;\n\nvar returnThis = function () { return this; };\n\n// `%IteratorPrototype%` object\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nif (IteratorPrototype == undefined) IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nif (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {\n  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n}\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n\n/***/ }),\n\n/***/ \"b047\":\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n/***/ }),\n\n/***/ \"b1d2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(\"3729\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar dateTag = '[object Date]';\n\n/**\n * The base implementation of `_.isDate` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n */\nfunction baseIsDate(value) {\n  return isObjectLike(value) && baseGetTag(value) == dateTag;\n}\n\nmodule.exports = baseIsDate;\n\n\n/***/ }),\n\n/***/ \"b1e5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getAllKeys = __webpack_require__(\"a994\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Check that cyclic values are equal.\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n\n\n/***/ }),\n\n/***/ \"b218\":\n/***/ (function(module, exports) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n/***/ }),\n\n/***/ \"b4b0\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"1a8c\"),\n    isSymbol = __webpack_require__(\"ffd6\");\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n\n\n/***/ }),\n\n/***/ \"b4c0\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(\"cb5a\");\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n/***/ }),\n\n/***/ \"b5a7\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(\"0b07\"),\n    root = __webpack_require__(\"2b3e\");\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n\n\n/***/ }),\n\n/***/ \"b622\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"da84\");\nvar shared = __webpack_require__(\"5692\");\nvar has = __webpack_require__(\"5135\");\nvar uid = __webpack_require__(\"90e3\");\nvar NATIVE_SYMBOL = __webpack_require__(\"4930\");\nvar USE_SYMBOL_AS_UID = __webpack_require__(\"fdbf\");\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!has(WellKnownSymbolsStore, name)) {\n    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];\n    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n  } return WellKnownSymbolsStore[name];\n};\n\n\n/***/ }),\n\n/***/ \"b760\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(\"872a\"),\n    eq = __webpack_require__(\"9638\");\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n\n\n/***/ }),\n\n/***/ \"b7fe\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-select[data-v-26a07a51]{position:relative}.vc-select select[data-v-26a07a51]{flex-grow:1;display:block;-webkit-appearance:none;appearance:none;width:52px;height:30px;font-weight:var(--font-medium);text-align:left;background-color:var(--gray-200);border:2px solid;border-color:var(--gray-200);color:var(--gray-700);padding:0 20px 0 8px;border-radius:var(--rounded);line-height:var(--leading-tight);text-indent:0;cursor:pointer;-moz-padding-start:3px}.vc-select select[data-v-26a07a51]:hover{color:var(--gray-600)}.vc-select select[data-v-26a07a51]:focus{outline:0;border-color:var(--accent-400);background-color:var(--white)}.vc-select-arrow[data-v-26a07a51]{display:flex;align-items:center;pointer-events:none;position:absolute;top:0;bottom:0;right:0;padding:0 4px 0 0;color:var(--gray-700)}.vc-select-arrow svg[data-v-26a07a51]{width:16px;height:16px;fill:currentColor}.vc-is-dark select[data-v-26a07a51]{background:var(--gray-700);color:var(--gray-100);border-color:var(--gray-700)}.vc-is-dark select[data-v-26a07a51]:hover{color:var(--gray-400)}.vc-is-dark select[data-v-26a07a51]:focus{border-color:var(--accent-500);background-color:var(--gray-800)}.vc-is-dark .vc-select-arrow[data-v-26a07a51]{color:var(--gray-300)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"b803\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-day-popover-row[data-v-4975d69e]{--day-content-transition-time:0.13s ease-in;display:flex;align-items:center;transition:all var(--day-content-transition-time)}.vc-day-popover-row[data-v-4975d69e]:not(:first-child){margin-top:3px}.vc-day-popover-row-indicator[data-v-4975d69e]{display:flex;justify-content:center;align-items:center;flex-grow:0;width:15px;margin-right:3px}.vc-day-popover-row-indicator span[data-v-4975d69e]{transition:all var(--day-content-transition-time)}.vc-day-popover-row-content[data-v-4975d69e]{display:flex;align-items:center;flex-wrap:none;flex-grow:1;width:-webkit-max-content;width:max-content}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"bab4\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarPane_vue_vue_type_style_index_0_id_3491b290_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"0f62\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarPane_vue_vue_type_style_index_0_id_3491b290_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarPane_vue_vue_type_style_index_0_id_3491b290_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CalendarPane_vue_vue_type_style_index_0_id_3491b290_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"badf\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseMatches = __webpack_require__(\"642a\"),\n    baseMatchesProperty = __webpack_require__(\"1838\"),\n    identity = __webpack_require__(\"cd9d\"),\n    isArray = __webpack_require__(\"6747\"),\n    property = __webpack_require__(\"f9ce\");\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n\n\n/***/ }),\n\n/***/ \"bbc0\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(\"6044\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n/***/ }),\n\n/***/ \"c04e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"861d\");\n\n// `ToPrimitive` abstract operation\n// https://tc39.github.io/ecma262/#sec-toprimitive\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (input, PREFERRED_STRING) {\n  if (!isObject(input)) return input;\n  var fn, val;\n  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n\n/***/ \"c05f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsEqualDeep = __webpack_require__(\"7b97\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n\n\n/***/ }),\n\n/***/ \"c098\":\n/***/ (function(module, exports) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n/***/ }),\n\n/***/ \"c1c9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseSetToString = __webpack_require__(\"a454\"),\n    shortOut = __webpack_require__(\"f3c1\");\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n\n\n/***/ }),\n\n/***/ \"c2b6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cloneArrayBuffer = __webpack_require__(\"f8af\"),\n    cloneDataView = __webpack_require__(\"5d89\"),\n    cloneRegExp = __webpack_require__(\"6f6c\"),\n    cloneSymbol = __webpack_require__(\"a2db\"),\n    cloneTypedArray = __webpack_require__(\"c8fe\");\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n\n\n/***/ }),\n\n/***/ \"c3ea\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Grid_vue_vue_type_style_index_0_id_5e82e7ed_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"d57d\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Grid_vue_vue_type_style_index_0_id_5e82e7ed_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Grid_vue_vue_type_style_index_0_id_5e82e7ed_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Grid_vue_vue_type_style_index_0_id_5e82e7ed_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"c3fc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getTag = __webpack_require__(\"42a2\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n\n\n/***/ }),\n\n/***/ \"c430\":\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n\n/***/ }),\n\n/***/ \"c547\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-popover-content-wrapper[data-v-6c8a2a3c]{--popover-horizontal-content-offset:8px;--popover-vertical-content-offset:10px;--popover-slide-translation:15px;--popover-transition-time:0.14s ease-in-out;--popover-caret-horizontal-offset:18px;--popover-caret-vertical-offset:8px;position:absolute;display:block;outline:none;z-index:10}.vc-popover-content-wrapper[data-v-6c8a2a3c]:not(.is-interactive){pointer-events:none}.vc-popover-content[data-v-6c8a2a3c]{position:relative;outline:none;z-index:10;box-shadow:var(--shadow-lg)}.vc-popover-content.direction-bottom[data-v-6c8a2a3c]{margin-top:var(--popover-vertical-content-offset)}.vc-popover-content.direction-top[data-v-6c8a2a3c]{margin-bottom:var(--popover-vertical-content-offset)}.vc-popover-content.direction-left[data-v-6c8a2a3c]{margin-right:var(--popover-horizontal-content-offset)}.vc-popover-content.direction-right[data-v-6c8a2a3c]{margin-left:var(--popover-horizontal-content-offset)}.vc-popover-caret[data-v-6c8a2a3c]{content:\\\"\\\";position:absolute;display:block;width:12px;height:12px;border-top:inherit;border-left:inherit;background-color:inherit;z-index:-1}.vc-popover-caret.direction-bottom[data-v-6c8a2a3c]{top:0}.vc-popover-caret.direction-bottom.align-left[data-v-6c8a2a3c]{transform:translateY(-50%) rotate(45deg)}.vc-popover-caret.direction-bottom.align-center[data-v-6c8a2a3c]{transform:translateX(-50%) translateY(-50%) rotate(45deg)}.vc-popover-caret.direction-bottom.align-right[data-v-6c8a2a3c]{transform:translateY(-50%) rotate(45deg)}.vc-popover-caret.direction-top[data-v-6c8a2a3c]{top:100%}.vc-popover-caret.direction-top.align-left[data-v-6c8a2a3c]{transform:translateY(-50%) rotate(-135deg)}.vc-popover-caret.direction-top.align-center[data-v-6c8a2a3c]{transform:translateX(-50%) translateY(-50%) rotate(-135deg)}.vc-popover-caret.direction-top.align-right[data-v-6c8a2a3c]{transform:translateY(-50%) rotate(-135deg)}.vc-popover-caret.direction-left[data-v-6c8a2a3c]{left:100%}.vc-popover-caret.direction-left.align-top[data-v-6c8a2a3c]{transform:translateX(-50%) rotate(135deg)}.vc-popover-caret.direction-left.align-middle[data-v-6c8a2a3c]{transform:translateY(-50%) translateX(-50%) rotate(135deg)}.vc-popover-caret.direction-left.align-bottom[data-v-6c8a2a3c]{transform:translateX(-50%) rotate(135deg)}.vc-popover-caret.direction-right[data-v-6c8a2a3c]{left:0}.vc-popover-caret.direction-right.align-top[data-v-6c8a2a3c]{transform:translateX(-50%) rotate(-45deg)}.vc-popover-caret.direction-right.align-middle[data-v-6c8a2a3c]{transform:translateY(-50%) translateX(-50%) rotate(-45deg)}.vc-popover-caret.direction-right.align-bottom[data-v-6c8a2a3c]{transform:translateX(-50%) rotate(-45deg)}.vc-popover-caret.align-left[data-v-6c8a2a3c]{left:var(--popover-caret-horizontal-offset)}.vc-popover-caret.align-center[data-v-6c8a2a3c]{left:50%}.vc-popover-caret.align-right[data-v-6c8a2a3c]{right:var(--popover-caret-horizontal-offset)}.vc-popover-caret.align-top[data-v-6c8a2a3c]{top:var(--popover-caret-vertical-offset)}.vc-popover-caret.align-middle[data-v-6c8a2a3c]{top:50%}.vc-popover-caret.align-bottom[data-v-6c8a2a3c]{bottom:var(--popover-caret-vertical-offset)}.fade-enter-active[data-v-6c8a2a3c],.fade-leave-active[data-v-6c8a2a3c],.slide-fade-enter-active[data-v-6c8a2a3c],.slide-fade-leave-active[data-v-6c8a2a3c]{transition:all var(--popover-transition-time);pointer-events:none}.fade-enter[data-v-6c8a2a3c],.fade-leave-to[data-v-6c8a2a3c],.slide-fade-enter[data-v-6c8a2a3c],.slide-fade-leave-to[data-v-6c8a2a3c]{opacity:0}.slide-fade-enter.direction-bottom[data-v-6c8a2a3c],.slide-fade-leave-to.direction-bottom[data-v-6c8a2a3c]{transform:translateY(calc(var(--popover-slide-translation)*-1))}.slide-fade-enter.direction-top[data-v-6c8a2a3c],.slide-fade-leave-to.direction-top[data-v-6c8a2a3c]{transform:translateY(var(--popover-slide-translation))}.slide-fade-enter.direction-left[data-v-6c8a2a3c],.slide-fade-leave-to.direction-left[data-v-6c8a2a3c]{transform:translateX(var(--popover-slide-translation))}.slide-fade-enter.direction-right[data-v-6c8a2a3c],.slide-fade-leave-to.direction-right[data-v-6c8a2a3c]{transform:translateX(calc(var(--popover-slide-translation)*-1))}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"c584\":\n/***/ (function(module, exports) {\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n\n\n/***/ }),\n\n/***/ \"c6b6\":\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ \"c6cd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"da84\");\nvar setGlobal = __webpack_require__(\"ce4e\");\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n\n\n/***/ }),\n\n/***/ \"c6cf\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar flatten = __webpack_require__(\"4d8c\"),\n    overRest = __webpack_require__(\"2286\"),\n    setToString = __webpack_require__(\"c1c9\");\n\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */\nfunction flatRest(func) {\n  return setToString(overRest(func, undefined, flatten), func + '');\n}\n\nmodule.exports = flatRest;\n\n\n/***/ }),\n\n/***/ \"c869\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(\"0b07\"),\n    root = __webpack_require__(\"2b3e\");\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n\n\n/***/ }),\n\n/***/ \"c87c\":\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n\n\n/***/ }),\n\n/***/ \"c8ba\":\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"c8fe\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cloneArrayBuffer = __webpack_require__(\"f8af\");\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n\n\n/***/ }),\n\n/***/ \"ca84\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(\"5135\");\nvar toIndexedObject = __webpack_require__(\"fc6a\");\nvar indexOf = __webpack_require__(\"4d64\").indexOf;\nvar hiddenKeys = __webpack_require__(\"d012\");\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"cb5a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar eq = __webpack_require__(\"9638\");\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n/***/ }),\n\n/***/ \"cc12\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"da84\");\nvar isObject = __webpack_require__(\"861d\");\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ \"cc2e\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SvgIcon_vue_vue_type_style_index_0_id_19b6cf78_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"8dad\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SvgIcon_vue_vue_type_style_index_0_id_19b6cf78_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SvgIcon_vue_vue_type_style_index_0_id_19b6cf78_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SvgIcon_vue_vue_type_style_index_0_id_19b6cf78_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"cc45\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsMap = __webpack_require__(\"1a2d\"),\n    baseUnary = __webpack_require__(\"b047\"),\n    nodeUtil = __webpack_require__(\"99d3\");\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n\n\n/***/ }),\n\n/***/ \"cd9d\":\n/***/ (function(module, exports) {\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n/***/ }),\n\n/***/ \"ce4e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"da84\");\nvar createNonEnumerableProperty = __webpack_require__(\"9112\");\n\nmodule.exports = function (key, value) {\n  try {\n    createNonEnumerableProperty(global, key, value);\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n/***/ }),\n\n/***/ \"ce86\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(\"9e69\"),\n    arrayMap = __webpack_require__(\"7948\"),\n    isArray = __webpack_require__(\"6747\"),\n    isSymbol = __webpack_require__(\"ffd6\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n\n\n/***/ }),\n\n/***/ \"cebd\":\n/***/ (function(module, exports) {\n\n/**\n * Converts `set` to its value-value pairs.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the value-value pairs.\n */\nfunction setToPairs(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = [value, value];\n  });\n  return result;\n}\n\nmodule.exports = setToPairs;\n\n\n/***/ }),\n\n/***/ \"d012\":\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ \"d02c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ListCache = __webpack_require__(\"5e2e\"),\n    Map = __webpack_require__(\"79bc\"),\n    MapCache = __webpack_require__(\"7b83\");\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n\n\n/***/ }),\n\n/***/ \"d039\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"d066\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar path = __webpack_require__(\"428f\");\nvar global = __webpack_require__(\"da84\");\n\nvar aFunction = function (variable) {\n  return typeof variable == 'function' ? variable : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])\n    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];\n};\n\n\n/***/ }),\n\n/***/ \"d1e7\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\n\n\n/***/ }),\n\n/***/ \"d23e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"e207\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"4e63485a\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"d2bb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"825a\");\nvar aPossiblePrototype = __webpack_require__(\"3bbe\");\n\n// `Object.setPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n/***/ }),\n\n/***/ \"d327\":\n/***/ (function(module, exports) {\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n\n\n/***/ }),\n\n/***/ \"d370\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsArguments = __webpack_require__(\"253c\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n/***/ }),\n\n/***/ \"d44e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(\"9bf2\").f;\nvar has = __webpack_require__(\"5135\");\nvar wellKnownSymbol = __webpack_require__(\"b622\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\nmodule.exports = function (it, TAG, STATIC) {\n  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n\n\n/***/ }),\n\n/***/ \"d57d\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"9b5f\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"5292e2aa\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"d612\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MapCache = __webpack_require__(\"7b83\"),\n    setCacheAdd = __webpack_require__(\"7ed2\"),\n    setCacheHas = __webpack_require__(\"dc0f\");\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n\n\n/***/ }),\n\n/***/ \"d6f8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_TimePicker_vue_vue_type_style_index_0_id_31a34bc2_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"d23e\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_TimePicker_vue_vue_type_style_index_0_id_31a34bc2_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_TimePicker_vue_vue_type_style_index_0_id_31a34bc2_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_TimePicker_vue_vue_type_style_index_0_id_31a34bc2_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"d784\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// TODO: Remove from `core-js@4` since it's moved to entry points\n__webpack_require__(\"ac1f\");\nvar redefine = __webpack_require__(\"6eeb\");\nvar fails = __webpack_require__(\"d039\");\nvar wellKnownSymbol = __webpack_require__(\"b622\");\nvar regexpExec = __webpack_require__(\"9263\");\nvar createNonEnumerableProperty = __webpack_require__(\"9112\");\n\nvar SPECIES = wellKnownSymbol('species');\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  // #replace needs built-in support for named groups.\n  // #match works fine because it just return the exec results, even if it has\n  // a \"grops\" property.\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  return ''.replace(re, '$<a>') !== '7';\n});\n\n// IE <= 11 replaces $0 with the whole match, as if it was $&\n// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0\nvar REPLACE_KEEPS_$0 = (function () {\n  return 'a'.replace(/./, '$0') === '$0';\n})();\n\nvar REPLACE = wellKnownSymbol('replace');\n// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string\nvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {\n  if (/./[REPLACE]) {\n    return /./[REPLACE]('a', '$0') === '';\n  }\n  return false;\n})();\n\n// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n});\n\nmodule.exports = function (KEY, length, exec, sham) {\n  var SYMBOL = wellKnownSymbol(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    if (KEY === 'split') {\n      // We can't use real regex here since it causes deoptimization\n      // and serious performance degradation in V8\n      // https://github.com/zloirock/core-js/issues/306\n      re = {};\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n      re.flags = '';\n      re[SYMBOL] = /./[SYMBOL];\n    }\n\n    re.exec = function () { execCalled = true; return null; };\n\n    re[SYMBOL]('');\n    return !execCalled;\n  });\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    (KEY === 'replace' && !(\n      REPLACE_SUPPORTS_NAMED_GROUPS &&\n      REPLACE_KEEPS_$0 &&\n      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE\n    )) ||\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\n  ) {\n    var nativeRegExpMethod = /./[SYMBOL];\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n      if (regexp.exec === regexpExec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\n        }\n        return { done: true, value: nativeMethod.call(str, regexp, arg2) };\n      }\n      return { done: false };\n    }, {\n      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,\n      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE\n    });\n    var stringMethod = methods[0];\n    var regexMethod = methods[1];\n\n    redefine(String.prototype, KEY, stringMethod);\n    redefine(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return regexMethod.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return regexMethod.call(string, this); }\n    );\n  }\n\n  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);\n};\n\n\n/***/ }),\n\n/***/ \"d7ee\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsSet = __webpack_require__(\"c3fc\"),\n    baseUnary = __webpack_require__(\"b047\"),\n    nodeUtil = __webpack_require__(\"99d3\");\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n\n\n/***/ }),\n\n/***/ \"da03\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(\"2b3e\");\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n/***/ }),\n\n/***/ \"da84\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line no-undef\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func\n  Function('return this')();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"c8ba\")))\n\n/***/ }),\n\n/***/ \"dc0f\":\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n\n\n/***/ }),\n\n/***/ \"dc57\":\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n/***/ }),\n\n/***/ \"dc8c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-container{--white:#fff;--black:#000;--gray-100:#f7fafc;--gray-200:#edf2f7;--gray-300:#e2e8f0;--gray-400:#cbd5e0;--gray-500:#a0aec0;--gray-600:#718096;--gray-700:#4a5568;--gray-800:#2d3748;--gray-900:#1a202c;--red-100:#fff5f5;--red-200:#fed7d7;--red-300:#feb2b2;--red-400:#fc8181;--red-500:#f56565;--red-600:#e53e3e;--red-700:#c53030;--red-800:#9b2c2c;--red-900:#742a2a;--orange-100:#fffaf0;--orange-200:#feebc8;--orange-300:#fbd38d;--orange-400:#f6ad55;--orange-500:#ed8936;--orange-600:#dd6b20;--orange-700:#c05621;--orange-800:#9c4221;--orange-900:#7b341e;--yellow-100:ivory;--yellow-200:#fefcbf;--yellow-300:#faf089;--yellow-400:#f6e05e;--yellow-500:#ecc94b;--yellow-600:#d69e2e;--yellow-700:#b7791f;--yellow-800:#975a16;--yellow-900:#744210;--green-100:#f0fff4;--green-200:#c6f6d5;--green-300:#9ae6b4;--green-400:#68d391;--green-500:#48bb78;--green-600:#38a169;--green-700:#2f855a;--green-800:#276749;--green-900:#22543d;--teal-100:#e6fffa;--teal-200:#b2f5ea;--teal-300:#81e6d9;--teal-400:#4fd1c5;--teal-500:#38b2ac;--teal-600:#319795;--teal-700:#2c7a7b;--teal-800:#285e61;--teal-900:#234e52;--blue-100:#ebf8ff;--blue-200:#bee3f8;--blue-300:#90cdf4;--blue-400:#63b3ed;--blue-500:#4299e1;--blue-600:#3182ce;--blue-700:#2b6cb0;--blue-800:#2c5282;--blue-900:#2a4365;--indigo-100:#ebf4ff;--indigo-200:#c3dafe;--indigo-300:#a3bffa;--indigo-400:#7f9cf5;--indigo-500:#667eea;--indigo-600:#5a67d8;--indigo-700:#4c51bf;--indigo-800:#434190;--indigo-900:#3c366b;--purple-100:#faf5ff;--purple-200:#e9d8fd;--purple-300:#d6bcfa;--purple-400:#b794f4;--purple-500:#9f7aea;--purple-600:#805ad5;--purple-700:#6b46c1;--purple-800:#553c9a;--purple-900:#44337a;--pink-100:#fff5f7;--pink-200:#fed7e2;--pink-300:#fbb6ce;--pink-400:#f687b3;--pink-500:#ed64a6;--pink-600:#d53f8c;--pink-700:#b83280;--pink-800:#97266d;--pink-900:#702459}.vc-container.vc-red{--accent-100:var(--red-100);--accent-200:var(--red-200);--accent-300:var(--red-300);--accent-400:var(--red-400);--accent-500:var(--red-500);--accent-600:var(--red-600);--accent-700:var(--red-700);--accent-800:var(--red-800);--accent-900:var(--red-900)}.vc-container.vc-orange{--accent-100:var(--orange-100);--accent-200:var(--orange-200);--accent-300:var(--orange-300);--accent-400:var(--orange-400);--accent-500:var(--orange-500);--accent-600:var(--orange-600);--accent-700:var(--orange-700);--accent-800:var(--orange-800);--accent-900:var(--orange-900)}.vc-container.vc-yellow{--accent-100:var(--yellow-100);--accent-200:var(--yellow-200);--accent-300:var(--yellow-300);--accent-400:var(--yellow-400);--accent-500:var(--yellow-500);--accent-600:var(--yellow-600);--accent-700:var(--yellow-700);--accent-800:var(--yellow-800);--accent-900:var(--yellow-900)}.vc-container.vc-green{--accent-100:var(--green-100);--accent-200:var(--green-200);--accent-300:var(--green-300);--accent-400:var(--green-400);--accent-500:var(--green-500);--accent-600:var(--green-600);--accent-700:var(--green-700);--accent-800:var(--green-800);--accent-900:var(--green-900)}.vc-container.vc-teal{--accent-100:var(--teal-100);--accent-200:var(--teal-200);--accent-300:var(--teal-300);--accent-400:var(--teal-400);--accent-500:var(--teal-500);--accent-600:var(--teal-600);--accent-700:var(--teal-700);--accent-800:var(--teal-800);--accent-900:var(--teal-900)}.vc-container.vc-blue{--accent-100:var(--blue-100);--accent-200:var(--blue-200);--accent-300:var(--blue-300);--accent-400:var(--blue-400);--accent-500:var(--blue-500);--accent-600:var(--blue-600);--accent-700:var(--blue-700);--accent-800:var(--blue-800);--accent-900:var(--blue-900)}.vc-container.vc-indigo{--accent-100:var(--indigo-100);--accent-200:var(--indigo-200);--accent-300:var(--indigo-300);--accent-400:var(--indigo-400);--accent-500:var(--indigo-500);--accent-600:var(--indigo-600);--accent-700:var(--indigo-700);--accent-800:var(--indigo-800);--accent-900:var(--indigo-900)}.vc-container.vc-purple{--accent-100:var(--purple-100);--accent-200:var(--purple-200);--accent-300:var(--purple-300);--accent-400:var(--purple-400);--accent-500:var(--purple-500);--accent-600:var(--purple-600);--accent-700:var(--purple-700);--accent-800:var(--purple-800);--accent-900:var(--purple-900)}.vc-container.vc-pink{--accent-100:var(--pink-100);--accent-200:var(--pink-200);--accent-300:var(--pink-300);--accent-400:var(--pink-400);--accent-500:var(--pink-500);--accent-600:var(--pink-600);--accent-700:var(--pink-700);--accent-800:var(--pink-800);--accent-900:var(--pink-900)}.vc-container{--font-normal:400;--font-medium:500;--font-semibold:600;--font-bold:700;--text-xs:12px;--text-sm:14px;--text-base:16px;--text-lg:18px;--leading-snug:1.375;--rounded:0.25rem;--rounded-lg:0.5rem;--rounded-full:9999px;--shadow:0 1px 3px 0 rgba(0,0,0,0.1),0 1px 2px 0 rgba(0,0,0,0.06);--shadow-lg:0 10px 15px -3px rgba(0,0,0,0.1),0 4px 6px -2px rgba(0,0,0,0.05);--shadow-inner:inset 0 2px 4px 0 rgba(0,0,0,0.06);--slide-translate:22px;--slide-duration:0.15s;--slide-timing:ease;--day-content-transition-time:0.13s ease-in;font-family:BlinkMacSystemFont,-apple-system,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,Helvetica,Arial,sans-serif;color:var(--gray-900);background-color:var(--white);border:1px solid;border-color:var(--gray-400);border-radius:var(--rounded-lg);position:relative;width:-webkit-max-content;width:max-content;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-tap-highlight-color:transparent}.vc-container,.vc-container *{box-sizing:border-box}.vc-container:focus,.vc-container :focus{outline:none}.vc-container [role=button],.vc-container button{cursor:pointer}.vc-container.vc-is-expanded{min-width:100%}.vc-container .vc-container{border:none}.vc-container.vc-is-dark{color:var(--gray-100);background-color:var(--gray-900);border-color:var(--gray-700)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"dcbe\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(\"30c9\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n\n\n/***/ }),\n\n/***/ \"dd61\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(\"7948\"),\n    baseIteratee = __webpack_require__(\"badf\"),\n    baseMap = __webpack_require__(\"97d3\"),\n    isArray = __webpack_require__(\"6747\");\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n\n\n/***/ }),\n\n/***/ \"dd71\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Popover_vue_vue_type_style_index_0_id_6c8a2a3c_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"8e2e\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Popover_vue_vue_type_style_index_0_id_6c8a2a3c_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Popover_vue_vue_type_style_index_0_id_6c8a2a3c_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Popover_vue_vue_type_style_index_0_id_6c8a2a3c_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"ddb0\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"da84\");\nvar DOMIterables = __webpack_require__(\"fdbc\");\nvar ArrayIteratorMethods = __webpack_require__(\"e260\");\nvar createNonEnumerableProperty = __webpack_require__(\"9112\");\nvar wellKnownSymbol = __webpack_require__(\"b622\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  var Collection = global[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG]) {\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n}\n\n\n/***/ }),\n\n/***/ \"de5e\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Calendar_vue_vue_type_style_index_0_lang_postcss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"72f5\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Calendar_vue_vue_type_style_index_0_lang_postcss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Calendar_vue_vue_type_style_index_0_lang_postcss___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Calendar_vue_vue_type_style_index_0_lang_postcss___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"df75\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(\"ca84\");\nvar enumBugKeys = __webpack_require__(\"7839\");\n\n// `Object.keys` method\n// https://tc39.github.io/ecma262/#sec-object.keys\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n/***/ }),\n\n/***/ \"df9e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"9e83\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"29f48e5f\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"e031\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseMerge = __webpack_require__(\"f909\"),\n    isObject = __webpack_require__(\"1a8c\");\n\n/**\n * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n * objects into destination objects that are passed thru.\n *\n * @private\n * @param {*} objValue The destination value.\n * @param {*} srcValue The source value.\n * @param {string} key The key of the property to merge.\n * @param {Object} object The parent object of `objValue`.\n * @param {Object} source The parent object of `srcValue`.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n * @returns {*} Returns the value to assign.\n */\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n  if (isObject(objValue) && isObject(srcValue)) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, objValue);\n    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n    stack['delete'](srcValue);\n  }\n  return objValue;\n}\n\nmodule.exports = customDefaultsMerge;\n\n\n/***/ }),\n\n/***/ \"e0e7\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isPlainObject = __webpack_require__(\"60ed\");\n\n/**\n * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n * objects.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {string} key The key of the property to inspect.\n * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n */\nfunction customOmitClone(value) {\n  return isPlainObject(value) ? undefined : value;\n}\n\nmodule.exports = customOmitClone;\n\n\n/***/ }),\n\n/***/ \"e163\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(\"5135\");\nvar toObject = __webpack_require__(\"7b0b\");\nvar sharedKey = __webpack_require__(\"f772\");\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(\"e177\");\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar ObjectPrototype = Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.getprototypeof\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectPrototype : null;\n};\n\n\n/***/ }),\n\n/***/ \"e177\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"d039\");\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n/***/ }),\n\n/***/ \"e207\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(\"24fb\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".vc-time-container[data-v-31a34bc2]{display:flex;align-items:center;padding:0 8px 8px 8px}.vc-time-container.vc-invalid[data-v-31a34bc2]{pointer-events:none;opacity:1%}.vc-time-container[data-v-31a34bc2]:not(:first-child){border-top:1px solid var(--gray-400)}.vc-date-time[data-v-31a34bc2]{margin-left:8px}.vc-time-icon[data-v-31a34bc2]{width:16px;height:16px;color:var(--gray-600)}.vc-date[data-v-31a34bc2]{display:flex;align-items:center;font-size:var(--text-sm);font-weight:var(--font-semibold);text-transform:uppercase;padding:4px 0 4px 4px}.vc-date .vc-weekday[data-v-31a34bc2]{color:var(--gray-700);letter-spacing:var(--tracking-wide)}.vc-date .vc-month[data-v-31a34bc2]{color:var(--accent-600);margin-left:8px}.vc-date .vc-day[data-v-31a34bc2]{color:var(--accent-600);margin-left:4px}.vc-date .vc-year[data-v-31a34bc2]{color:var(--gray-500);margin-left:8px}.vc-am-pm[data-v-31a34bc2],.vc-time[data-v-31a34bc2]{display:flex;align-items:center}.vc-am-pm[data-v-31a34bc2]{background:var(--gray-200);color:var(--gray-800);margin-left:8px;padding:4px;border-radius:var(--rounded);height:30px}.vc-am-pm button[data-v-31a34bc2]{font-size:var(--text-sm);font-weight:var(--font-medium);padding:0 4px;border:2px solid transparent;border-radius:var(--rounded);line-height:var(--leading-snug)}.vc-am-pm button[data-v-31a34bc2]:hover{color:var(--gray-600)}.vc-am-pm button[data-v-31a34bc2]:focus{border-color:var(--accent-400)}.vc-am-pm button.active[data-v-31a34bc2]{background:var(--accent-600);color:var(--white)}.vc-am-pm button.active[data-v-31a34bc2]:hover{background:var(--accent-500)}.vc-am-pm button.active[data-v-31a34bc2]:focus{border-color:var(--accent-400)}.vc-is-dark .vc-time-container[data-v-31a34bc2]{border-color:var(--gray-700)}.vc-is-dark .vc-time-icon[data-v-31a34bc2],.vc-is-dark .vc-weekday[data-v-31a34bc2]{color:var(--gray-400)}.vc-is-dark .vc-day[data-v-31a34bc2],.vc-is-dark .vc-month[data-v-31a34bc2]{color:var(--accent-400)}.vc-is-dark .vc-year[data-v-31a34bc2]{color:var(--gray-500)}.vc-is-dark .vc-am-pm[data-v-31a34bc2]{background:var(--gray-700);color:var(--gray-100)}.vc-is-dark .vc-am-pm[data-v-31a34bc2]:focus{border-color:var(--accent-500)}.vc-is-dark .vc-am-pm button[data-v-31a34bc2]:hover{color:var(--gray-400)}.vc-is-dark .vc-am-pm button[data-v-31a34bc2]:focus{border-color:var(--accent-500)}.vc-is-dark .vc-am-pm button.active[data-v-31a34bc2]{background:var(--accent-500);color:var(--white)}.vc-is-dark .vc-am-pm button.active[data-v-31a34bc2]:hover{background:var(--accent-600)}.vc-is-dark .vc-am-pm button.active[data-v-31a34bc2]:focus{border-color:var(--accent-500)}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n/***/ }),\n\n/***/ \"e24b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hashClear = __webpack_require__(\"49f4\"),\n    hashDelete = __webpack_require__(\"1efc\"),\n    hashGet = __webpack_require__(\"bbc0\"),\n    hashHas = __webpack_require__(\"7a48\"),\n    hashSet = __webpack_require__(\"2524\");\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n/***/ }),\n\n/***/ \"e260\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toIndexedObject = __webpack_require__(\"fc6a\");\nvar addToUnscopables = __webpack_require__(\"44d2\");\nvar Iterators = __webpack_require__(\"3f8c\");\nvar InternalStateModule = __webpack_require__(\"69f3\");\nvar defineIterator = __webpack_require__(\"7dd0\");\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.github.io/ecma262/#sec-createarrayiterator\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject\nIterators.Arguments = Iterators.Array;\n\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/***/ }),\n\n/***/ \"e2a0\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(\"3729\"),\n    isArray = __webpack_require__(\"6747\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n\n\n/***/ }),\n\n/***/ \"e2c0\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar castPath = __webpack_require__(\"e2e4\"),\n    isArguments = __webpack_require__(\"d370\"),\n    isArray = __webpack_require__(\"6747\"),\n    isIndex = __webpack_require__(\"c098\"),\n    isLength = __webpack_require__(\"b218\"),\n    toKey = __webpack_require__(\"f4d6\");\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n\n\n/***/ }),\n\n/***/ \"e2e4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(\"6747\"),\n    isKey = __webpack_require__(\"f608\"),\n    stringToPath = __webpack_require__(\"18d8\"),\n    toString = __webpack_require__(\"76dd\");\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n\n\n/***/ }),\n\n/***/ \"e380\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MapCache = __webpack_require__(\"7b83\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n\n\n/***/ }),\n\n/***/ \"e3f8\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(\"656b\");\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n\n\n/***/ }),\n\n/***/ \"e538\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(\"2b3e\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"62e4\")(module)))\n\n/***/ }),\n\n/***/ \"e76f\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CustomTransition_vue_vue_type_style_index_0_id_8466592e_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"255e\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CustomTransition_vue_vue_type_style_index_0_id_8466592e_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CustomTransition_vue_vue_type_style_index_0_id_8466592e_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CustomTransition_vue_vue_type_style_index_0_id_8466592e_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"e893\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(\"5135\");\nvar ownKeys = __webpack_require__(\"56ef\");\nvar getOwnPropertyDescriptorModule = __webpack_require__(\"06cf\");\nvar definePropertyModule = __webpack_require__(\"9bf2\");\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n\n\n/***/ }),\n\n/***/ \"e969\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(\"0da5\");\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(\"499e\").default\nvar update = add(\"61c2bd5e\", content, true, {\"sourceMap\":false,\"shadowMode\":false});\n\n/***/ }),\n\n/***/ \"eac5\":\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n/***/ }),\n\n/***/ \"ec47\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseToPairs = __webpack_require__(\"a3fd\"),\n    getTag = __webpack_require__(\"42a2\"),\n    mapToArray = __webpack_require__(\"edfa\"),\n    setToPairs = __webpack_require__(\"cebd\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/**\n * Creates a `_.toPairs` or `_.toPairsIn` function.\n *\n * @private\n * @param {Function} keysFunc The function to get the keys of a given object.\n * @returns {Function} Returns the new pairs function.\n */\nfunction createToPairs(keysFunc) {\n  return function(object) {\n    var tag = getTag(object);\n    if (tag == mapTag) {\n      return mapToArray(object);\n    }\n    if (tag == setTag) {\n      return setToPairs(object);\n    }\n    return baseToPairs(object, keysFunc(object));\n  };\n}\n\nmodule.exports = createToPairs;\n\n\n/***/ }),\n\n/***/ \"ec69\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayLikeKeys = __webpack_require__(\"6fcd\"),\n    baseKeys = __webpack_require__(\"03dd\"),\n    isArrayLike = __webpack_require__(\"30c9\");\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n/***/ }),\n\n/***/ \"ec8c\":\n/***/ (function(module, exports) {\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n\n\n/***/ }),\n\n/***/ \"edfa\":\n/***/ (function(module, exports) {\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n\n\n/***/ }),\n\n/***/ \"eefb\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_TimeSelect_vue_vue_type_style_index_0_id_26a07a51_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"0a6b\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_TimeSelect_vue_vue_type_style_index_0_id_26a07a51_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_TimeSelect_vue_vue_type_style_index_0_id_26a07a51_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_vue_style_loader_index_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_TimeSelect_vue_vue_type_style_index_0_id_26a07a51_lang_postcss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); \n\n/***/ }),\n\n/***/ \"ef5d\":\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n\n/***/ }),\n\n/***/ \"efb6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ListCache = __webpack_require__(\"5e2e\");\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n\n\n/***/ }),\n\n/***/ \"f3c1\":\n/***/ (function(module, exports) {\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n\n\n/***/ }),\n\n/***/ \"f4d6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isSymbol = __webpack_require__(\"ffd6\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n\n\n/***/ }),\n\n/***/ \"f542\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createToPairs = __webpack_require__(\"ec47\"),\n    keys = __webpack_require__(\"ec69\");\n\n/**\n * Creates an array of own enumerable string keyed-value pairs for `object`\n * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n * entries are returned.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias entries\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the key-value pairs.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.toPairs(new Foo);\n * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n */\nvar toPairs = createToPairs(keys);\n\nmodule.exports = toPairs;\n\n\n/***/ }),\n\n/***/ \"f608\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(\"6747\"),\n    isSymbol = __webpack_require__(\"ffd6\");\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n\n\n/***/ }),\n\n/***/ \"f678\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseClamp = __webpack_require__(\"8384\"),\n    toNumber = __webpack_require__(\"b4b0\");\n\n/**\n * Clamps `number` within the inclusive `lower` and `upper` bounds.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Number\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n * @example\n *\n * _.clamp(-10, -5, 5);\n * // => -5\n *\n * _.clamp(10, -5, 5);\n * // => 5\n */\nfunction clamp(number, lower, upper) {\n  if (upper === undefined) {\n    upper = lower;\n    lower = undefined;\n  }\n  if (upper !== undefined) {\n    upper = toNumber(upper);\n    upper = upper === upper ? upper : 0;\n  }\n  if (lower !== undefined) {\n    lower = toNumber(lower);\n    lower = lower === lower ? lower : 0;\n  }\n  return baseClamp(toNumber(number), lower, upper);\n}\n\nmodule.exports = clamp;\n\n\n/***/ }),\n\n/***/ \"f772\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(\"5692\");\nvar uid = __webpack_require__(\"90e3\");\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n/***/ }),\n\n/***/ \"f8af\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Uint8Array = __webpack_require__(\"2474\");\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n\n\n/***/ }),\n\n/***/ \"f909\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(\"7e64\"),\n    assignMergeValue = __webpack_require__(\"b760\"),\n    baseFor = __webpack_require__(\"72af\"),\n    baseMergeDeep = __webpack_require__(\"4f50\"),\n    isObject = __webpack_require__(\"1a8c\"),\n    keysIn = __webpack_require__(\"9934\"),\n    safeGet = __webpack_require__(\"8adb\");\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n\n\n/***/ }),\n\n/***/ \"f9ce\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseProperty = __webpack_require__(\"ef5d\"),\n    basePropertyDeep = __webpack_require__(\"e3f8\"),\n    isKey = __webpack_require__(\"f608\"),\n    toKey = __webpack_require__(\"f4d6\");\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n\n\n/***/ }),\n\n/***/ \"fa21\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseCreate = __webpack_require__(\"7530\"),\n    getPrototype = __webpack_require__(\"2dcb\"),\n    isPrototype = __webpack_require__(\"eac5\");\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n\n\n/***/ }),\n\n/***/ \"fb15\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: C:/Projects/v-calendar/node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js\n// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  var currentScript = window.document.currentScript\n  if (false) { var getCurrentScript; }\n\n  var src = currentScript && currentScript.src.match(/(.+\\/)[^/]+\\.js(\\?.*)?$/)\n  if (src) {\n    __webpack_require__.p = src[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\n/* harmony default export */ var setPublicPath = (null);\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js\nvar web_dom_collections_iterator = __webpack_require__(\"ddb0\");\n\n// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/toInteger/index.js\nfunction toInteger(dirtyNumber) {\n  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {\n    return NaN;\n  }\n\n  var number = Number(dirtyNumber);\n\n  if (isNaN(number)) {\n    return number;\n  }\n\n  return number < 0 ? Math.ceil(number) : Math.floor(number);\n}\n// CONCATENATED MODULE: ./node_modules/date-fns/esm/_lib/requiredArgs/index.js\nfunction requiredArgs(required, args) {\n  if (args.length < required) {\n    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');\n  }\n}\n// CONCATENATED MODULE: ./node_modules/date-fns/esm/toDate/index.js\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @param {Date|Number} argument - the value to convert\n * @returns {Date} the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\n\nfunction toDate(argument) {\n  requiredArgs(1, arguments);\n  var argStr = Object.prototype.toString.call(argument); // Clone the date\n\n  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime());\n  } else if (typeof argument === 'number' || argStr === '[object Number]') {\n    return new Date(argument);\n  } else {\n    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {\n      // eslint-disable-next-line no-console\n      console.warn(\"Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule\"); // eslint-disable-next-line no-console\n\n      console.warn(new Error().stack);\n    }\n\n    return new Date(NaN);\n  }\n}\n// CONCATENATED MODULE: ./node_modules/date-fns/esm/addDays/index.js\n\n\n\n/**\n * @name addDays\n * @category Day Helpers\n * @summary Add the specified number of days to the given date.\n *\n * @description\n * Add the specified number of days to the given date.\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.\n * @returns {Date} the new date with the days added\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Add 10 days to 1 September 2014:\n * var result = addDays(new Date(2014, 8, 1), 10)\n * //=> Thu Sep 11 2014 00:00:00\n */\n\nfunction addDays(dirtyDate, dirtyAmount) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var amount = toInteger(dirtyAmount);\n\n  if (isNaN(amount)) {\n    return new Date(NaN);\n  }\n\n  if (!amount) {\n    // If 0 days, no-op to avoid changing times in the hour before end of DST\n    return date;\n  }\n\n  date.setDate(date.getDate() + amount);\n  return date;\n}\n// CONCATENATED MODULE: ./node_modules/date-fns/esm/addMonths/index.js\n\n\n\n/**\n * @name addMonths\n * @category Month Helpers\n * @summary Add the specified number of months to the given date.\n *\n * @description\n * Add the specified number of months to the given date.\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.\n * @returns {Date} the new date with the months added\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Add 5 months to 1 September 2014:\n * var result = addMonths(new Date(2014, 8, 1), 5)\n * //=> Sun Feb 01 2015 00:00:00\n */\n\nfunction addMonths(dirtyDate, dirtyAmount) {\n  requiredArgs(2, arguments);\n  var date = toDate(dirtyDate);\n  var amount = toInteger(dirtyAmount);\n\n  if (isNaN(amount)) {\n    return new Date(NaN);\n  }\n\n  if (!amount) {\n    // If 0 months, no-op to avoid changing times in the hour before end of DST\n    return date;\n  }\n\n  var dayOfMonth = date.getDate(); // The JS Date object supports date math by accepting out-of-bounds values for\n  // month, day, etc. For example, new Date(2020, 1, 0) returns 31 Dec 2019 and\n  // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we\n  // want except that dates will wrap around the end of a month, meaning that\n  // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So\n  // we'll default to the end of the desired month by adding 1 to the desired\n  // month and using a date of 0 to back up one day to the end of the desired\n  // month.\n\n  var endOfDesiredMonth = new Date(date.getTime());\n  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);\n  var daysInMonth = endOfDesiredMonth.getDate();\n\n  if (dayOfMonth >= daysInMonth) {\n    // If we're already at the end of the month, then this is the correct date\n    // and we're done.\n    return endOfDesiredMonth;\n  } else {\n    // Otherwise, we now know that setting the original day-of-month value won't\n    // cause an overflow, so set the desired day-of-month. Note that we can't\n    // just set the date of `endOfDesiredMonth` because that object may have had\n    // its time changed in the unusual case where where a DST transition was on\n    // the last day of the month and its local time was in the hour skipped or\n    // repeated next to a DST transition.  So we use `date` instead which is\n    // guaranteed to still have the original time.\n    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);\n    return date;\n  }\n}\n// CONCATENATED MODULE: ./node_modules/date-fns/esm/addYears/index.js\n\n\n\n/**\n * @name addYears\n * @category Year Helpers\n * @summary Add the specified number of years to the given date.\n *\n * @description\n * Add the specified number of years to the given date.\n *\n * ### v2.0.0 breaking changes:\n *\n * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).\n *\n * @param {Date|Number} date - the date to be changed\n * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.\n * @returns {Date} the new date with the years added\n * @throws {TypeError} 2 arguments required\n *\n * @example\n * // Add 5 years to 1 September 2014:\n * var result = addYears(new Date(2014, 8, 1), 5)\n * //=> Sun Sep 01 2019 00:00:00\n */\n\nfunction addYears(dirtyDate, dirtyAmount) {\n  requiredArgs(2, arguments);\n  var amount = toInteger(dirtyAmount);\n  return addMonths(dirtyDate, amount * 12);\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\nfunction getBoundingClientRect(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    y: rect.top\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\n/*:: import type { Window } from '../types'; */\n\n/*:: declare function getWindow(node: Node | Window): Window; */\nfunction getWindow(node) {\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\n\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\n\n/*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n  Element); */\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement); */\n\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n/*:: declare function isShadowRoot(node: mixed): boolean %checks(node instanceof\n  ShadowRoot); */\n\n\nfunction isShadowRoot(node) {\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\n\n\n\n\n\n\n // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement);\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\n// Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\nfunction getLayoutRect(element) {\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\n\n\nfunction getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    // $FlowFixMe: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\n\n\n\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\n\n\n\n\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the \nreference element's position.\n*/\n\nfunction listScrollParents(element, list) {\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = getNodeName(scrollParent) === 'body';\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\n\n\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  var offsetParent = element.offsetParent;\n\n  if (offsetParent) {\n    var html = getDocumentElement(offsetParent);\n\n    if (getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && getComputedStyle(html).position !== 'static') {\n      return html;\n    }\n  }\n\n  return offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.willChange && css.willChange !== 'auto') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/enums.js\nvar enums_top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar enums_auto = 'auto';\nvar basePlacements = [enums_top, bottom, right, left];\nvar enums_start = 'start';\nvar enums_end = 'end';\nvar enums_clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar enums_popper = 'popper';\nvar enums_reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + enums_start, placement + \"-\" + enums_end]);\n}, []);\nvar enums_placements = /*#__PURE__*/[].concat(basePlacements, [enums_auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + enums_start, placement + \"-\" + enums_end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/orderModifiers.js\n // source: https://stackoverflow.com/questions/49875255\n\nfunction orderModifiers_order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = orderModifiers_order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/debounce.js\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergeByName.js\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), {}, {\n      options: Object.assign(Object.assign({}, existing.options), current.options),\n      data: Object.assign(Object.assign({}, existing.data), current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/createPopper.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (false) { var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers; }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (false) {}\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (false) {}\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (false) {}\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar createPopper_createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var eventListeners = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getVariation.js\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeOffsets.js\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case enums_top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case enums_start:\n        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);\n        break;\n\n      case enums_end:\n        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\n\n\nfunction popperOffsets_popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_popperOffsets = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets_popperOffsets,\n  data: {}\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsets(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive;\n\n  var _roundOffsets = roundOffsets(offsets),\n      x = _roundOffsets.x,\n      y = _roundOffsets.y;\n\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = enums_top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    /*:: offsetParent = (offsetParent: Element); */\n\n\n    if (placement === enums_top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref3) {\n  var state = _ref3.state,\n      options = _ref3.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;\n\n  if (false) { var transitionProperty; }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false\n    })));\n  }\n\n  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_computeStyles = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction applyStyles_effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe\n\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_applyStyles = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: applyStyles_effect,\n  requires: ['computeStyles']\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/offset.js\n\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign(Object.assign({}, rects), {}, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset_offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = enums_placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_offset = ({\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset_offset\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\nvar getOppositeVariationPlacement_hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return getOppositeVariationPlacement_hash[matched];\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\n\n\n\nfunction getViewportRect(element) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n  // can be obscured underneath it.\n  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n  // if it isn't open, so if this isn't available, the popper will be detected\n  // to overflow the bottom of the screen too early.\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n    // Feature detection fails in mobile emulation mode in Chrome.\n    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n    // 0.001\n    // Fallback here: \"Not Safari\" userAgent\n\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\n\n\n\n // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = element.ownerDocument.body;\n  var width = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/contains.js\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\nfunction rectToClientRect(rect) {\n  return Object.assign(Object.assign({}, rect), {}, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getInnerBoundingClientRect(element) {\n  var rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign(Object.assign({}, getFreshSideObject()), paddingObject);\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/detectOverflow.js\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? enums_clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? enums_popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === enums_popper ? enums_reference : enums_popper;\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(referenceElement);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n  var elementClientRect = elementContext === enums_popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === enums_popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\n\n\n\n\n\n/*:: type OverflowsMap = { [ComputedPlacement]: number }; */\n\n/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements; // $FlowFixMe\n\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n\n    if (false) {}\n  } // $FlowFixMe: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/flip.js\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === enums_auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === enums_auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === enums_start;\n    var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases  research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_flip = ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getAltAxis.js\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/within.js\nfunction within(min, value, max) {\n  return Math.max(min, Math.min(value, max));\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {}, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? enums_top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === enums_start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === enums_start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? enums_top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var _preventedOffset = within(_min, _offset, _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_preventOverflow = ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/arrow.js\n\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = state.modifiersData[name + \"#persistent\"].padding;\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? enums_top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction arrow_effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,\n      _options$padding = options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (false) {}\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false) {}\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[name + \"#persistent\"] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_arrow = ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: arrow_effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/hide.js\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [enums_top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide_hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_hide = ({\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide_hide\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper.js\n\n\n\n\n\n\n\n\n\n\nvar popper_defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];\nvar popper_createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: popper_defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n\n// EXTERNAL MODULE: ./node_modules/lodash/isBoolean.js\nvar isBoolean = __webpack_require__(\"6679\");\n\n// EXTERNAL MODULE: ./node_modules/lodash/isNumber.js\nvar isNumber = __webpack_require__(\"501e\");\nvar isNumber_default = /*#__PURE__*/__webpack_require__.n(isNumber);\n\n// EXTERNAL MODULE: ./node_modules/lodash/isString.js\nvar isString = __webpack_require__(\"e2a0\");\nvar isString_default = /*#__PURE__*/__webpack_require__.n(isString);\n\n// EXTERNAL MODULE: ./node_modules/lodash/isArrayLikeObject.js\nvar isArrayLikeObject = __webpack_require__(\"dcbe\");\nvar isArrayLikeObject_default = /*#__PURE__*/__webpack_require__.n(isArrayLikeObject);\n\n// EXTERNAL MODULE: ./node_modules/lodash/isFunction.js\nvar isFunction = __webpack_require__(\"9520\");\nvar isFunction_default = /*#__PURE__*/__webpack_require__.n(isFunction);\n\n// EXTERNAL MODULE: ./node_modules/lodash/isUndefined.js\nvar isUndefined = __webpack_require__(\"4cfe\");\nvar isUndefined_default = /*#__PURE__*/__webpack_require__.n(isUndefined);\n\n// EXTERNAL MODULE: ./node_modules/lodash/isDate.js\nvar isDate = __webpack_require__(\"6220\");\nvar isDate_default = /*#__PURE__*/__webpack_require__.n(isDate);\n\n// EXTERNAL MODULE: ./node_modules/lodash/clamp.js\nvar clamp = __webpack_require__(\"f678\");\nvar clamp_default = /*#__PURE__*/__webpack_require__.n(clamp);\n\n// EXTERNAL MODULE: ./node_modules/lodash/get.js\nvar get = __webpack_require__(\"9b02\");\nvar get_default = /*#__PURE__*/__webpack_require__.n(get);\n\n// EXTERNAL MODULE: ./node_modules/lodash/set.js\nvar set = __webpack_require__(\"0f5c\");\nvar set_default = /*#__PURE__*/__webpack_require__.n(set);\n\n// EXTERNAL MODULE: ./node_modules/lodash/mapValues.js\nvar mapValues = __webpack_require__(\"9e86\");\nvar mapValues_default = /*#__PURE__*/__webpack_require__.n(mapValues);\n\n// EXTERNAL MODULE: ./node_modules/lodash/toPairs.js\nvar toPairs = __webpack_require__(\"f542\");\nvar toPairs_default = /*#__PURE__*/__webpack_require__.n(toPairs);\n\n// EXTERNAL MODULE: ./node_modules/lodash/defaults.js\nvar defaults = __webpack_require__(\"95ae\");\nvar defaults_default = /*#__PURE__*/__webpack_require__.n(defaults);\n\n// EXTERNAL MODULE: ./node_modules/lodash/defaultsDeep.js\nvar defaultsDeep = __webpack_require__(\"3f84\");\nvar defaultsDeep_default = /*#__PURE__*/__webpack_require__.n(defaultsDeep);\n\n// EXTERNAL MODULE: ./node_modules/lodash/pick.js\nvar pick = __webpack_require__(\"2593\");\nvar pick_default = /*#__PURE__*/__webpack_require__.n(pick);\n\n// EXTERNAL MODULE: ./node_modules/lodash/omit.js\nvar omit = __webpack_require__(\"3eea\");\nvar omit_default = /*#__PURE__*/__webpack_require__.n(omit);\n\n// EXTERNAL MODULE: ./node_modules/lodash/has.js\nvar has = __webpack_require__(\"3852\");\nvar has_default = /*#__PURE__*/__webpack_require__.n(has);\n\n// EXTERNAL MODULE: ./node_modules/lodash/map.js\nvar lodash_map = __webpack_require__(\"dd61\");\nvar map_default = /*#__PURE__*/__webpack_require__.n(lodash_map);\n\n// EXTERNAL MODULE: ./node_modules/lodash/head.js\nvar head = __webpack_require__(\"a59b\");\nvar head_default = /*#__PURE__*/__webpack_require__.n(head);\n\n// EXTERNAL MODULE: ./node_modules/lodash/last.js\nvar last = __webpack_require__(\"4416\");\nvar last_default = /*#__PURE__*/__webpack_require__.n(last);\n\n// EXTERNAL MODULE: ./node_modules/lodash/some.js\nvar some = __webpack_require__(\"3092\");\nvar some_default = /*#__PURE__*/__webpack_require__.n(some);\n\n// CONCATENATED MODULE: ./src/utils/_.js\n// Type utils\n\n\n\n\n\n\n // Number utils\n\n // Object utils\n\n\n\n\n\n\n\n\n\n // Collection utils\n\n\n\n\n // Type checkers\n\nconst getType = function (value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n};\nconst _isDate = function (value) {\n  return isDate_default()(value) && !isNaN(value.getTime());\n};\nconst isObject = function (value) {\n  return getType(value) === 'Object';\n}; // Object utils\n\nconst _has = has_default.a;\nconst hasAny = function (obj, props) {\n  return some_default()(props, function (p) {\n    return has_default()(obj, p);\n  });\n}; // Collection utils\n\nconst _some = some_default.a;\n// CONCATENATED MODULE: ./src/utils/helpers.js\n\n\nconst pad = function (val, len, char = '0') {\n  val = val !== null && val !== undefined ? String(val) : '';\n  len = len || 2;\n\n  while (val.length < len) {\n    val = `${char}${val}`;\n  }\n\n  return val;\n};\nconst evalFn = function (fn, args) {\n  return isFunction_default()(fn) ? fn(args) : fn;\n};\nconst pageIsValid = function (page) {\n  return !!(page && page.month && page.year);\n};\nconst mergeEvents = function (...args) {\n  const result = {};\n  args.forEach(function (e) {\n    return Object.entries(e).forEach(function ([key, value]) {\n      if (!result[key]) {\n        result[key] = value;\n      } else if (isArrayLikeObject_default()(result[key])) {\n        result[key].push(value);\n      } else {\n        result[key] = [result[key], value];\n      }\n    });\n  });\n  return result;\n};\nconst pageIsBeforePage = function (page, comparePage) {\n  if (!pageIsValid(page) || !pageIsValid(comparePage)) return false;\n  if (page.year === comparePage.year) return page.month < comparePage.month;\n  return page.year < comparePage.year;\n};\nconst pageIsAfterPage = function (page, comparePage) {\n  if (!pageIsValid(page) || !pageIsValid(comparePage)) return false;\n  if (page.year === comparePage.year) return page.month > comparePage.month;\n  return page.year > comparePage.year;\n};\nconst pageIsBetweenPages = function (page, fromPage, toPage) {\n  return (page || false) && !pageIsBeforePage(page, fromPage) && !pageIsAfterPage(page, toPage);\n};\nconst pageIsEqualToPage = function (aPage, bPage) {\n  if (!aPage && bPage) return false;\n  if (aPage && !bPage) return false;\n  if (!aPage && !bPage) return true;\n  return aPage.month === bPage.month && aPage.year === bPage.year;\n};\nconst pageForDate = function (date) {\n  if (!date) return null;\n  return {\n    month: date.getMonth() + 1,\n    year: date.getFullYear()\n  };\n};\nconst addPages = function ({\n  month,\n  year\n}, count) {\n  const incr = count > 0 ? 1 : -1;\n\n  for (let i = 0; i < Math.abs(count); i++) {\n    month += incr;\n\n    if (month > 12) {\n      month = 1;\n      year++;\n    } else if (month < 1) {\n      month = 12;\n      year--;\n    }\n  }\n\n  return {\n    month,\n    year\n  };\n};\nconst pageForThisMonth = function () {\n  return pageForDate(new Date());\n};\nconst pageForNextMonth = function () {\n  return addPages(pageForThisMonth(), 1);\n};\nconst pageForPrevMonth = function () {\n  return addPages(pageForThisMonth(), -1);\n};\nconst getMaxPage = function (...args) {\n  return args.reduce(function (prev, curr) {\n    if (!prev) return curr;\n    if (!curr) return prev;\n    return pageIsAfterPage(curr, prev) ? curr : prev;\n  });\n};\nfunction datesAreEqual(a, b) {\n  const aIsDate = _isDate(a);\n  const bIsDate = _isDate(b);\n  if (!aIsDate && !bIsDate) return true;\n  if (aIsDate !== bIsDate) return false;\n  return a.getTime() === b.getTime();\n}\nconst arrayHasItems = function (array) {\n  return isArrayLikeObject_default()(array) && array.length;\n};\nconst findAncestor = function (el, fn) {\n  if (!el) return null;\n  if (fn && fn(el)) return el;\n  return findAncestor(el.parentElement, fn);\n};\nconst elementHasAncestor = function (el, ancestor) {\n  return !!findAncestor(el, function (e) {\n    return e === ancestor;\n  });\n};\nconst elementPositionInAncestor = function (el, ancestor) {\n  let top = 0;\n  let left = 0;\n\n  do {\n    top += el.offsetTop || 0;\n    left += el.offsetLeft || 0;\n    el = el.offsetParent;\n  } while (el && el !== ancestor);\n\n  return {\n    top,\n    left\n  };\n};\nconst mixinOptionalProps = function (source, target, props) {\n  const assigned = [];\n  props.forEach(function (p) {\n    const name = p.name || p.toString();\n    const mixin = p.mixin;\n    const validate = p.validate;\n\n    if (Object.prototype.hasOwnProperty.call(source, name)) {\n      const value = validate ? validate(source[name]) : source[name];\n      target[name] = mixin && isObject(value) ? { ...mixin,\n        ...value\n      } : value;\n      assigned.push(name);\n    }\n  });\n  return {\n    target,\n    assigned: assigned.length ? assigned : null\n  };\n};\nconst on = function (element, event, handler) {\n  if (element && event && handler) {\n    element.addEventListener(event, handler, false);\n  }\n};\nconst off = function (element, event, handler) {\n  if (element && event) {\n    element.removeEventListener(event, handler, false);\n  }\n};\nconst elementContains = function (element, child) {\n  return !!element && !!child && (element === child || element.contains(child));\n};\nconst onSpaceOrEnter = function (event, handler) {\n  if (event.key === ' ' || event.key === 'Enter') {\n    handler(event);\n    event.preventDefault();\n  }\n};\n/* eslint-disable no-bitwise */\n\nconst createGuid = function () {\n  function S4() {\n    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);\n  }\n\n  return `${S4() + S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;\n};\nfunction helpers_hash(str) {\n  let hashcode = 0;\n  let i = 0;\n  let chr;\n  if (str.length === 0) return hashcode;\n\n  for (i = 0; i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hashcode = (hashcode << 5) - hashcode + chr;\n    hashcode |= 0; // Convert to 32bit integer\n  }\n\n  return hashcode;\n}\n/* eslint-enable no-bitwise */\n// CONCATENATED MODULE: ./src/utils/touch.js\n\n // This function detects taps or clicks\n// Can't just rely on 'click' event because of oddities in mobile Safari\n\nconst addTapOrClickHandler = function (element, handler) {\n  if (!element || !element.addEventListener || !isFunction_default()(handler)) {\n    return null;\n  } // State variables\n\n\n  let tap = false;\n  let disableClick = false;\n\n  const touchstart = function () {\n    return tap = true;\n  };\n\n  const touchmove = function () {\n    return tap = false;\n  };\n\n  const touchend = function (event) {\n    if (tap) {\n      // Reset state\n      tap = false; // Disable click so we don't call handler twice\n\n      disableClick = true;\n      handler(event);\n      return;\n    } // Make sure tap event hasn't disabled click\n\n\n    if (event.type === 'click' && !disableClick) {\n      handler(event);\n    } // Reset state\n\n\n    disableClick = false;\n  }; // Add event handlers\n\n\n  on(element, 'touchstart', touchstart);\n  on(element, 'touchmove', touchmove);\n  on(element, 'click', touchend);\n  on(element, 'touchend', touchend); // Return function that removes event handlers\n\n  return function () {\n    off(element, 'touchstart', touchstart);\n    off(element, 'touchmove', touchmove);\n    off(element, 'click', touchend);\n    off(element, 'touchend', touchend);\n  };\n};\nconst addHorizontalSwipeHandler = function (element, handler, {\n  maxSwipeTime,\n  minHorizontalSwipeDistance,\n  maxVerticalSwipeDistance\n}) {\n  if (!element || !element.addEventListener || !isFunction_default()(handler)) {\n    return null;\n  } // State variables\n\n\n  let startX = 0;\n  let startY = 0;\n  let startTime = null;\n  let isSwiping = false; // Touch start handler\n\n  function touchStart(e) {\n    const t = e.changedTouches[0];\n    startX = t.screenX;\n    startY = t.screenY;\n    startTime = new Date().getTime();\n    isSwiping = true;\n  } // Touch end handler\n\n\n  function touchEnd(e) {\n    if (!isSwiping) return;\n    isSwiping = false;\n    const t = e.changedTouches[0];\n    const deltaX = t.screenX - startX;\n    const deltaY = t.screenY - startY;\n    const deltaTime = new Date().getTime() - startTime;\n\n    if (deltaTime < maxSwipeTime) {\n      if (Math.abs(deltaX) >= minHorizontalSwipeDistance && Math.abs(deltaY) <= maxVerticalSwipeDistance) {\n        const arg = {\n          toLeft: false,\n          toRight: false\n        };\n\n        if (deltaX < 0) {\n          // Swipe to the left\n          arg.toLeft = true;\n        } else {\n          // Swipe to the right\n          arg.toRight = true;\n        }\n\n        handler(arg);\n      }\n    }\n  } // Add event handlers\n\n\n  on(element, 'touchstart', touchStart); // on(element, 'touchmove', touchmove);\n\n  on(element, 'touchend', touchEnd); // Return function that removes event handlers\n\n  return function () {\n    off(element, 'touchstart', touchStart); // off(element, 'touchmove', touchmove);\n\n    off(element, 'touchend', touchEnd);\n  };\n};\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Popover.vue?vue&type=script&lang=js&\n\n\n\n\n\n/* harmony default export */ var Popovervue_type_script_lang_js_ = ({\n  name: 'Popover',\n\n  render(h) {\n    return h('div', {\n      class: ['vc-popover-content-wrapper', {\n        'is-interactive': this.isInteractive\n      }],\n      ref: 'popover'\n    }, [h('transition', {\n      props: {\n        name: this.transition,\n        appear: true\n      },\n      on: {\n        beforeEnter: this.beforeEnter,\n        afterEnter: this.afterEnter,\n        beforeLeave: this.beforeLeave,\n        afterLeave: this.afterLeave\n      }\n    }, [this.isVisible && h('div', {\n      attrs: {\n        tabindex: -1\n      },\n      class: ['vc-popover-content', `direction-${this.direction}`, this.contentClass]\n    }, [this.content, h('span', {\n      class: ['vc-popover-caret', `direction-${this.direction}`, `align-${this.alignment}`]\n    })])])]);\n  },\n\n  props: {\n    id: {\n      type: String,\n      required: true\n    },\n    transition: {\n      type: String,\n      default: 'slide-fade'\n    },\n    contentClass: String\n  },\n\n  data() {\n    return {\n      ref: null,\n      opts: null,\n      data: null,\n      placement: 'bottom',\n      positionFixed: false,\n      modifiers: [],\n      isInteractive: false,\n      isHovered: false,\n      isFocused: false,\n      showDelay: 10,\n      hideDelay: 110,\n      autoHide: false,\n      popperEl: null\n    };\n  },\n\n  computed: {\n    content() {\n      var _this = this;\n\n      return isFunction_default()(this.$scopedSlots.default) && this.$scopedSlots.default({\n        direction: this.direction,\n        alignment: this.alignment,\n        data: this.data,\n        updateLayout: this.update,\n        hide: function (opts) {\n          return _this.hide(opts);\n        }\n      }) || this.$slots.default;\n    },\n\n    popperOptions() {\n      return {\n        placement: this.placement,\n        strategy: this.positionFixed ? 'fixed' : 'absolute',\n        modifiers: [{\n          name: 'onUpdate',\n          enabled: true,\n          phase: 'afterWrite',\n          fn: this.onPopperUpdate\n        }, ...(this.modifiers || [])],\n        onFirstUpdate: this.onPopperUpdate\n      };\n    },\n\n    isVisible() {\n      return !!(this.ref && this.content);\n    },\n\n    direction() {\n      return this.placement && this.placement.split('-')[0] || 'bottom';\n    },\n\n    alignment() {\n      const isLeftRight = this.direction === 'left' || this.direction === 'right';\n      let alignment = this.placement.split('-');\n      alignment = alignment.length > 1 ? alignment[1] : '';\n\n      if (['start', 'top', 'left'].includes(alignment)) {\n        return isLeftRight ? 'top' : 'left';\n      }\n\n      if (['end', 'bottom', 'right'].includes(alignment)) {\n        return isLeftRight ? 'bottom' : 'right';\n      }\n\n      return isLeftRight ? 'middle' : 'center';\n    },\n\n    state() {\n      return this.$popovers[this.id];\n    }\n\n  },\n  watch: {\n    opts(val, oldVal) {\n      if (oldVal && oldVal.callback) {\n        oldVal.callback({ ...oldVal,\n          completed: !val,\n          reason: val ? 'Overridden by action' : null\n        });\n      }\n    }\n\n  },\n\n  mounted() {\n    this.popoverEl = this.$refs.popover;\n    this.addEvents();\n  },\n\n  beforeDestroy() {\n    this.removeEvents();\n  },\n\n  methods: {\n    addEvents() {\n      on(this.popoverEl, 'click', this.onClick);\n      on(this.popoverEl, 'mouseover', this.onMouseOver);\n      on(this.popoverEl, 'mouseleave', this.onMouseLeave);\n      on(this.popoverEl, 'focusin', this.onFocusIn);\n      on(this.popoverEl, 'focusout', this.onFocusOut);\n      on(document, 'keydown', this.onDocumentKeydown);\n      this.removeDocHandler = addTapOrClickHandler(document, this.onDocumentClick);\n      on(document, 'show-popover', this.onDocumentShowPopover);\n      on(document, 'hide-popover', this.onDocumentHidePopover);\n      on(document, 'toggle-popover', this.onDocumentTogglePopover);\n      on(document, 'update-popover', this.onDocumentUpdatePopover);\n    },\n\n    removeEvents() {\n      off(this.popoverEl, 'click', this.onClick);\n      off(this.popoverEl, 'mouseover', this.onMouseOver);\n      off(this.popoverEl, 'mouseleave', this.onMouseLeave);\n      off(this.popoverEl, 'focusin', this.onFocusIn);\n      off(this.popoverEl, 'focusout', this.onFocusOut);\n      off(document, 'keydown', this.onDocumentKeydown);\n      if (this.removeDocHandler) this.removeDocHandler();\n      off(document, 'show-popover', this.onDocumentShowPopover);\n      off(document, 'hide-popover', this.onDocumentHidePopover);\n      off(document, 'toggle-popover', this.onDocumentTogglePopover);\n      off(document, 'update-popover', this.onDocumentUpdatePopover);\n    },\n\n    onClick(e) {\n      e.stopPropagation();\n    },\n\n    onMouseOver() {\n      this.isHovered = true;\n      if (this.isInteractive) this.show();\n    },\n\n    onMouseLeave() {\n      this.isHovered = false;\n\n      if (this.autoHide && !this.isFocused && (!this.ref || this.ref !== document.activeElement)) {\n        this.hide();\n      }\n    },\n\n    onFocusIn() {\n      this.isFocused = true;\n      if (this.isInteractive) this.show();\n    },\n\n    onFocusOut(e) {\n      if (!e.relatedTarget || !elementContains(this.popoverEl, e.relatedTarget)) {\n        this.isFocused = false;\n        if (!this.isHovered && this.autoHide) this.hide();\n      }\n    },\n\n    onDocumentClick(e) {\n      if (!this.$refs.popover || !this.ref) {\n        return;\n      } // Don't hide if target element is contained within popover ref or content\n\n\n      if (elementContains(this.popoverEl, e.target) || elementContains(this.ref, e.target)) {\n        return;\n      } // Hide the popover\n\n\n      this.hide();\n    },\n\n    onDocumentKeydown(e) {\n      if (e.key === 'Esc' || e.key === 'Escape') {\n        this.hide();\n      }\n    },\n\n    onDocumentShowPopover({\n      detail\n    }) {\n      if (!detail.id || detail.id !== this.id) return;\n      this.show(detail);\n    },\n\n    onDocumentHidePopover({\n      detail\n    }) {\n      if (!detail.id || detail.id !== this.id) return;\n      this.hide(detail);\n    },\n\n    onDocumentTogglePopover({\n      detail\n    }) {\n      if (!detail.id || detail.id !== this.id) return;\n      this.toggle(detail);\n    },\n\n    onDocumentUpdatePopover({\n      detail\n    }) {\n      this.update(detail);\n    },\n\n    show(opts = {}) {\n      var _this2 = this;\n\n      opts.action = 'show';\n      const ref = opts.ref || this.ref;\n      const delay = opts.delay || this.showDelay; // Validate options\n\n      if (!ref) {\n        if (opts.callback) {\n          opts.callback({\n            completed: false,\n            reason: 'Invalid reference element provided'\n          });\n        }\n\n        return;\n      }\n\n      clearTimeout(this.timeout);\n      this.opts = opts;\n\n      const fn = function () {\n        Object.assign(_this2, opts);\n\n        _this2.setupPopper();\n\n        _this2.opts = null;\n      };\n\n      if (delay > 0) {\n        this.timeout = setTimeout(function () {\n          return fn();\n        }, delay);\n      } else {\n        fn();\n      }\n    },\n\n    hide(opts = {}) {\n      var _this3 = this;\n\n      opts.action = 'hide';\n      const ref = opts.ref || this.ref;\n      const delay = opts.delay || this.hideDelay;\n\n      if (!this.ref || ref !== this.ref) {\n        if (opts.callback) {\n          opts.callback({ ...opts,\n            completed: false,\n            reason: this.ref ? 'Invalid reference element provided' : 'Popover already hidden'\n          });\n        }\n\n        return;\n      }\n\n      const fn = function () {\n        _this3.ref = null;\n        _this3.opts = null;\n      };\n\n      clearTimeout(this.timeout);\n      this.opts = opts;\n\n      if (delay > 0) {\n        this.timeout = setTimeout(fn, delay);\n      } else {\n        fn();\n      }\n    },\n\n    toggle(opts = {}) {\n      if (this.isVisible && opts.ref === this.ref) {\n        this.hide(opts);\n      } else {\n        this.show(opts);\n      }\n    },\n\n    setupPopper() {\n      var _this4 = this;\n\n      this.$nextTick(function () {\n        if (!_this4.ref || !_this4.$refs.popover) return;\n\n        if (_this4.popper && _this4.popper.reference !== _this4.ref) {\n          _this4.destroyPopper();\n        }\n\n        if (!_this4.popper) {\n          _this4.popper = popper_createPopper(_this4.ref, _this4.popoverEl, _this4.popperOptions);\n        } else {\n          _this4.popper.update();\n        }\n      });\n    },\n\n    onPopperUpdate(args) {\n      if (args.placement) {\n        this.placement = args.placement;\n      } else if (args.state) {\n        this.placement = args.state.placement;\n      }\n    },\n\n    update({\n      data\n    }) {\n      this.data = data;\n      this.setupPopper();\n    },\n\n    beforeEnter(e) {\n      this.$emit('beforeShow', e);\n    },\n\n    afterEnter(e) {\n      this.$emit('afterShow', e);\n    },\n\n    beforeLeave(e) {\n      this.$emit('beforeHide', e);\n    },\n\n    afterLeave(e) {\n      this.destroyPopper();\n      this.$emit('afterHide', e);\n    },\n\n    destroyPopper() {\n      if (this.popper) {\n        this.popper.destroy();\n        this.popper = null;\n      }\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/Popover.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_Popovervue_type_script_lang_js_ = (Popovervue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/Popover.vue?vue&type=style&index=0&id=6c8a2a3c&lang=postcss&scoped=true&\nvar Popovervue_type_style_index_0_id_6c8a2a3c_lang_postcss_scoped_true_ = __webpack_require__(\"dd71\");\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n        injectStyles.call(\n          this,\n          (options.functional ? this.parent : this).$root.$options.shadowRoot\n        )\n      }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n// CONCATENATED MODULE: ./src/components/Popover.vue\nvar render, staticRenderFns\n\n\n\n\n\n/* normalize component */\n\nvar component = normalizeComponent(\n  components_Popovervue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"6c8a2a3c\",\n  null\n  \n)\n\n/* harmony default export */ var Popover = (component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"8773979e-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/PopoverRow.vue?vue&type=template&id=4975d69e&scoped=true&\nvar PopoverRowvue_type_template_id_4975d69e_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"vc-day-popover-row\"},[(_vm.indicator)?_c('div',{staticClass:\"vc-day-popover-row-indicator\"},[_c('span',{class:_vm.indicator.class,style:(_vm.indicator.style)})]):_vm._e(),_c('div',{staticClass:\"vc-day-popover-row-content\"},[_vm._t(\"default\",[_vm._v(_vm._s(_vm.attribute.popover ? _vm.attribute.popover.label : 'No content provided'))])],2)])}\nvar PopoverRowvue_type_template_id_4975d69e_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/PopoverRow.vue?vue&type=template&id=4975d69e&scoped=true&\n\n// EXTERNAL MODULE: external {\"commonjs\":\"vue\",\"commonjs2\":\"vue\",\"root\":\"Vue\"}\nvar external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(\"8bbf\");\nvar external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);\n\n// EXTERNAL MODULE: ./src/utils/defaults/touch.json\nvar touch = __webpack_require__(\"23a5\");\n\n// EXTERNAL MODULE: ./src/utils/defaults/masks.json\nvar defaults_masks = __webpack_require__(\"7efe\");\n\n// EXTERNAL MODULE: ./src/utils/defaults/screens.json\nvar defaults_screens = __webpack_require__(\"85a9\");\n\n// CONCATENATED MODULE: ./src/utils/defaults/locales.js\n\n\nconst locales_locales = {\n  // Arabic\n  ar: {\n    dow: 7,\n    L: 'D/\\u200FM/\\u200FYYYY'\n  },\n  // Bulgarian\n  bg: {\n    dow: 2,\n    L: 'D.MM.YYYY'\n  },\n  // Catalan\n  ca: {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // Chinese (China)\n  'zh-CN': {\n    dow: 2,\n    L: 'YYYY/MM/DD'\n  },\n  // Chinese (Taiwan)\n  'zh-TW': {\n    dow: 1,\n    L: 'YYYY/MM/DD'\n  },\n  // Croatian\n  hr: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Czech\n  cs: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Danish\n  da: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Dutch\n  nl: {\n    dow: 2,\n    L: 'DD-MM-YYYY'\n  },\n  // English (US)\n  'en-US': {\n    dow: 1,\n    L: 'MM/DD/YYYY'\n  },\n  // English (Australia)\n  'en-AU': {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // English (Canada)\n  'en-CA': {\n    dow: 1,\n    L: 'YYYY-MM-DD'\n  },\n  // English (Great Britain)\n  'en-GB': {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // English (Ireland)\n  'en-IE': {\n    dow: 2,\n    L: 'DD-MM-YYYY'\n  },\n  // English (New Zealand)\n  'en-NZ': {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // English (South Africa)\n  'en-ZA': {\n    dow: 1,\n    L: 'YYYY/MM/DD'\n  },\n  // Esperanto\n  eo: {\n    dow: 2,\n    L: 'YYYY-MM-DD'\n  },\n  // Estonian\n  et: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Finnish\n  fi: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // French\n  fr: {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // French (Canada)\n  'fr-CA': {\n    dow: 1,\n    L: 'YYYY-MM-DD'\n  },\n  // French (Switzerland)\n  'fr-CH': {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // German\n  de: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Hebrew\n  he: {\n    dow: 1,\n    L: 'DD.MM.YYYY'\n  },\n  // Indonesian\n  id: {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // Italian\n  it: {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // Japanese\n  ja: {\n    dow: 1,\n    L: 'YYYYMD'\n  },\n  // Korean\n  ko: {\n    dow: 1,\n    L: 'YYYY.MM.DD'\n  },\n  // Latvian\n  lv: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Lithuanian\n  lt: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Macedonian\n  mk: {\n    dow: 2,\n    L: 'D.MM.YYYY'\n  },\n  // Norwegian\n  nb: {\n    dow: 2,\n    L: 'D. MMMM YYYY'\n  },\n  nn: {\n    dow: 2,\n    L: 'D. MMMM YYYY'\n  },\n  // Polish\n  pl: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Portuguese\n  pt: {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // Romanian\n  ro: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Russian\n  ru: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Slovak\n  sk: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Spanish (Spain)\n  'es-ES': {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // Spanish (Mexico)\n  'es-MX': {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  },\n  // Swedish\n  sv: {\n    dow: 2,\n    L: 'YYYY-MM-DD'\n  },\n  // Thai\n  th: {\n    dow: 1,\n    L: 'DD/MM/YYYY'\n  },\n  // Turkish\n  tr: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Ukrainian\n  uk: {\n    dow: 2,\n    L: 'DD.MM.YYYY'\n  },\n  // Vietnam\n  vi: {\n    dow: 2,\n    L: 'DD/MM/YYYY'\n  }\n};\nlocales_locales.en = locales_locales['en-US'];\nlocales_locales.es = locales_locales['es-ES'];\nlocales_locales.no = locales_locales.nb;\nlocales_locales.zh = locales_locales['zh-CN']; // Remap from abbr. to intuitive property names\n\ntoPairs_default()(locales_locales).forEach(function ([id, {\n  dow,\n  L\n}]) {\n  locales_locales[id] = {\n    id,\n    firstDayOfWeek: dow,\n    masks: {\n      L\n    }\n  };\n});\n/* harmony default export */ var defaults_locales = (locales_locales);\n// CONCATENATED MODULE: ./src/utils/defaults/index.js\n// Vue won't get included in bundle as it is externalized\n// https://cli.vuejs.org/guide/build-targets.html#library\n\n\n\n\n\n\nconst pluginDefaults = {\n  componentPrefix: 'v',\n  navVisibility: 'click',\n  titlePosition: 'center',\n  transition: 'slide-h',\n  touch: touch,\n  masks: defaults_masks,\n  screens: defaults_screens,\n  locales: defaults_locales,\n  datePicker: {\n    updateOnInput: true,\n    inputDebounce: 1000,\n    popover: {\n      visibility: 'hover-focus',\n      placement: 'bottom-start',\n      keepVisibleOnInput: false,\n      isInteractive: true\n    }\n  }\n};\nlet defaults_ = null;\nconst setupDefaults = function (opts) {\n  if (!defaults_) {\n    defaults_ = new external_commonjs_vue_commonjs2_vue_root_Vue_default.a({\n      data() {\n        return {\n          defaults: defaultsDeep_default()(opts, pluginDefaults)\n        };\n      },\n\n      computed: {\n        locales() {\n          var _this = this;\n\n          return mapValues_default()(this.defaults.locales, function (v) {\n            v.masks = defaultsDeep_default()(v.masks, _this.defaults.masks);\n            return v;\n          });\n        }\n\n      }\n    });\n  }\n\n  return defaults_.defaults;\n};\nconst defaultsMixin = {\n  beforeCreate() {\n    setupDefaults();\n  },\n\n  computed: {\n    $defaults() {\n      return defaults_.defaults;\n    },\n\n    $locales() {\n      return defaults_.locales;\n    }\n\n  },\n  methods: {\n    propOrDefault(prop, defaultPath, strategy) {\n      return this.passedProp(prop, get_default()(this.$defaults, defaultPath), strategy);\n    },\n\n    passedProp(prop, fallback, strategy) {\n      if (_has(this.$options.propsData, prop)) {\n        const propValue = this[prop];\n\n        if (isObject(propValue) && strategy === 'merge') {\n          return defaultsDeep_default()(propValue, fallback);\n        }\n\n        return propValue;\n      }\n\n      return fallback;\n    }\n\n  }\n};\n// CONCATENATED MODULE: ./src/utils/mixins/child.js\n\nconst childMixin = {\n  inject: ['sharedState'],\n  mixins: [defaultsMixin],\n  computed: {\n    masks() {\n      return this.sharedState.masks;\n    },\n\n    theme() {\n      return this.sharedState.theme;\n    },\n\n    locale() {\n      return this.sharedState.locale;\n    },\n\n    dayPopoverId() {\n      return this.sharedState.dayPopoverId;\n    }\n\n  },\n  methods: {\n    format(date, mask) {\n      return this.locale.format(date, mask);\n    }\n\n  }\n};\n// CONCATENATED MODULE: ./src/utils/theme.js\n\n\nconst targetProps = ['base', 'start', 'end', 'startEnd'];\nconst displayProps = ['class', 'style', 'color', 'fillMode'];\nconst defConfig = {\n  color: 'blue',\n  isDark: false,\n  highlight: {\n    base: {\n      fillMode: 'light'\n    },\n    start: {\n      fillMode: 'solid'\n    },\n    end: {\n      fillMode: 'solid'\n    }\n  },\n  dot: {\n    base: {\n      fillMode: 'solid'\n    },\n    start: {\n      fillMode: 'solid'\n    },\n    end: {\n      fillMode: 'solid'\n    }\n  },\n  bar: {\n    base: {\n      fillMode: 'solid'\n    },\n    start: {\n      fillMode: 'solid'\n    },\n    end: {\n      fillMode: 'solid'\n    }\n  },\n  content: {\n    base: {},\n    start: {},\n    end: {}\n  }\n};\nclass theme_Theme {\n  constructor(config) {\n    Object.assign(this, defConfig, config);\n  } // Normalizes attribute config to the structure defined by the properties\n\n\n  normalizeAttr({\n    config,\n    type\n  }) {\n    let rootColor = this.color;\n    let root = {}; // Get the normalized root config\n\n    const normAttr = this[type];\n\n    if (config === true || isString_default()(config)) {\n      // Assign default color for booleans or strings\n      rootColor = isString_default()(config) ? config : rootColor; // Set the default root\n\n      root = { ...normAttr\n      };\n    } else if (isObject(config)) {\n      if (hasAny(config, targetProps)) {\n        // Mixin target configs\n        root = { ...config\n        };\n      } else {\n        // Mixin display configs\n        root = {\n          base: { ...config\n          },\n          start: { ...config\n          },\n          end: { ...config\n          }\n        };\n      }\n    } else {\n      return null;\n    } // Fill in missing targets\n\n\n    defaults_default()(root, {\n      start: root.startEnd,\n      end: root.startEnd\n    }, normAttr); // Normalize each target\n\n    toPairs_default()(root).forEach(function ([targetType, targetConfig]) {\n      let targetColor = rootColor;\n\n      if (targetConfig === true || isString_default()(targetConfig)) {\n        targetColor = isString_default()(targetConfig) ? targetConfig : targetColor;\n        root[targetType] = {\n          color: targetColor\n        };\n      } else if (isObject(targetConfig)) {\n        if (hasAny(targetConfig, displayProps)) {\n          root[targetType] = { ...targetConfig\n          };\n        } else {\n          root[targetType] = {};\n        }\n      } // Set the theme color if it is missing\n\n\n      if (!_has(root, `${targetType}.color`)) {\n        set_default()(root, `${targetType}.color`, targetColor);\n      }\n    });\n    return root;\n  }\n\n  normalizeHighlight(config) {\n    var _this = this;\n\n    const highlight = this.normalizeAttr({\n      config,\n      type: 'highlight'\n    });\n    toPairs_default()(highlight).forEach(function ([_, targetConfig]) {\n      const c = defaults_default()(targetConfig, {\n        isDark: _this.isDark,\n        color: _this.color\n      });\n      targetConfig.style = { ..._this.getHighlightBgStyle(c),\n        ...targetConfig.style\n      };\n      targetConfig.contentStyle = { ..._this.getHighlightContentStyle(c),\n        ...targetConfig.contentStyle\n      };\n    });\n    return highlight;\n  }\n\n  getHighlightBgStyle({\n    fillMode,\n    color,\n    isDark\n  }) {\n    switch (fillMode) {\n      case 'none':\n        return {\n          backgroundColor: isDark ? 'var(--gray-900)' : 'var(--white)',\n          border: '2px solid',\n          borderColor: isDark ? `var(--${color}-200)` : `var(--${color}-700)`,\n          borderRadius: 'var(--rounded-full)'\n        };\n\n      case 'light':\n        return {\n          backgroundColor: isDark ? `var(--${color}-800)` : `var(--${color}-200)`,\n          opacity: isDark ? 0.75 : 1,\n          borderRadius: 'var(--rounded-full)'\n        };\n\n      case 'solid':\n        return {\n          backgroundColor: isDark ? `var(--${color}-500)` : `var(--${color}-600)`,\n          borderRadius: 'var(--rounded-full)'\n        };\n\n      default:\n        return null;\n    }\n  }\n\n  getHighlightContentStyle({\n    fillMode,\n    color,\n    isDark\n  }) {\n    switch (fillMode) {\n      case 'none':\n        return {\n          fontWeight: 'var(--font-bold)',\n          color: isDark ? `var(--${color}-100)` : `var(--${color}-900)`\n        };\n\n      case 'light':\n        return {\n          fontWeight: 'var(--font-bold)',\n          color: isDark ? `var(--${color}-100)` : `var(--${color}-900)`\n        };\n\n      case 'solid':\n        return {\n          fontWeight: 'var(--font-bold)',\n          color: 'var(--white)'\n        };\n\n      default:\n        return '';\n    }\n  }\n\n  bgAccentHigh({\n    color,\n    isDark\n  }) {\n    return {\n      backgroundColor: isDark ? `var(--${color}-500)` : `var(--${color}-600)`\n    };\n  }\n\n  contentAccent({\n    color,\n    isDark\n  }) {\n    return {\n      fontWeight: 'var(--font-bold)',\n      color: isDark ? `var(--${color}-100)` : `var(--${color}-900)`\n    };\n  }\n\n  normalizeDot(config) {\n    return this.normalizeNonHighlight('dot', config, this.bgAccentHigh);\n  }\n\n  normalizeBar(config) {\n    return this.normalizeNonHighlight('bar', config, this.bgAccentHigh);\n  }\n\n  normalizeContent(config) {\n    return this.normalizeNonHighlight('content', config, this.contentAccent);\n  }\n\n  normalizeNonHighlight(type, config, styleFn) {\n    var _this2 = this;\n\n    const attr = this.normalizeAttr({\n      type,\n      config\n    });\n    toPairs_default()(attr).forEach(function ([_, targetConfig]) {\n      defaults_default()(targetConfig, {\n        isDark: _this2.isDark,\n        color: _this2.color\n      });\n      targetConfig.style = { ...styleFn(targetConfig),\n        ...targetConfig.style\n      };\n    });\n    return attr;\n  }\n\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js\nvar es_string_replace = __webpack_require__(\"5319\");\n\n// CONCATENATED MODULE: ./src/utils/locale.js\n\n\n/* eslint-disable no-bitwise, no-multi-assign */\n\n\n\nconst token = /d{1,2}|W{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|X{1,3}|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\nconst twoDigits = /\\d\\d?/;\nconst threeDigits = /\\d{3}/;\nconst fourDigits = /\\d{4}/;\nconst word = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\nconst literal = /\\[([^]*?)\\]/gm;\n\nconst noop = function () {};\n\nconst monthUpdate = function (arrName) {\n  return function (d, v, l) {\n    const index = l[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());\n\n    if (~index) {\n      d.month = index;\n    }\n  };\n};\n\nconst daysInWeek = 7;\nconst daysInMonths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst formatFlags = {\n  D(d) {\n    return d.day;\n  },\n\n  DD(d) {\n    return pad(d.day);\n  },\n\n  Do(d, l) {\n    return l.DoFn(d.day);\n  },\n\n  d(d) {\n    return d.weekday - 1;\n  },\n\n  dd(d) {\n    return pad(d.weekday - 1);\n  },\n\n  W(d, l) {\n    return l.dayNamesNarrow[d.weekday - 1];\n  },\n\n  WW(d, l) {\n    return l.dayNamesShorter[d.weekday - 1];\n  },\n\n  WWW(d, l) {\n    return l.dayNamesShort[d.weekday - 1];\n  },\n\n  WWWW(d, l) {\n    return l.dayNames[d.weekday - 1];\n  },\n\n  M(d) {\n    return d.month;\n  },\n\n  MM(d) {\n    return pad(d.month);\n  },\n\n  MMM(d, l) {\n    return l.monthNamesShort[d.month - 1];\n  },\n\n  MMMM(d, l) {\n    return l.monthNames[d.month - 1];\n  },\n\n  YY(d) {\n    return String(d.year).substr(2);\n  },\n\n  YYYY(d) {\n    return pad(d.year, 4);\n  },\n\n  h(d) {\n    return d.hours % 12 || 12;\n  },\n\n  hh(d) {\n    return pad(d.hours % 12 || 12);\n  },\n\n  H(d) {\n    return d.hours;\n  },\n\n  HH(d) {\n    return pad(d.hours);\n  },\n\n  m(d) {\n    return d.minutes;\n  },\n\n  mm(d) {\n    return pad(d.minutes);\n  },\n\n  s(d) {\n    return d.seconds;\n  },\n\n  ss(d) {\n    return pad(d.seconds);\n  },\n\n  S(d) {\n    return Math.round(d.milliseconds / 100);\n  },\n\n  SS(d) {\n    return pad(Math.round(d.milliseconds / 10), 2);\n  },\n\n  SSS(d) {\n    return pad(d.milliseconds, 3);\n  },\n\n  a(d, l) {\n    return d.hours < 12 ? l.amPm[0] : l.amPm[1];\n  },\n\n  A(d, l) {\n    return d.hours < 12 ? l.amPm[0].toUpperCase() : l.amPm[1].toUpperCase();\n  },\n\n  X(d) {\n    const o = d.timezoneOffset;\n    return `${o > 0 ? '-' : '+'}${pad(Math.floor(Math.abs(o) / 60), 2)}`;\n  },\n\n  XX(d) {\n    const o = d.timezoneOffset;\n    return `${o > 0 ? '-' : '+'}${pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4)}`;\n  },\n\n  XXX(d) {\n    const o = d.timezoneOffset;\n    return `${o > 0 ? '-' : '+'}${pad(Math.floor(Math.abs(o) / 60), 2)}:${pad(Math.abs(o) % 60, 2)}`;\n  }\n\n};\nconst parseFlags = {\n  D: [twoDigits, function (d, v) {\n    d.day = v;\n  }],\n  Do: [new RegExp(twoDigits.source + word.source), function (d, v) {\n    d.day = parseInt(v, 10);\n  }],\n  d: [twoDigits, noop],\n  W: [word, noop],\n  M: [twoDigits, function (d, v) {\n    d.month = v - 1;\n  }],\n  MMM: [word, monthUpdate('monthNamesShort')],\n  MMMM: [word, monthUpdate('monthNames')],\n  YY: [twoDigits, function (d, v) {\n    const da = new Date();\n    const cent = +da.getFullYear().toString().substr(0, 2);\n    d.year = `${v > 68 ? cent - 1 : cent}${v}`;\n  }],\n  YYYY: [fourDigits, function (d, v) {\n    d.year = v;\n  }],\n  S: [/\\d/, function (d, v) {\n    d.millisecond = v * 100;\n  }],\n  SS: [/\\d{2}/, function (d, v) {\n    d.millisecond = v * 10;\n  }],\n  SSS: [threeDigits, function (d, v) {\n    d.millisecond = v;\n  }],\n  h: [twoDigits, function (d, v) {\n    d.hour = v;\n  }],\n  m: [twoDigits, function (d, v) {\n    d.minute = v;\n  }],\n  s: [twoDigits, function (d, v) {\n    d.second = v;\n  }],\n  a: [word, function (d, v, l) {\n    const val = v.toLowerCase();\n\n    if (val === l.amPm[0]) {\n      d.isPm = false;\n    } else if (val === l.amPm[1]) {\n      d.isPm = true;\n    }\n  }],\n  X: [/[^\\s]*?[+-]\\d\\d:?\\d\\d|[^\\s]*?Z?/, function (d, v) {\n    if (v === 'Z') v = '+00:00';\n    const parts = `${v}`.match(/([+-]|\\d\\d)/gi);\n\n    if (parts) {\n      const minutes = +(parts[1] * 60) + parseInt(parts[2], 10);\n      d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;\n    }\n  }]\n};\nparseFlags.DD = parseFlags.D;\nparseFlags.dd = parseFlags.d;\nparseFlags.WWWW = parseFlags.WWW = parseFlags.WW = parseFlags.W;\nparseFlags.MM = parseFlags.M;\nparseFlags.mm = parseFlags.m;\nparseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;\nparseFlags.ss = parseFlags.s;\nparseFlags.A = parseFlags.a;\nparseFlags.XXX = parseFlags.XX = parseFlags.X;\nfunction resolveConfig(config, locales) {\n  // Get the detected locale string\n  const detLocale = new Intl.DateTimeFormat().resolvedOptions().locale; // Resolve the locale id\n\n  let id;\n\n  if (isString_default()(config)) {\n    id = config;\n  } else if (_has(config, 'id')) {\n    id = config.id;\n  }\n\n  id = (id || detLocale).toLowerCase();\n  const localeKeys = Object.keys(locales);\n\n  const validKey = function (k) {\n    return localeKeys.find(function (lk) {\n      return lk.toLowerCase() === k;\n    });\n  };\n\n  id = validKey(id) || validKey(id.substring(0, 2)) || detLocale; // Add fallback and spread default locale to prevent repetitive update loops\n\n  const defLocale = { ...locales['en-IE'],\n    ...locales[id],\n    id\n  }; // Assign or merge defaults with provided config\n\n  config = isObject(config) ? defaultsDeep_default()(config, defLocale) : defLocale; // Return resolved config\n\n  return config;\n}\nclass locale_Locale {\n  constructor(config, locales = defaults_locales) {\n    const {\n      id,\n      firstDayOfWeek,\n      masks\n    } = resolveConfig(config, locales);\n    this.id = id;\n    this.firstDayOfWeek = clamp_default()(firstDayOfWeek, 1, daysInWeek);\n    this.masks = masks;\n    this.dayNames = this.getDayNames('long');\n    this.dayNamesShort = this.getDayNames('short');\n    this.dayNamesShorter = this.dayNamesShort.map(function (s) {\n      return s.substring(0, 2);\n    });\n    this.dayNamesNarrow = this.getDayNames('narrow');\n    this.monthNames = this.getMonthNames('long');\n    this.monthNamesShort = this.getMonthNames('short');\n    this.amPm = ['am', 'pm'];\n    this.monthData = {}; // Bind methods\n\n    this.getMonthComps = this.getMonthComps.bind(this);\n    this.parse = this.parse.bind(this);\n    this.format = this.format.bind(this);\n    this.toPage = this.toPage.bind(this);\n  }\n\n  format(date, mask, timezone) {\n    var _this = this;\n\n    mask = arrayHasItems(mask) && mask[0] || isString_default()(mask) && mask || 'YYYY-MM-DD';\n    date = this.getDateParts(this.normalizeDate(date), timezone);\n    mask = this.masks[mask] || mask;\n    const literals = []; // Make literals inactive by replacing them with ??\n\n    mask = mask.replace(literal, function ($0, $1) {\n      literals.push($1);\n      return '??';\n    }); // Apply formatting rules\n\n    mask = mask.replace(token, function ($0) {\n      return $0 in formatFlags ? formatFlags[$0](date, _this) : $0.slice(1, $0.length - 1);\n    }); // Inline literal values back into the formatted value\n\n    return mask.replace(/\\?\\?/g, function () {\n      return literals.shift();\n    });\n  }\n\n  parse(dateStr, mask, timezone) {\n    var _this2 = this;\n\n    const masks = arrayHasItems(mask) && mask || [isString_default()(mask) && mask || 'YYYY-MM-DD'];\n    return masks.map(function (m) {\n      if (typeof m !== 'string') {\n        throw new Error('Invalid mask in fecha.parse');\n      }\n\n      m = _this2.masks[m] || m; // Avoid regular expression denial of service, fail early for really long strings\n      // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n\n      if (dateStr.length > 1000) {\n        return false;\n      }\n\n      let isValid = true;\n      const dateInfo = {};\n      m.replace(token, function ($0) {\n        if (parseFlags[$0]) {\n          const info = parseFlags[$0];\n          const index = dateStr.search(info[0]);\n\n          if (!~index) {\n            isValid = false;\n          } else {\n            dateStr.replace(info[0], function (result) {\n              info[1](dateInfo, result, _this2);\n              dateStr = dateStr.substr(index + result.length);\n              return result;\n            });\n          }\n        }\n\n        return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);\n      });\n\n      if (!isValid) {\n        return false;\n      }\n\n      const today = new Date();\n\n      if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {\n        dateInfo.hour = +dateInfo.hour + 12;\n      } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {\n        dateInfo.hour = 0;\n      }\n\n      let date;\n\n      if (dateInfo.timezoneOffset != null) {\n        dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;\n        date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));\n      } else {\n        date = _this2.getDateFromParts({\n          year: dateInfo.year || today.getFullYear(),\n          month: (dateInfo.month || 0) + 1,\n          day: dateInfo.day || 1,\n          hours: dateInfo.hour || 0,\n          minutes: dateInfo.minute || 0,\n          seconds: dateInfo.second || 0,\n          milliseconds: dateInfo.millisecond || 0\n        }, timezone);\n      }\n\n      return date;\n    }).find(function (d) {\n      return d;\n    }) || new Date(dateStr);\n  }\n\n  normalizeDate(d, config = {}) {\n    let result = null;\n    let type = config.type;\n    const auto = type === 'auto' || !type;\n\n    if (isNumber_default()(d)) {\n      type = 'number';\n      result = new Date(+d);\n    } else if (isString_default()(d)) {\n      type = 'string';\n      const mask = config.mask || 'iso';\n      result = d ? this.parse(d, mask, config.timezone) : null;\n    } else if (isObject(d)) {\n      type = 'object';\n      result = this.getDateFromParts(d, config.timezone);\n    } else {\n      type = 'date';\n      result = _isDate(d) ? new Date(d.getTime()) : null;\n    }\n\n    if (auto) config.type = type;\n    return result && !isNaN(result.getTime()) ? result : null;\n  }\n\n  denormalizeDate(date, {\n    type,\n    mask,\n    timezone\n  } = {}) {\n    switch (type) {\n      case 'number':\n        return date ? date.getTime() : NaN;\n\n      case 'string':\n        return date ? this.format(date, mask || 'iso', timezone) : '';\n\n      default:\n        return date ? new Date(date) : null;\n    }\n  }\n\n  adjustTimeForDate(date, {\n    timeAdjust,\n    timezone\n  }) {\n    if (timeAdjust) {\n      const dateParts = this.getDateParts(date, timezone);\n\n      if (timeAdjust === 'now') {\n        const timeParts = this.getDateParts(new Date(), timezone);\n        dateParts.hours = timeParts.hours;\n        dateParts.minutes = timeParts.minutes;\n        dateParts.seconds = timeParts.seconds;\n      } else {\n        const timeParts = timeAdjust.split(':');\n        dateParts.hours = +timeParts[0];\n        dateParts.minutes = +timeParts[1];\n        dateParts.seconds = +timeParts[2];\n      }\n\n      date = this.getDateFromParts(dateParts, timezone);\n    }\n\n    return date;\n  }\n\n  getDateParts(date, timezone) {\n    if (!date) return null;\n    let tzDate = date;\n\n    if (timezone) {\n      const normDate = new Date(date.toLocaleString('en-US', {\n        timeZone: timezone\n      }));\n      const diff = normDate.getTime() - date.getTime();\n      tzDate = new Date(date.getTime() + diff);\n    }\n\n    const seconds = tzDate.getSeconds();\n    const minutes = tzDate.getMinutes();\n    const hours = tzDate.getHours();\n    const month = tzDate.getMonth() + 1;\n    const year = tzDate.getFullYear();\n    const comps = this.getMonthComps(month, year);\n    const day = tzDate.getDate();\n    const dayFromEnd = comps.days - day + 1;\n    const weekday = tzDate.getDay() + 1;\n    const weekdayOrdinal = Math.floor((day - 1) / 7 + 1);\n    const weekdayOrdinalFromEnd = Math.floor((comps.days - day) / 7 + 1);\n    const week = Math.ceil((day + Math.abs(comps.firstWeekday - comps.firstDayOfWeek)) / 7);\n    const weekFromEnd = comps.weeks - week + 1;\n    const parts = {\n      seconds,\n      minutes,\n      hours,\n      day,\n      dayFromEnd,\n      weekday,\n      weekdayOrdinal,\n      weekdayOrdinalFromEnd,\n      week,\n      weekFromEnd,\n      month,\n      year,\n      date,\n      isValid: true\n    };\n    parts.timezoneOffset = this.getTimezoneOffset(parts, timezone) / 60000;\n    return parts;\n  }\n\n  getDateFromParts(parts, timezone) {\n    if (!parts) return null;\n    const {\n      year: y,\n      month: m,\n      day: d,\n      hours: hrs,\n      minutes: min,\n      seconds: sec,\n      milliseconds: ms\n    } = parts;\n    if (y === undefined || m === undefined || d === undefined) return null;\n    const utcDate = new Date(Date.UTC(y || 0, m - 1, d || 0, hrs || 0, min || 0, sec || 0, ms || 0));\n    const tzOffsetMs = this.getTimezoneOffset(parts, timezone);\n    return new Date(utcDate.getTime() + tzOffsetMs);\n  }\n\n  getTimezoneOffset(parts, timezone) {\n    const {\n      year: y,\n      month: m,\n      day: d,\n      minutes: min,\n      seconds: sec,\n      milliseconds: ms\n    } = parts;\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      hour: 'numeric',\n      hour12: false,\n      hourCycle: 'h24',\n      timeZone: timezone || undefined\n    });\n    const utcNoon = new Date(Date.UTC(y || 0, m - 1, d || 0, 12, min || 0, sec || 0, ms || 0));\n    const tzHours = +formatter.format(utcNoon);\n    const tzOffset = 12 - tzHours;\n    const msInHour = 3600000;\n    return tzOffset * msInHour;\n  }\n\n  toPage(arg, fromPage) {\n    if (isNumber_default()(arg)) {\n      return addPages(fromPage, arg);\n    }\n\n    if (isString_default()(arg)) {\n      return pageForDate(this.normalizeDate(arg));\n    }\n\n    if (_isDate(arg)) {\n      return pageForDate(arg);\n    }\n\n    if (isObject(arg)) {\n      return arg;\n    }\n\n    return null;\n  }\n\n  getMonthDates(year = 2000) {\n    const dates = [];\n\n    for (let i = 0; i < 12; i++) {\n      dates.push(new Date(year, i, 15));\n    }\n\n    return dates;\n  }\n\n  getMonthNames(length) {\n    const dtf = new Intl.DateTimeFormat(this.id, {\n      month: length,\n      timezome: 'UTC'\n    });\n    return this.getMonthDates().map(function (d) {\n      return dtf.format(d);\n    });\n  }\n\n  getWeekdayDates({\n    year = 2000,\n    utc = false,\n    firstDayOfWeek = this.firstDayOfWeek\n  } = {}) {\n    const dates = [];\n\n    for (let i = 1, j = 0; j < daysInWeek; i++) {\n      const d = utc ? new Date(Date.UTC(year, 0, i)) : new Date(year, 0, i);\n      const day = utc ? d.getUTCDay() : d.getDay();\n\n      if (day === firstDayOfWeek - 1 || j > 0) {\n        dates.push(d);\n        j++;\n      }\n    }\n\n    return dates;\n  }\n\n  getDayNames(length) {\n    const dtf = new Intl.DateTimeFormat(this.id, {\n      weekday: length,\n      timeZone: 'UTC'\n    });\n    return this.getWeekdayDates({\n      firstDayOfWeek: 1,\n      utc: true\n    }).map(function (d) {\n      return dtf.format(d);\n    });\n  } // Days/month/year components for a given month and year\n\n\n  getMonthComps(month, year) {\n    const key = `${month}-${year}`;\n    let comps = this.monthData[key];\n\n    if (!comps) {\n      const inLeapYear = year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n      const firstWeekday = new Date(year, month - 1, 1).getDay() + 1;\n      const days = month === 2 && inLeapYear ? 29 : daysInMonths[month - 1];\n      const weeks = Math.ceil((days + Math.abs(firstWeekday - this.firstDayOfWeek)) / daysInWeek);\n      comps = {\n        firstDayOfWeek: this.firstDayOfWeek,\n        inLeapYear,\n        firstWeekday,\n        days,\n        weeks,\n        month,\n        year\n      };\n      this.monthData[key] = comps;\n    }\n\n    return comps;\n  } // Days/month/year components for today's month\n\n\n  getThisMonthComps() {\n    const date = new Date();\n    return this.getMonthComps(date.getMonth() + 1, date.getFullYear());\n  } // Day/month/year components for previous month\n\n\n  getPrevMonthComps(month, year) {\n    if (month === 1) return this.getMonthComps(12, year - 1);\n    return this.getMonthComps(month - 1, year);\n  } // Day/month/year components for next month\n\n\n  getNextMonthComps(month, year) {\n    if (month === 12) return this.getMonthComps(1, year + 1);\n    return this.getMonthComps(month + 1, year);\n  }\n\n  getDayId(date) {\n    return this.format(date, 'YYYY-MM-DD');\n  } // Builds day components for a given page\n\n\n  getCalendarDays({\n    monthComps,\n    prevMonthComps,\n    nextMonthComps\n  }, timezone) {\n    var _this3 = this;\n\n    const days = [];\n    const {\n      firstDayOfWeek,\n      firstWeekday\n    } = monthComps;\n    const prevMonthDaysToShow = firstWeekday + (firstWeekday < firstDayOfWeek ? daysInWeek : 0) - firstDayOfWeek;\n    let prevMonth = true;\n    let thisMonth = false;\n    let nextMonth = false; // Formatter for aria labels\n\n    const formatter = new Intl.DateTimeFormat(this.id, {\n      weekday: 'long',\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric'\n    }); // Init counters with previous month's data\n\n    let day = prevMonthComps.days - prevMonthDaysToShow + 1;\n    let dayFromEnd = prevMonthComps.days - day + 1;\n    let weekdayOrdinal = Math.floor((day - 1) / daysInWeek + 1);\n    let weekdayOrdinalFromEnd = 1;\n    let week = prevMonthComps.weeks;\n    let weekFromEnd = 1;\n    let month = prevMonthComps.month;\n    let year = prevMonthComps.year; // Store todays comps\n\n    const today = new Date();\n    const todayDay = today.getDate();\n    const todayMonth = today.getMonth() + 1;\n    const todayYear = today.getFullYear();\n\n    const dft = function (y, m, d) {\n      return function (hours, minutes, seconds, milliseconds) {\n        return _this3.normalizeDate({\n          year: y,\n          month: m,\n          day: d,\n          hours,\n          minutes,\n          seconds,\n          milliseconds\n        }, {\n          timezone\n        });\n      };\n    }; // Cycle through 6 weeks (max in month)\n\n\n    for (let w = 1; w <= 6; w++) {\n      // Cycle through days in week\n      for (let i = 1, weekday = firstDayOfWeek; i <= daysInWeek; i++, weekday += weekday === daysInWeek ? 1 - daysInWeek : 1) {\n        // We need to know when to start counting actual month days\n        if (prevMonth && weekday === firstWeekday) {\n          // Reset counters for current month\n          day = 1;\n          dayFromEnd = monthComps.days;\n          weekdayOrdinal = Math.floor((day - 1) / daysInWeek + 1);\n          weekdayOrdinalFromEnd = Math.floor((monthComps.days - day) / daysInWeek + 1);\n          week = 1;\n          weekFromEnd = monthComps.weeks;\n          month = monthComps.month;\n          year = monthComps.year; // ...and flag we're tracking actual month days\n\n          prevMonth = false;\n          thisMonth = true;\n        } // Append day info for the current week\n        // Note: this might or might not be an actual month day\n        //  We don't know how the UI wants to display various days,\n        //  so we'll supply all the data we can\n\n\n        const dateFromTime = dft(year, month, day);\n        const date = dateFromTime(12, 0, 0, 0);\n        const range = {\n          start: dateFromTime(0, 0, 0),\n          end: dateFromTime(23, 59, 59, 999)\n        };\n        const id = this.getDayId(date);\n        const weekdayPosition = i;\n        const weekdayPositionFromEnd = daysInWeek - i;\n        const isToday = day === todayDay && month === todayMonth && year === todayYear;\n        const isFirstDay = thisMonth && day === 1;\n        const isLastDay = thisMonth && day === monthComps.days;\n        const onTop = w === 1;\n        const onBottom = w === 6;\n        const onLeft = i === 1;\n        const onRight = i === daysInWeek;\n        days.push({\n          id,\n          label: day.toString(),\n          ariaLabel: formatter.format(new Date(year, month, day)),\n          day,\n          dayFromEnd,\n          weekday,\n          weekdayPosition,\n          weekdayPositionFromEnd,\n          weekdayOrdinal,\n          weekdayOrdinalFromEnd,\n          week,\n          weekFromEnd,\n          month,\n          year,\n          dateFromTime,\n          date,\n          range,\n          isToday,\n          isFirstDay,\n          isLastDay,\n          inMonth: thisMonth,\n          inPrevMonth: prevMonth,\n          inNextMonth: nextMonth,\n          onTop,\n          onBottom,\n          onLeft,\n          onRight,\n          classes: [`id-${id}`, `day-${day}`, `day-from-end-${dayFromEnd}`, `weekday-${weekday}`, `weekday-position-${weekdayPosition}`, `weekday-ordinal-${weekdayOrdinal}`, `weekday-ordinal-from-end-${weekdayOrdinalFromEnd}`, `week-${week}`, `week-from-end-${weekFromEnd}`, {\n            'is-today': isToday,\n            'is-first-day': isFirstDay,\n            'is-last-day': isLastDay,\n            'in-month': thisMonth,\n            'in-prev-month': prevMonth,\n            'in-next-month': nextMonth,\n            'on-top': onTop,\n            'on-bottom': onBottom,\n            'on-left': onLeft,\n            'on-right': onRight\n          }]\n        }); // See if we've hit the last day of the month\n\n        if (thisMonth && isLastDay) {\n          thisMonth = false;\n          nextMonth = true; // Reset counters to next month's data\n\n          day = 1;\n          dayFromEnd = nextMonthComps.days;\n          weekdayOrdinal = 1;\n          weekdayOrdinalFromEnd = Math.floor((nextMonthComps.days - day) / daysInWeek + 1);\n          week = 1;\n          weekFromEnd = nextMonthComps.weeks;\n          month = nextMonthComps.month;\n          year = nextMonthComps.year; // Still in the middle of the month (hasn't ended yet)\n        } else {\n          day++;\n          dayFromEnd--;\n          weekdayOrdinal = Math.floor((day - 1) / daysInWeek + 1);\n          weekdayOrdinalFromEnd = Math.floor((monthComps.days - day) / daysInWeek + 1);\n        }\n      } // Append week days\n\n\n      week++;\n      weekFromEnd--;\n    }\n\n    return days;\n  }\n\n}\n// CONCATENATED MODULE: ./src/utils/buildMediaQuery.js\n // This function gratuitously borrowed from TailwindCSS\n// https://github.com/tailwindcss/tailwindcss/blob/master/src/util/buildMediaQuery.js\n\nfunction buildMediaQuery(screens) {\n  // Default min width\n  if (isString_default()(screens)) {\n    screens = {\n      min: screens\n    };\n  } // Wrap in array\n\n\n  if (!isArrayLikeObject_default()(screens)) {\n    screens = [screens];\n  }\n\n  return screens.map(function (screen) {\n    if (_has(screen, 'raw')) {\n      return screen.raw;\n    }\n\n    return map_default()(screen, function (value, feature) {\n      feature = get_default()({\n        min: 'min-width',\n        max: 'max-width'\n      }, feature, feature);\n      return `(${feature}: ${value})`;\n    }).join(' and ');\n  }).join(', ');\n}\n// CONCATENATED MODULE: ./src/utils/screens.js\n// Vue won't get included in bundle as it is externalized\n// https://cli.vuejs.org/guide/build-targets.html#library\n\n\n\n\nlet isSettingUp = false;\nlet shouldRefreshQueries = false;\nlet screensComp = null;\nfunction setupScreens(screens = defaults_screens, forceSetup) {\n  if (screensComp && !forceSetup || isSettingUp) {\n    return;\n  }\n\n  isSettingUp = true;\n  shouldRefreshQueries = true; // Use a private Vue component to store reactive screen matches\n\n  screensComp = new external_commonjs_vue_commonjs2_vue_root_Vue_default.a({\n    data() {\n      return {\n        matches: [],\n        queries: []\n      };\n    },\n\n    methods: {\n      refreshQueries() {\n        var _this = this;\n\n        this.queries = mapValues_default()(screens, function (v) {\n          const query = window.matchMedia(buildMediaQuery(v));\n          query.addListener(_this.refreshMatches);\n          return query;\n        });\n        this.refreshMatches();\n      },\n\n      refreshMatches() {\n        this.matches = toPairs_default()(this.queries).filter(function (p) {\n          return p[1].matches;\n        }).map(function (p) {\n          return p[0];\n        });\n      }\n\n    }\n  });\n  isSettingUp = false;\n} // Global mixin that provides responsive '$screens' utility method\n// that refreshes any time the screen matches update\n\nexternal_commonjs_vue_commonjs2_vue_root_Vue_default.a.mixin({\n  beforeCreate() {\n    if (!isSettingUp) {\n      setupScreens();\n    }\n  },\n\n  mounted() {\n    if (shouldRefreshQueries && screensComp) {\n      screensComp.refreshQueries();\n      shouldRefreshQueries = false;\n    }\n  },\n\n  computed: {\n    $screens() {\n      return function (config, def) {\n        return screensComp.matches.reduce(function (prev, curr) {\n          return _has(config, curr) ? config[curr] : prev;\n        }, isUndefined_default()(def) ? config.default : def);\n      };\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/utils/dateInfo.js\n\n\n\n\nconst millisecondsPerDay = 24 * 60 * 60 * 1000;\nclass dateInfo_DateInfo {\n  constructor(config, {\n    order = 0,\n    locale\n  } = {}) {\n    this.isDateInfo = true;\n    this.isRange = isObject(config);\n    this.isDate = !this.isRange;\n    this.order = order;\n    this.locale = locale instanceof locale_Locale ? locale : new locale_Locale(locale);\n    this.firstDayOfWeek = this.locale.firstDayOfWeek; // Process date\n\n    if (this.isDate) {\n      this.type = 'date'; // Initialize date from config\n\n      this.date = this.locale.normalizeDate(config);\n      this.dateTime = this.date && this.date.getTime();\n    } // Process date range\n\n\n    if (this.isRange) {\n      this.type = 'range'; // Initialize start and end dates from config (null means infinity)\n\n      let start = this.locale.normalizeDate(config.start);\n      let end = this.locale.normalizeDate(config.end); // Reconfigure start and end dates if needed\n\n      if (start && end && start > end) {\n        const temp = start;\n        start = end;\n        end = temp;\n      } else if (start && config.span >= 1) {\n        end = addDays(start, config.span - 1);\n      } // Reset invalid dates to null and strip times for valid dates\n\n\n      if (start) {\n        if (!_isDate(start)) start = null;\n      }\n\n      if (end) {\n        if (!_isDate(end)) end = null;\n      } // Assign start and end dates\n\n\n      this.start = start;\n      this.startTime = start ? start.getTime() : NaN;\n      this.end = end;\n      this.endTime = end ? end.getTime() : NaN; // Assign spans\n\n      if (start && end) {\n        this.daySpan = this.diffInDays(start, end);\n        this.weekSpan = this.diffInWeeks(start, end);\n        this.monthSpan = this.diffInMonths(start, end);\n        this.yearSpan = this.diffInYears(start, end);\n      } // Assign 'and' condition\n\n\n      const andOpt = mixinOptionalProps(config, {}, dateInfo_DateInfo.patternProps);\n\n      if (andOpt.assigned) {\n        this.on = {\n          and: andOpt.target\n        };\n      } // Assign 'or' conditions\n\n\n      if (config.on) {\n        const or = (isArrayLikeObject_default()(config.on) ? config.on : [config.on]).map(function (o) {\n          if (isFunction_default()(o)) return o;\n          const opt = mixinOptionalProps(o, {}, dateInfo_DateInfo.patternProps);\n          return opt.assigned ? opt.target : null;\n        }).filter(function (o) {\n          return o;\n        });\n        if (or.length) this.on = { ...this.on,\n          or\n        };\n      } // Assign flag if date is complex\n\n\n      this.isComplex = !!this.on;\n    }\n  }\n\n  get opts() {\n    return {\n      order: this.order,\n      locale: this.locale\n    };\n  }\n\n  toDateInfo(date) {\n    return date.isDateInfo ? date : new dateInfo_DateInfo(date, this.opts);\n  }\n\n  startOfWeek(date) {\n    const day = date.getDay() + 1;\n    const daysToAdd = day >= this.firstDayOfWeek ? this.firstDayOfWeek - day : -(7 - (this.firstDayOfWeek - day));\n    return addDays(date, daysToAdd);\n  }\n\n  diffInDays(d1, d2) {\n    return Math.round((d2 - d1) / millisecondsPerDay);\n  }\n\n  diffInWeeks(d1, d2) {\n    return this.diffInDays(this.startOfWeek(d1), this.startOfWeek(d2));\n  }\n\n  diffInYears(d1, d2) {\n    return d2.getUTCFullYear() - d1.getUTCFullYear();\n  }\n\n  diffInMonths(d1, d2) {\n    return this.diffInYears(d1, d2) * 12 + (d2.getMonth() - d1.getMonth());\n  }\n\n  static get patterns() {\n    return {\n      dailyInterval: {\n        test: function (day, interval, di) {\n          return di.diffInDays(di.start || new Date(), day.date) % interval === 0;\n        }\n      },\n      weeklyInterval: {\n        test: function (day, interval, di) {\n          return di.diffInWeeks(di.start || new Date(), day.date) % interval === 0;\n        }\n      },\n      monthlyInterval: {\n        test: function (day, interval, di) {\n          return di.diffInMonths(di.start || new Date(), day.date) % interval === 0;\n        }\n      },\n      yearlyInterval: {\n        test: function () {\n          return function (day, interval, di) {\n            return di.diffInYears(di.start || new Date(), day.date) % interval === 0;\n          };\n        }\n      },\n      days: {\n        validate: function (days) {\n          return isArrayLikeObject_default()(days) ? days : [parseInt(days, 10)];\n        },\n        test: function (day, days) {\n          return days.includes(day.day) || days.includes(-day.dayFromEnd);\n        }\n      },\n      weekdays: {\n        validate: function (weekdays) {\n          return isArrayLikeObject_default()(weekdays) ? weekdays : [parseInt(weekdays, 10)];\n        },\n        test: function (day, weekdays) {\n          return weekdays.includes(day.weekday);\n        }\n      },\n      ordinalWeekdays: {\n        validate: function (ordinalWeekdays) {\n          return Object.keys(ordinalWeekdays).reduce(function (obj, ck) {\n            const weekdays = ordinalWeekdays[ck];\n            if (!weekdays) return obj;\n            obj[ck] = isArrayLikeObject_default()(weekdays) ? weekdays : [parseInt(weekdays, 10)];\n            return obj;\n          }, {});\n        },\n        test: function (day, ordinalWeekdays) {\n          return Object.keys(ordinalWeekdays).map(function (k) {\n            return parseInt(k, 10);\n          }).find(function (k) {\n            return ordinalWeekdays[k].includes(day.weekday) && (k === day.weekdayOrdinal || k === -day.weekdayOrdinalFromEnd);\n          });\n        }\n      },\n      weekends: {\n        validate: function (config) {\n          return config;\n        },\n        test: function (day) {\n          return day.weekday === 1 || day.weekday === 7;\n        }\n      },\n      workweek: {\n        validate: function (config) {\n          return config;\n        },\n        test: function (day) {\n          return day.weekday >= 2 && day.weekday <= 6;\n        }\n      },\n      weeks: {\n        validate: function (weeks) {\n          return isArrayLikeObject_default()(weeks) ? weeks : [parseInt(weeks, 10)];\n        },\n        test: function (day, weeks) {\n          return weeks.includes(day.week) || weeks.includes(-day.weekFromEnd);\n        }\n      },\n      months: {\n        validate: function (months) {\n          return isArrayLikeObject_default()(months) ? months : [parseInt(months, 10)];\n        },\n        test: function (day, months) {\n          return months.includes(day.month);\n        }\n      },\n      years: {\n        validate: function (years) {\n          return isArrayLikeObject_default()(years) ? years : [parseInt(years, 10)];\n        },\n        test: function (day, years) {\n          return years.includes(day.year);\n        }\n      }\n    };\n  }\n\n  static get patternProps() {\n    return Object.keys(dateInfo_DateInfo.patterns).map(function (k) {\n      return {\n        name: k,\n        validate: dateInfo_DateInfo.patterns[k].validate\n      };\n    });\n  }\n\n  static testConfig(config, day, dateInfo) {\n    if (isFunction_default()(config)) return config(day);\n\n    if (isObject(config)) {\n      return Object.keys(config).every(function (k) {\n        return dateInfo_DateInfo.patterns[k].test(day, config[k], dateInfo);\n      });\n    }\n\n    return null;\n  }\n\n  iterateDatesInRange({\n    start,\n    end\n  }, fn) {\n    if (!start || !end || !isFunction_default()(fn)) return null;\n    const state = {\n      i: 0,\n      date: start,\n      day: this.locale.getDateParts(start),\n      finished: false\n    };\n    let result = null;\n\n    for (; !state.finished && state.date <= end; state.i++) {\n      result = fn(state);\n      state.date = addDays(state.date, 1);\n      state.day = this.locale.getDateParts(state.date);\n    }\n\n    return result;\n  }\n\n  shallowIntersectingRange(other) {\n    return this.rangeShallowIntersectingRange(this, other);\n  } // Returns a date range that intersects two DateInfo objects\n  // NOTE: This is a shallow calculation (does not take patterns into account),\n  //   so this method should only really be called for special conditions\n  //   where absolute accuracy is not necessarily needed\n\n\n  rangeShallowIntersectingRange(date1, date2) {\n    date1 = this.toDateInfo(date1);\n    date2 = this.toDateInfo(date2);\n\n    if (!this.dateShallowIntersectsDate(date1, date2)) {\n      return null;\n    }\n\n    const thisRange = date1.toRange();\n    const otherRange = date2.toRange(); // Start with infinite start and end dates\n\n    let start = null;\n    let end = null; // This start date exists\n\n    if (thisRange.start) {\n      // Use this definite start date if other start date is infinite\n      if (!otherRange.start) {\n        start = thisRange.start;\n      } else {\n        // Otherwise, use the latest start date\n        start = thisRange.start > otherRange.start ? thisRange.start : otherRange.start;\n      } // Other start date exists\n\n    } else if (otherRange.start) {\n      // Use other definite start date as this one is infinite\n      start = otherRange.start;\n    } // This end date exists\n\n\n    if (thisRange.end) {\n      // Use this definite end date if other end date is infinite\n      if (!otherRange.end) {\n        end = thisRange.end;\n      } else {\n        // Otherwise, use the earliest end date\n        end = thisRange.end < otherRange.end ? thisRange.end : otherRange.end;\n      } // Other end date exists\n\n    } else if (otherRange.end) {\n      // Use other definite end date as this one is infinite\n      end = otherRange.end;\n    } // Return calculated range\n\n\n    return {\n      start,\n      end\n    };\n  } // ========================================================\n  // Determines if this date partially intersects another date\n  // NOTE: This is a deep test (patterns tested)\n\n\n  intersectsDate(other) {\n    var _this = this;\n\n    const date = this.toDateInfo(other);\n    if (!this.shallowIntersectsDate(date)) return null;\n    if (!this.on) return this;\n    const range = this.rangeShallowIntersectingRange(this, date);\n    let result = false;\n    this.iterateDatesInRange(range, function (state) {\n      if (_this.matchesDay(state.day)) {\n        result = result || date.matchesDay(state.day);\n        state.finished = result;\n      }\n    });\n    return result;\n  } // ========================================================\n  // Determines if this date partially intersects another date\n  // NOTE: This is a shallow test (no patterns tested)\n\n\n  shallowIntersectsDate(other) {\n    return this.dateShallowIntersectsDate(this, this.toDateInfo(other));\n  } // ========================================================\n  // Determines if first date partially intersects second date\n  // NOTE: This is a shallow test (no patterns tested)\n\n\n  dateShallowIntersectsDate(date1, date2) {\n    if (date1.isDate) {\n      return date2.isDate ? date1.dateTime === date2.dateTime : this.dateShallowIncludesDate(date2, date1);\n    }\n\n    if (date2.isDate) {\n      return this.dateShallowIncludesDate(date1, date2);\n    } // Both ranges\n\n\n    if (date1.start && date2.end && date1.start > date2.end) {\n      return false;\n    }\n\n    if (date1.end && date2.start && date1.end < date2.start) {\n      return false;\n    }\n\n    return true;\n  } // ========================================================\n  // Determines if this date completely includes another date\n  // NOTE: This is a deep test (patterns tested)\n\n\n  includesDate(other) {\n    var _this2 = this;\n\n    const date = this.toDateInfo(other);\n\n    if (!this.shallowIncludesDate(date)) {\n      return false;\n    }\n\n    if (!this.on) {\n      return true;\n    }\n\n    const range = this.rangeShallowIntersectingRange(this, date);\n    let result = true;\n    this.iterateDatesInRange(range, function (state) {\n      if (_this2.matchesDay(state.day)) {\n        result = result && date.matchesDay(state.day);\n        state.finished = !result;\n      }\n    });\n    return result;\n  } // ========================================================\n  // Determines if this date completely includes another date\n  // NOTE: This is a shallow test (no patterns tested)\n\n\n  shallowIncludesDate(other) {\n    return this.dateShallowIncludesDate(this, other.isDate ? other : new dateInfo_DateInfo(other, this.opts));\n  } // ========================================================\n  // Determines if first date completely includes second date\n  // NOTE: This is a shallow test (no patterns tested)\n\n\n  dateShallowIncludesDate(date1, date2) {\n    // First date is simple date\n    if (date1.isDate) {\n      if (date2.isDate) {\n        return date1.dateTime === date2.dateTime;\n      }\n\n      if (!date2.startTime || !date2.endTime) {\n        return false;\n      }\n\n      return date1.dateTime === date2.startTime && date1.dateTime === date2.endTime;\n    } // Second date is simple date and first is date range\n\n\n    if (date2.isDate) {\n      if (date1.start && date2.date < date1.start) {\n        return false;\n      }\n\n      if (date1.end && date2.date > date1.end) {\n        return false;\n      }\n\n      return true;\n    } // Both dates are date ranges\n\n\n    if (date1.start && (!date2.start || date2.start < date1.start)) {\n      return false;\n    }\n\n    if (date1.end && (!date2.end || date2.end > date1.end)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  intersectsDay(day) {\n    // Date is outside general range - return null\n    if (!this.shallowIntersectsDate(day.range)) return null; // Return this date if patterns match\n\n    return this.matchesDay(day) ? this : null;\n  }\n\n  matchesDay(day) {\n    var _this3 = this;\n\n    // No patterns to test\n    if (!this.on) return true; // Fail if 'and' condition fails\n\n    if (this.on.and && !dateInfo_DateInfo.testConfig(this.on.and, day, this)) {\n      return false;\n    } // Fail if every 'or' condition fails\n\n\n    if (this.on.or && !this.on.or.some(function (or) {\n      return dateInfo_DateInfo.testConfig(or, day, _this3);\n    })) {\n      return false;\n    } // Patterns match\n\n\n    return true;\n  }\n\n  toRange() {\n    if (this.isDate) {\n      return new dateInfo_DateInfo({\n        start: this.date,\n        end: this.date\n      }, this.opts);\n    }\n\n    return new dateInfo_DateInfo({\n      start: this.start,\n      end: this.end\n    }, this.opts);\n  } // Build the 'compare to other' function\n\n\n  compare(other) {\n    if (this.order !== other.order) return this.order - other.order;\n    if (this.type !== other.type) return this.isDate ? 1 : -1;\n    if (this.isDate) return 0;\n    const diff = this.start - other.start;\n    return diff !== 0 ? diff : this.end - other.end;\n  }\n\n}\n// CONCATENATED MODULE: ./src/utils/attribute.js\n\n\n\nclass attribute_Attribute {\n  constructor({\n    key,\n    hashcode,\n    highlight,\n    content,\n    dot,\n    bar,\n    popover,\n    dates,\n    excludeDates,\n    excludeMode,\n    customData,\n    order,\n    pinPage\n  }, theme, locale) {\n    var _this = this;\n\n    this.key = isUndefined_default()(key) ? createGuid() : key;\n    this.hashcode = hashcode;\n    this.customData = customData;\n    this.order = order || 0;\n    this.dateOpts = {\n      order,\n      locale\n    };\n    this.pinPage = pinPage; // Normalize attribute types\n\n    if (highlight) {\n      this.highlight = theme.normalizeHighlight(highlight);\n    }\n\n    if (content) {\n      this.content = theme.normalizeContent(content);\n    }\n\n    if (dot) {\n      this.dot = theme.normalizeDot(dot);\n    }\n\n    if (bar) {\n      this.bar = theme.normalizeBar(bar);\n    }\n\n    if (popover) {\n      this.popover = popover;\n    } // Wrap dates in array if needed\n\n\n    if (dates) {\n      this.dates = isArrayLikeObject_default()(dates) ? dates : [dates];\n    }\n\n    this.hasDates = arrayHasItems(this.dates); // Wrap exclude dates in array if needed\n\n    if (excludeDates) {\n      this.excludeDates = isArrayLikeObject_default()(excludeDates) ? excludeDates : [excludeDates];\n    }\n\n    this.hasExcludeDates = arrayHasItems(this.excludeDates);\n    this.excludeMode = excludeMode || 'intersects'; // Assign final dates\n\n    this.dates = (this.hasDates && this.dates || this.hasExcludeDates && [{}] || []).map(function (d) {\n      return d && (d instanceof dateInfo_DateInfo ? d : new dateInfo_DateInfo(d, _this.dateOpts));\n    }).filter(function (d) {\n      return d;\n    }); // Assign final exclude dates\n\n    this.excludeDates = (this.hasExcludeDates && this.excludeDates || []).map(function (d) {\n      return d && (d instanceof dateInfo_DateInfo ? d : new dateInfo_DateInfo(d, _this.dateOpts));\n    }).filter(function (d) {\n      return d;\n    });\n    this.isComplex = _some(this.dates, function (d) {\n      return d.isComplex;\n    });\n  } // Accepts: Date or date range object\n  // Returns: First date that partially intersects the given date\n\n\n  intersectsDate(date) {\n    return !this.excludesDate(date) && (this.dates.find(function (d) {\n      return d.intersectsDate(date);\n    }) || false);\n  } // Accepts: Date or date range object\n  // Returns: First date that completely includes the given date\n\n\n  includesDate(date) {\n    date = date instanceof dateInfo_DateInfo ? date : new dateInfo_DateInfo(date, this.dateOpts);\n    return !this.excludesDate(date) && (this.dates.find(function (d) {\n      return d.includesDate(date);\n    }) || false);\n  }\n\n  excludesDate(date) {\n    var _this2 = this;\n\n    date = date instanceof dateInfo_DateInfo ? date : new dateInfo_DateInfo(date, this.dateOpts);\n    return this.hasExcludeDates && this.excludeDates.find(function (ed) {\n      return _this2.excludeMode === 'intersects' && ed.intersectsDate(date) || _this2.excludeMode === 'includes' && ed.includesDate(date);\n    });\n  } // Accepts: Day object\n  // Returns: First attribute date info that occurs on given day.\n\n\n  intersectsDay(day) {\n    return !this.excludesDay(day) && (this.dates.find(function (d) {\n      return d.intersectsDay(day);\n    }) || false);\n  }\n\n  excludesDay(day) {\n    return this.hasExcludeDates && this.excludeDates.find(function (ed) {\n      return ed.intersectsDay(day);\n    });\n  }\n\n}\n// CONCATENATED MODULE: ./src/utils/mixins/root.js\n\n\n\n\n\n\n\nconst rootMixin = {\n  mixins: [defaultsMixin],\n  props: {\n    color: String,\n    isDark: Boolean,\n    firstDayOfWeek: Number,\n    masks: Object,\n    locale: [String, Object],\n    timezone: String,\n    minDate: null,\n    maxDate: null,\n    disabledDates: null,\n    availableDates: null,\n    theme: null\n  },\n  computed: {\n    $theme() {\n      // Return the theme prop if it is an instance of the Theme class\n      if (this.theme instanceof theme_Theme) return this.theme; // Create the theme\n\n      return new theme_Theme({\n        color: this.passedProp('color', 'blue'),\n        isDark: this.passedProp('isDark', false)\n      });\n    },\n\n    $locale() {\n      // Return the locale prop if it is an instance of the Locale class\n      if (this.locale instanceof locale_Locale) return this.locale; // Build up a base config from component props\n\n      const config = isObject(this.locale) ? this.locale : {\n        id: this.locale,\n        firstDayOfWeek: this.firstDayOfWeek,\n        masks: this.masks\n      }; // Return new locale\n\n      return new locale_Locale(config, this.$locales);\n    },\n\n    disabledAttribute() {\n      // Build up a complete list of disabled dates\n      let dates = []; // Initialize with disabled dates prop, if any\n\n      if (this.disabledDates) {\n        dates = isArrayLikeObject_default()(this.disabledDates) ? this.disabledDates : [this.disabledDates];\n      } // Add disabled dates for minDate and maxDate props\n\n\n      const minDate = this.normalizeDate(this.minDate);\n      const maxDate = this.normalizeDate(this.maxDate);\n\n      if (minDate) {\n        dates.push({\n          start: null,\n          end: addDays(minDate, -1)\n        });\n      }\n\n      if (maxDate) {\n        dates.push({\n          start: addDays(maxDate, 1),\n          end: null\n        });\n      } // Return the new disabled attribute\n\n\n      return new attribute_Attribute({\n        key: 'disabled',\n        dates,\n        excludeDates: this.availableDates,\n        excludeMode: 'includes',\n        order: 100\n      }, this.$theme, this.$locale);\n    }\n\n  },\n\n  created() {\n    setupScreens(this.$defaults.screens);\n  },\n\n  methods: {\n    formatDate(date, mask) {\n      return this.$locale ? this.$locale.format(date, mask) : '';\n    },\n\n    parseDate(text, mask) {\n      if (!this.$locale) return null;\n      const value = this.$locale.parse(text, mask);\n      return _isDate(value) ? value : null;\n    },\n\n    normalizeDate(date, config) {\n      return this.$locale ? this.$locale.normalizeDate(date, config) : date;\n    }\n\n  }\n};\n// CONCATENATED MODULE: ./src/utils/mixins/safeScopedSlot.js\n\nconst safeScopedSlotMixin = {\n  methods: {\n    safeScopedSlot(name, args, def = null) {\n      return isFunction_default()(this.$scopedSlots[name]) ? this.$scopedSlots[name](args) : def;\n    }\n\n  }\n};\n// CONCATENATED MODULE: ./src/utils/mixins/index.js\n\n\n\nconst mixins_childMixin = childMixin;\nconst mixins_rootMixin = rootMixin;\nconst mixins_safeScopedSlotMixin = safeScopedSlotMixin;\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/PopoverRow.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var PopoverRowvue_type_script_lang_js_ = ({\n  name: 'PopoverRow',\n  mixins: [mixins_childMixin],\n  props: {\n    attribute: Object\n  },\n  computed: {\n    indicator() {\n      const {\n        highlight,\n        dot,\n        bar,\n        popover\n      } = this.attribute;\n      if (popover && popover.hideIndicator) return null;\n\n      if (highlight) {\n        const {\n          color,\n          isDark\n        } = highlight.start;\n        return {\n          style: { ...this.theme.bgAccentHigh({\n              color,\n              isDark: !isDark\n            }),\n            width: '10px',\n            height: '5px',\n            borderRadius: '3px'\n          }\n        };\n      }\n\n      if (dot) {\n        const {\n          color,\n          isDark\n        } = dot.start;\n        return {\n          style: { ...this.theme.bgAccentHigh({\n              color,\n              isDark: !isDark\n            }),\n            width: '5px',\n            height: '5px',\n            borderRadius: '50%'\n          }\n        };\n      }\n\n      if (bar) {\n        const {\n          color,\n          isDark\n        } = bar.start;\n        return {\n          style: { ...this.theme.bgAccentHigh({\n              color,\n              isDark: !isDark\n            }),\n            width: '10px',\n            height: '3px'\n          }\n        };\n      }\n\n      return null;\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/PopoverRow.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_PopoverRowvue_type_script_lang_js_ = (PopoverRowvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/PopoverRow.vue?vue&type=style&index=0&id=4975d69e&lang=postcss&scoped=true&\nvar PopoverRowvue_type_style_index_0_id_4975d69e_lang_postcss_scoped_true_ = __webpack_require__(\"2b27\");\n\n// CONCATENATED MODULE: ./src/components/PopoverRow.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar PopoverRow_component = normalizeComponent(\n  components_PopoverRowvue_type_script_lang_js_,\n  PopoverRowvue_type_template_id_4975d69e_scoped_true_render,\n  PopoverRowvue_type_template_id_4975d69e_scoped_true_staticRenderFns,\n  false,\n  null,\n  \"4975d69e\",\n  null\n  \n)\n\n/* harmony default export */ var PopoverRow = (PopoverRow_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Grid.vue?vue&type=script&lang=js&\n\nconst directions = {\n  vLeading: 'vertical-leading',\n  vTrailing: 'vertical-trailing',\n  hLeading: 'horizontal-leading',\n  hTrailing: 'horizontal-trailing'\n};\n/* harmony default export */ var Gridvue_type_script_lang_js_ = ({\n  name: 'Grid',\n\n  render(h) {\n    var _this = this;\n\n    // Grid cell renderer\n    const getCell = function ({\n      nodes,\n      position,\n      row,\n      column\n    }) {\n      // Get the default slot first\n      if (nodes.length >= position) {\n        return nodes[position - 1];\n      } // Get the scoped slot second\n\n\n      if (_this.$scopedSlots.default) {\n        return _this.$scopedSlots.default({\n          position,\n          row,\n          column\n        });\n      }\n\n      return null;\n    }; // Grid cells renderer\n\n\n    const getCells = function () {\n      const cells = []; // Resolve default slot nodes (remove whitespaced)\n\n      const nodes = _this.$slots.default && _this.$slots.default.filter(function (n) {\n        return n.tag !== undefined;\n      }) || []; // Build cells\n\n      for (let r = 1, p = 1; r <= _this.rows; r++) {\n        for (let c = 1; c <= _this.columns; c++) {\n          const rFromEnd = r - _this.rows - 1;\n          const cFromEnd = c - _this.columns - 1; // Add the cell for current row & column\n\n          cells.push(h('div', {\n            class: ['vc-grid-cell', `vc-grid-cell-row-${r}`, `vc-grid-cell-row-${rFromEnd}`, `vc-grid-cell-col-${c}`, `vc-grid-cell-col-${cFromEnd}`],\n            style: {\n              'grid-row': r,\n              'grid-column': c\n            },\n            on: {\n              keydown: function (e) {\n                return _this.handleCellKeydown({\n                  row: r,\n                  column: c,\n                  event: e\n                });\n              }\n            }\n          }, [getCell({\n            nodes,\n            position: p++,\n            row: r,\n            column: c\n          })]));\n        }\n      }\n\n      return cells;\n    };\n\n    return h('div', {\n      class: 'vc-grid-container',\n      style: this.containerStyle\n    }, [...getCells()]);\n  },\n\n  props: {\n    count: Number,\n    rows: {\n      type: Number,\n      default: 1\n    },\n    columns: {\n      type: Number,\n      default: 1\n    },\n    gap: {\n      type: String,\n      default: '0px'\n    },\n    autofit: Boolean,\n    columnWidth: {\n      type: String,\n      default: '1fr'\n    },\n    disableFocus: {\n      type: Boolean,\n      default: false\n    }\n  },\n  computed: {\n    containerStyle() {\n      return {\n        gridTemplateColumns: this.gridTemplateColumns,\n        gridGap: this.gap\n      };\n    },\n\n    gridTemplateColumns() {\n      return `repeat(${this.autofit ? 'auto-fit' : this.columns}, ${this.columnWidth})`;\n    }\n\n  },\n  methods: {\n    handleCellKeydown({\n      row,\n      column,\n      event\n    }) {\n      // Return if focus management is disabled\n      if (this.disableFocus) return;\n      const state = {\n        row,\n        column,\n        alt: false,\n        handled: false\n      }; // Increment row/column based on key\n\n      switch (event.key) {\n        case 'ArrowUp':\n          {\n            state.row--;\n            break;\n          }\n\n        case 'ArrowDown':\n          {\n            state.row++;\n            break;\n          }\n\n        case 'ArrowLeft':\n          {\n            state.column--;\n            break;\n          }\n\n        case 'ArrowRight':\n          {\n            state.column++;\n            break;\n          }\n\n        case 'Home':\n          {\n            state.column = 1;\n            break;\n          }\n\n        case 'End':\n          {\n            state.column = this.columns;\n            break;\n          }\n\n        case 'PageUp':\n          {\n            state.alt = event.altKey;\n            state.direction = directions.vLeading;\n            break;\n          }\n\n        case 'PageDown':\n          {\n            state.alt = event.altKey;\n            state.direction = directions.vTrailing;\n            break;\n          }\n\n        default:\n          {\n            return;\n          }\n      } // Handle state for row rollovers\n\n\n      if (state.row < 1) {\n        state.direction = directions.vLeading;\n        state.row = this.rows;\n      } else if (state.row > this.rows) {\n        state.direction = directions.vTrailing;\n        state.row = 1;\n      } // Handle state for column rollovers\n\n\n      if (state.column < 1) {\n        state.direction = directions.hLeading;\n        state.column = this.columns;\n      } else if (state.column > this.columns) {\n        state.direction = directions.hTrailing;\n        state.column = 1;\n      } // Emit rollover event if direction was assigned\n\n\n      if (state.direction) {\n        this.$emit('rollover', state);\n      } // Focusd on cell for current state if event wasn't handled\n\n\n      if (!state.handled) {\n        // Get grid cell element\n        const cellSelector = `.vc-grid-cell-row-${state.row}.vc-grid-cell-col-${state.column}`;\n        const cellEl = this.$el.querySelector(cellSelector);\n\n        if (cellEl) {\n          this.tryFocus(cellEl);\n        }\n      }\n\n      event.stopPropagation();\n      event.preventDefault();\n    },\n\n    tryFocus(el = this.$el) {\n      this.$nextTick(function () {\n        const selectors = ['.vc-grid-focus', 'button, [href], input, select, textarea, [tabindex=\"0\"]', '[tabindex]:not([tabindex=\"undefined\"])'];\n        const focusableEl = selectors.map(function (s) {\n          return el.querySelector(s);\n        }).find(function (e) {\n          return e;\n        });\n\n        if (focusableEl) {\n          focusableEl.focus();\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/Grid.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_Gridvue_type_script_lang_js_ = (Gridvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/Grid.vue?vue&type=style&index=0&id=5e82e7ed&scoped=true&lang=css&\nvar Gridvue_type_style_index_0_id_5e82e7ed_scoped_true_lang_css_ = __webpack_require__(\"c3ea\");\n\n// CONCATENATED MODULE: ./src/components/Grid.vue\nvar Grid_render, Grid_staticRenderFns\n\n\n\n\n\n/* normalize component */\n\nvar Grid_component = normalizeComponent(\n  components_Gridvue_type_script_lang_js_,\n  Grid_render,\n  Grid_staticRenderFns,\n  false,\n  null,\n  \"5e82e7ed\",\n  null\n  \n)\n\n/* harmony default export */ var Grid = (Grid_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"8773979e-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CalendarNav.vue?vue&type=template&id=6f2cdb11&\nvar CalendarNavvue_type_template_id_6f2cdb11_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"vc-nav-container\"},[_c('grid',{ref:\"headerGrid\",attrs:{\"columns\":3},on:{\"rollover\":_vm.onHeaderRollover}},[_c('span',{ref:\"prevButton\",staticClass:\"vc-nav-arrow is-left\",attrs:{\"role\":\"button\",\"tabindex\":\"-1\"},on:{\"click\":_vm.movePrev,\"keydown\":function (e) { return _vm.onSpaceOrEnter(e, _vm.movePrev); }}},[_vm._t(\"nav-left-button\",[_c('svg-icon',{attrs:{\"name\":\"left-arrow\",\"width\":\"20px\",\"height\":\"24px\"}})])],2),_c('span',{ref:\"titleButton\",staticClass:\"vc-nav-title vc-grid-focus\",style:({ whiteSpace: 'nowrap' }),attrs:{\"role\":\"button\",\"tabindex\":\"0\"},on:{\"click\":_vm.toggleMode,\"keydown\":function (e) { return _vm.onSpaceOrEnter(e, _vm.toggleMode); }}},[_vm._v(\" \"+_vm._s(_vm.title)+\" \")]),_c('span',{ref:\"nextButton\",staticClass:\"vc-nav-arrow is-right\",attrs:{\"role\":\"button\",\"tabindex\":\"-1\"},on:{\"click\":_vm.moveNext,\"keydown\":function (e) { return _vm.onSpaceOrEnter(e, _vm.moveNext); }}},[_vm._t(\"nav-right-button\",[_c('svg-icon',{attrs:{\"name\":\"right-arrow\",\"width\":\"20px\",\"height\":\"24px\"}})])],2)]),_c('grid',{ref:\"itemsGrid\",attrs:{\"rows\":4,\"columns\":3,\"gap\":\"2px 5px\"},on:{\"rollover\":_vm.onItemsRollover}},_vm._l((_vm.activeItems),function(item){return _c('span',{key:item.label,ref:\"items\",refInFor:true,class:_vm.getItemClasses(item),attrs:{\"role\":\"button\",\"aria-label\":item.ariaLabel,\"tabindex\":item.isDisabled ? undefined : item.isActive ? 0 : -1},on:{\"click\":item.click,\"keydown\":function (e) { return _vm.onSpaceOrEnter(e, item.click); }}},[_vm._v(\" \"+_vm._s(item.label)+\" \")])}),0)],1)}\nvar CalendarNavvue_type_template_id_6f2cdb11_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/CalendarNav.vue?vue&type=template&id=6f2cdb11&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"8773979e-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/SvgIcon.vue?vue&type=template&id=19b6cf78&scoped=true&\nvar SvgIconvue_type_template_id_19b6cf78_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('svg',_vm._g({staticClass:\"vc-svg-icon\",attrs:{\"width\":_vm.width,\"height\":_vm.height,\"viewBox\":_vm.viewBox}},_vm.$listeners),[_c('path',{attrs:{\"d\":_vm.path}})])}\nvar SvgIconvue_type_template_id_19b6cf78_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/SvgIcon.vue?vue&type=template&id=19b6cf78&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/SvgIcon.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nconst _defSize = '26px';\nconst _defViewBox = '0 0 32 32';\nconst icons = {\n  'left-arrow': {\n    viewBox: '0 -1 16 34',\n    path: 'M11.196 10c0 0.143-0.071 0.304-0.179 0.411l-7.018 7.018 7.018 7.018c0.107 0.107 0.179 0.268 0.179 0.411s-0.071 0.304-0.179 0.411l-0.893 0.893c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-8.321-8.321c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l8.321-8.321c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l0.893 0.893c0.107 0.107 0.179 0.25 0.179 0.411z'\n  },\n  'right-arrow': {\n    viewBox: '-5 -1 16 34',\n    path: 'M10.625 17.429c0 0.143-0.071 0.304-0.179 0.411l-8.321 8.321c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-0.893-0.893c-0.107-0.107-0.179-0.25-0.179-0.411 0-0.143 0.071-0.304 0.179-0.411l7.018-7.018-7.018-7.018c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l0.893-0.893c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l8.321 8.321c0.107 0.107 0.179 0.268 0.179 0.411z'\n  }\n};\n/* harmony default export */ var SvgIconvue_type_script_lang_js_ = ({\n  props: ['name'],\n\n  data() {\n    return {\n      width: _defSize,\n      height: _defSize,\n      viewBox: _defViewBox,\n      path: '',\n      isBaseline: false\n    };\n  },\n\n  mounted() {\n    this.updateIcon();\n  },\n\n  watch: {\n    name() {\n      this.updateIcon();\n    }\n\n  },\n  methods: {\n    updateIcon() {\n      const icon = icons[this.name];\n\n      if (icon) {\n        this.width = icon.width || _defSize;\n        this.height = icon.height || _defSize;\n        this.viewBox = icon.viewBox;\n        this.path = icon.path;\n      }\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/SvgIcon.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_SvgIconvue_type_script_lang_js_ = (SvgIconvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/SvgIcon.vue?vue&type=style&index=0&id=19b6cf78&lang=postcss&scoped=true&\nvar SvgIconvue_type_style_index_0_id_19b6cf78_lang_postcss_scoped_true_ = __webpack_require__(\"cc2e\");\n\n// CONCATENATED MODULE: ./src/components/SvgIcon.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar SvgIcon_component = normalizeComponent(\n  components_SvgIconvue_type_script_lang_js_,\n  SvgIconvue_type_template_id_19b6cf78_scoped_true_render,\n  SvgIconvue_type_template_id_19b6cf78_scoped_true_staticRenderFns,\n  false,\n  null,\n  \"19b6cf78\",\n  null\n  \n)\n\n/* harmony default export */ var SvgIcon = (SvgIcon_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CalendarNav.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\nconst _yearGroupCount = 12;\n/* harmony default export */ var CalendarNavvue_type_script_lang_js_ = ({\n  name: 'CalendarNav',\n  components: {\n    Grid: Grid,\n    SvgIcon: SvgIcon\n  },\n  mixins: [mixins_childMixin],\n  props: {\n    value: {\n      type: Object,\n      default: function () {\n        return {\n          month: 0,\n          year: 0\n        };\n      }\n    },\n    validator: {\n      type: Function,\n      default: function () {\n        return function () {\n          return true;\n        };\n      }\n    }\n  },\n\n  data() {\n    return {\n      monthMode: true,\n      yearIndex: 0,\n      yearGroupIndex: 0,\n      onSpaceOrEnter: onSpaceOrEnter\n    };\n  },\n\n  computed: {\n    month() {\n      return this.value ? this.value.month || 0 : 0;\n    },\n\n    year() {\n      return this.value ? this.value.year || 0 : 0;\n    },\n\n    title() {\n      return this.monthMode ? this.yearIndex : `${this.firstYear} - ${this.lastYear}`;\n    },\n\n    monthItems() {\n      var _this = this;\n\n      const {\n        month: thisMonth,\n        year: thisYear\n      } = pageForDate(new Date());\n      return this.locale.getMonthDates().map(function (d, i) {\n        const month = i + 1;\n        return {\n          label: _this.locale.format(d, _this.masks.navMonths),\n          ariaLabel: _this.locale.format(d, 'MMMM YYYY'),\n          isActive: month === _this.month && _this.yearIndex === _this.year,\n          isCurrent: month === thisMonth && _this.yearIndex === thisYear,\n          isDisabled: !_this.validator({\n            month,\n            year: _this.yearIndex\n          }),\n          click: function () {\n            return _this.monthClick(month);\n          }\n        };\n      });\n    },\n\n    yearItems() {\n      var _this2 = this;\n\n      const {\n        _,\n        year: thisYear\n      } = pageForDate(new Date());\n      const startYear = this.yearGroupIndex * _yearGroupCount;\n      const endYear = startYear + _yearGroupCount;\n      const items = [];\n\n      for (let year = startYear; year < endYear; year += 1) {\n        items.push({\n          year,\n          label: year,\n          ariaLabel: year,\n          isActive: year === this.year,\n          isCurrent: year === thisYear,\n          isDisabled: !this.validator({\n            month: this.month,\n            year\n          }),\n          click: function () {\n            return _this2.yearClick(year);\n          }\n        });\n      }\n\n      return items;\n    },\n\n    activeItems() {\n      return this.monthMode ? this.monthItems : this.yearItems;\n    },\n\n    firstYear() {\n      return head_default()(this.yearItems.map(function (i) {\n        return i.year;\n      }));\n    },\n\n    lastYear() {\n      return last_default()(this.yearItems.map(function (i) {\n        return i.year;\n      }));\n    }\n\n  },\n  watch: {\n    year() {\n      this.yearIndex = this.year;\n    },\n\n    yearIndex(val) {\n      this.yearGroupIndex = this.getYearGroupIndex(val);\n    }\n\n  },\n\n  created() {\n    this.yearIndex = this.year;\n  },\n\n  mounted() {\n    this.$refs.itemsGrid.tryFocus();\n  },\n\n  methods: {\n    getItemClasses({\n      isActive,\n      isCurrent,\n      isDisabled\n    }) {\n      const classes = ['vc-nav-item'];\n\n      if (isActive) {\n        classes.push('is-active', 'vc-grid-focus');\n      } else if (isCurrent) {\n        classes.push('is-inactive-current');\n      } else {\n        classes.push('is-inactive');\n      }\n\n      if (isDisabled) {\n        classes.push('is-disabled');\n      }\n\n      return classes;\n    },\n\n    getYearGroupIndex(year) {\n      return Math.floor(year / _yearGroupCount);\n    },\n\n    monthClick(month) {\n      this.$emit('input', {\n        month,\n        year: this.yearIndex\n      });\n    },\n\n    yearClick(year) {\n      this.yearIndex = year;\n      this.monthMode = true;\n      this.$refs.itemsGrid.tryFocus();\n    },\n\n    toggleMode() {\n      this.monthMode = !this.monthMode;\n    },\n\n    movePrev() {\n      if (this.monthMode) {\n        this.movePrevYear();\n      }\n\n      this.movePrevYearGroup();\n    },\n\n    moveNext() {\n      if (this.monthMode) {\n        this.moveNextYear();\n      }\n\n      this.moveNextYearGroup();\n    },\n\n    movePrevYear() {\n      this.yearIndex--;\n    },\n\n    moveNextYear() {\n      this.yearIndex++;\n    },\n\n    movePrevYearGroup() {\n      this.yearGroupIndex--;\n    },\n\n    moveNextYearGroup() {\n      this.yearGroupIndex++;\n    },\n\n    onHeaderRollover(e) {\n      switch (e.direction) {\n        case 'vertical-trailing':\n          this.$refs.itemsGrid.tryFocus();\n          break;\n      }\n\n      e.handled = true;\n    },\n\n    onItemsRollover(e) {\n      switch (e.direction) {\n        case 'horizontal-leading':\n          {\n            this.movePrev();\n            break;\n          }\n\n        case 'horizontal-trailing':\n          {\n            this.moveNext();\n            break;\n          }\n\n        case 'vertical-leading':\n          {\n            this.$refs.headerGrid.tryFocus();\n            e.handled = true;\n            break;\n          }\n\n        case 'vertical-trailing':\n          {\n            e.handled = true;\n            break;\n          }\n      }\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/CalendarNav.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_CalendarNavvue_type_script_lang_js_ = (CalendarNavvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/CalendarNav.vue?vue&type=style&index=0&lang=postcss&\nvar CalendarNavvue_type_style_index_0_lang_postcss_ = __webpack_require__(\"3c55\");\n\n// CONCATENATED MODULE: ./src/components/CalendarNav.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar CalendarNav_component = normalizeComponent(\n  components_CalendarNavvue_type_script_lang_js_,\n  CalendarNavvue_type_template_id_6f2cdb11_render,\n  CalendarNavvue_type_template_id_6f2cdb11_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var CalendarNav = (CalendarNav_component.exports);\n// CONCATENATED MODULE: ./src/utils/popovers.js\n\nfunction popovers_showPopover(opts) {\n  if (document) {\n    document.dispatchEvent(new CustomEvent('show-popover', {\n      detail: opts\n    }));\n  }\n}\nfunction popovers_hidePopover(opts) {\n  if (document) {\n    document.dispatchEvent(new CustomEvent('hide-popover', {\n      detail: opts\n    }));\n  }\n}\nfunction popovers_togglePopover(opts) {\n  if (document) {\n    document.dispatchEvent(new CustomEvent('toggle-popover', {\n      detail: opts\n    }));\n  }\n}\nfunction updatePopover(opts) {\n  if (document) {\n    document.dispatchEvent(new CustomEvent('update-popover', {\n      detail: opts\n    }));\n  }\n}\nfunction getPopoverTriggerEvents(opts) {\n  const {\n    visibility\n  } = opts;\n  const click = visibility === 'click';\n  const hover = visibility === 'hover';\n  const hoverFocus = visibility === 'hover-focus';\n  const focus = visibility === 'focus';\n  opts.autoHide = !click;\n  let hovered = false;\n  let focused = false;\n  return {\n    click(e) {\n      if (click) {\n        opts.ref = e.target;\n        popovers_togglePopover(opts);\n        e.stopPropagation();\n      }\n    },\n\n    mousemove(e) {\n      opts.ref = e.currentTarget;\n\n      if (!hovered) {\n        hovered = true;\n\n        if (hover || hoverFocus) {\n          popovers_showPopover(opts);\n        }\n      }\n    },\n\n    mouseleave(e) {\n      opts.ref = e.target;\n\n      if (hovered) {\n        hovered = false;\n\n        if (hover || hoverFocus && !focused) {\n          popovers_hidePopover(opts);\n        }\n      }\n    },\n\n    focusin(e) {\n      opts.ref = e.currentTarget;\n\n      if (!focused) {\n        focused = true;\n\n        if (focus || hoverFocus) {\n          popovers_showPopover(opts);\n        }\n      }\n    },\n\n    focusout(e) {\n      opts.ref = e.currentTarget;\n\n      if (focused && !elementContains(opts.ref, e.relatedTarget)) {\n        focused = false;\n\n        if (focus || hoverFocus && !hovered) {\n          popovers_hidePopover(opts);\n        }\n      }\n    }\n\n  };\n}\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CalendarDay.vue?vue&type=script&lang=js&\n\n\n\n\n\n/* harmony default export */ var CalendarDayvue_type_script_lang_js_ = ({\n  name: 'CalendarDay',\n  mixins: [mixins_childMixin, mixins_safeScopedSlotMixin],\n\n  render(h) {\n    var _this = this;\n\n    // Backgrounds layer\n    const backgroundsLayer = function () {\n      return _this.hasBackgrounds && h('div', {\n        class: 'vc-highlights vc-day-layer'\n      }, _this.backgrounds.map(function ({\n        key,\n        wrapperClass,\n        class: bgClass,\n        style\n      }) {\n        return h('div', {\n          key,\n          class: wrapperClass\n        }, [h('div', {\n          class: bgClass,\n          style\n        })]);\n      }));\n    }; // Content layer\n\n\n    const contentLayer = function () {\n      return _this.safeScopedSlot('day-content', {\n        day: _this.day,\n        attributes: _this.day.attributes,\n        attributesMap: _this.day.attributesMap,\n        dayProps: _this.dayContentProps,\n        dayEvents: _this.dayContentEvents\n      }) || h('span', {\n        class: _this.dayContentClass,\n        style: _this.dayContentStyle,\n        attrs: { ..._this.dayContentProps\n        },\n        on: _this.dayContentEvents,\n        ref: 'content'\n      }, [_this.day.label]);\n    }; // Dots layer\n\n\n    const dotsLayer = function () {\n      return _this.hasDots && h('div', {\n        class: 'vc-day-layer vc-day-box-center-bottom'\n      }, [h('div', {\n        class: 'vc-dots'\n      }, _this.dots.map(function ({\n        key,\n        class: bgClass,\n        style\n      }) {\n        return h('span', {\n          key,\n          class: bgClass,\n          style\n        });\n      }))]);\n    }; // Bars layer\n\n\n    const barsLayer = function () {\n      return _this.hasBars && h('div', {\n        class: 'vc-day-layer vc-day-box-center-bottom'\n      }, [h('div', {\n        class: 'vc-bars'\n      }, _this.bars.map(function ({\n        key,\n        class: bgClass,\n        style\n      }) {\n        return h('span', {\n          key,\n          class: bgClass,\n          style\n        });\n      }))]);\n    }; // Root layer\n\n\n    return h('div', {\n      class: ['vc-day', ...this.day.classes, {\n        'vc-day-box-center-center': !this.$scopedSlots['day-content']\n      }, {\n        'is-not-in-month': !this.inMonth\n      }]\n    }, [backgroundsLayer(), contentLayer(), dotsLayer(), barsLayer()]);\n  },\n\n  inject: ['sharedState'],\n  props: {\n    day: {\n      type: Object,\n      required: true\n    }\n  },\n\n  data() {\n    return {\n      glyphs: {},\n      dayContentEvents: {}\n    };\n  },\n\n  computed: {\n    label() {\n      return this.day.label;\n    },\n\n    startTime() {\n      return this.day.range.start.getTime();\n    },\n\n    endTime() {\n      return this.day.range.end.getTime();\n    },\n\n    inMonth() {\n      return this.day.inMonth;\n    },\n\n    isDisabled() {\n      return this.day.isDisabled;\n    },\n\n    backgrounds() {\n      return this.glyphs.backgrounds;\n    },\n\n    hasBackgrounds() {\n      return !!arrayHasItems(this.backgrounds);\n    },\n\n    content() {\n      return this.glyphs.content;\n    },\n\n    dots() {\n      return this.glyphs.dots;\n    },\n\n    hasDots() {\n      return !!arrayHasItems(this.dots);\n    },\n\n    bars() {\n      return this.glyphs.bars;\n    },\n\n    hasBars() {\n      return !!arrayHasItems(this.bars);\n    },\n\n    popovers() {\n      return this.glyphs.popovers;\n    },\n\n    hasPopovers() {\n      return !!arrayHasItems(this.popovers);\n    },\n\n    dayContentClass() {\n      return ['vc-day-content vc-focusable', {\n        'is-disabled': this.isDisabled\n      }, get_default()(last_default()(this.content), 'class') || ''];\n    },\n\n    dayContentStyle() {\n      return get_default()(last_default()(this.content), 'style');\n    },\n\n    dayContentProps() {\n      let tabindex;\n\n      if (this.day.isFocusable) {\n        tabindex = '0';\n      } else if (this.day.inMonth) {\n        tabindex = '-1';\n      }\n\n      return {\n        tabindex,\n        'aria-label': this.day.ariaLabel,\n        'aria-disabled': this.day.isDisabled ? 'true' : 'false',\n        role: 'button'\n      };\n    },\n\n    dayEvent() {\n      return { ...this.day,\n        el: this.$refs.content,\n        popovers: this.popovers\n      };\n    }\n\n  },\n  watch: {\n    theme() {\n      this.refresh();\n    },\n\n    popovers() {\n      this.refreshPopovers();\n    }\n\n  },\n\n  mounted() {\n    this.refreshPopovers();\n  },\n\n  methods: {\n    getDayEvent(origEvent) {\n      return { ...this.dayEvent,\n        event: origEvent\n      };\n    },\n\n    click(e) {\n      this.$emit('dayclick', this.getDayEvent(e));\n    },\n\n    mouseenter(e) {\n      this.$emit('daymouseenter', this.getDayEvent(e));\n    },\n\n    mouseleave(e) {\n      this.$emit('daymouseleave', this.getDayEvent(e));\n    },\n\n    focusin(e) {\n      this.$emit('dayfocusin', this.getDayEvent(e));\n    },\n\n    focusout(e) {\n      this.$emit('dayfocusout', this.getDayEvent(e));\n    },\n\n    keydown(e) {\n      this.$emit('daykeydown', this.getDayEvent(e));\n    },\n\n    refresh() {\n      var _this2 = this;\n\n      if (!this.day.refresh) return;\n      this.day.refresh = false;\n      const glyphs = {\n        backgrounds: [],\n        dots: [],\n        bars: [],\n        popovers: [],\n        content: []\n      }; // Use $set to trigger reactivity in popovers, if needed\n\n      this.$set(this.day, 'attributes', Object.values(this.day.attributesMap || {}).sort(function (a, b) {\n        return a.order - b.order;\n      }));\n      this.day.attributes.forEach(function (attr) {\n        // Add glyphs for each attribute\n        const {\n          targetDate\n        } = attr;\n        const {\n          isDate,\n          isComplex,\n          startTime,\n          endTime\n        } = targetDate;\n        const onStart = _this2.startTime <= startTime;\n        const onEnd = _this2.endTime >= endTime;\n        const onStartAndEnd = onStart && onEnd;\n        const onStartOrEnd = onStart || onEnd;\n        const dateInfo = {\n          isDate,\n          isComplex,\n          onStart,\n          onEnd,\n          onStartAndEnd,\n          onStartOrEnd\n        };\n\n        _this2.processHighlight(attr, dateInfo, glyphs);\n\n        _this2.processNonHighlight(attr, 'content', dateInfo, glyphs.content);\n\n        _this2.processNonHighlight(attr, 'dot', dateInfo, glyphs.dots);\n\n        _this2.processNonHighlight(attr, 'bar', dateInfo, glyphs.bars);\n\n        _this2.processPopover(attr, glyphs);\n      });\n      this.glyphs = glyphs;\n    },\n\n    processHighlight({\n      key,\n      highlight\n    }, {\n      isDate,\n      isComplex,\n      onStart,\n      onEnd,\n      onStartAndEnd\n    }, {\n      backgrounds,\n      content\n    }) {\n      if (!highlight) return;\n      const {\n        base,\n        start,\n        end\n      } = highlight;\n\n      if (isDate || isComplex) {\n        backgrounds.push({\n          key,\n          wrapperClass: 'vc-day-layer vc-day-box-center-center',\n          class: ['vc-highlight', start.class],\n          style: start.style\n        });\n        content.push({\n          key: `${key}-content`,\n          class: start.contentClass,\n          style: start.contentStyle\n        });\n      } else if (onStartAndEnd) {\n        backgrounds.push({\n          key,\n          wrapperClass: 'vc-day-layer vc-day-box-center-center',\n          class: ['vc-highlight', start.class],\n          style: start.style\n        });\n        content.push({\n          key: `${key}-content`,\n          class: start.contentClass,\n          style: start.contentStyle\n        });\n      } else if (onStart) {\n        backgrounds.push({\n          key: `${key}-base`,\n          wrapperClass: 'vc-day-layer vc-day-box-right-center',\n          class: ['vc-highlight vc-highlight-base-start', base.class],\n          style: base.style\n        });\n        backgrounds.push({\n          key,\n          wrapperClass: 'vc-day-layer vc-day-box-center-center',\n          class: ['vc-highlight', start.class],\n          style: start.style\n        });\n        content.push({\n          key: `${key}-content`,\n          class: start.contentClass,\n          style: start.contentStyle\n        });\n      } else if (onEnd) {\n        backgrounds.push({\n          key: `${key}-base`,\n          wrapperClass: 'vc-day-layer vc-day-box-left-center',\n          class: ['vc-highlight vc-highlight-base-end', base.class],\n          style: base.style\n        });\n        backgrounds.push({\n          key,\n          wrapperClass: 'vc-day-layer vc-day-box-center-center',\n          class: ['vc-highlight', end.class],\n          style: end.style\n        });\n        content.push({\n          key: `${key}-content`,\n          class: end.contentClass,\n          style: end.contentStyle\n        });\n      } else {\n        backgrounds.push({\n          key: `${key}-middle`,\n          wrapperClass: 'vc-day-layer vc-day-box-center-center',\n          class: ['vc-highlight vc-highlight-base-middle', base.class],\n          style: base.style\n        });\n        content.push({\n          key: `${key}-content`,\n          class: base.contentClass,\n          style: base.contentStyle\n        });\n      }\n    },\n\n    processNonHighlight(attr, itemKey, {\n      isDate,\n      onStart,\n      onEnd\n    }, list) {\n      if (!attr[itemKey]) return;\n      const {\n        key\n      } = attr;\n      const className = `vc-${itemKey}`;\n      const {\n        base,\n        start,\n        end\n      } = attr[itemKey];\n\n      if (isDate || onStart) {\n        list.push({\n          key,\n          class: [className, start.class],\n          style: start.style\n        });\n      } else if (onEnd) {\n        list.push({\n          key,\n          class: [className, end.class],\n          style: end.style\n        });\n      } else {\n        list.push({\n          key,\n          class: [className, base.class],\n          style: base.style\n        });\n      }\n    },\n\n    processPopover(attribute, {\n      popovers\n    }) {\n      const {\n        key,\n        customData,\n        popover\n      } = attribute;\n      if (!popover) return;\n      const resolvedPopover = defaults_default()({\n        key,\n        customData,\n        attribute\n      }, { ...popover\n      }, {\n        visibility: popover.label ? 'hover' : 'click',\n        placement: 'bottom',\n        isInteractive: !popover.label\n      });\n      popovers.splice(0, 0, resolvedPopover);\n    },\n\n    refreshPopovers() {\n      let popoverEvents = {};\n\n      if (this.popovers) {\n        const visibilities = ['click', 'focus', 'hover', 'visible'];\n        let placement = '';\n        let modifiers = null;\n        let isInteractive = false;\n        let vIdx = -1;\n        this.popovers.forEach(function (p) {\n          const vNew = visibilities.indexOf(p.visibility);\n          vIdx = vNew > vIdx ? vNew : vIdx;\n          placement = placement || p.placement;\n          modifiers = modifiers || p.modifiers;\n          isInteractive = isInteractive || p.isInteractive;\n        });\n        popoverEvents = getPopoverTriggerEvents({\n          id: this.dayPopoverId,\n          data: this.day,\n          visibility: vIdx >= 0 ? visibilities[vIdx] : 'hidden',\n          placement: placement || 'bottom',\n          modifiers,\n          isInteractive\n        });\n      }\n\n      this.dayContentEvents = mergeEvents({\n        click: this.click,\n        mouseenter: this.mouseenter,\n        mouseleave: this.mouseleave,\n        focusin: this.focusin,\n        focusout: this.focusout,\n        keydown: this.keydown\n      }, popoverEvents);\n      updatePopover({\n        id: this.dayPopoverId,\n        data: this.day\n      });\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/CalendarDay.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_CalendarDayvue_type_script_lang_js_ = (CalendarDayvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/CalendarDay.vue?vue&type=style&index=0&id=a1110b40&lang=postcss&scoped=true&\nvar CalendarDayvue_type_style_index_0_id_a1110b40_lang_postcss_scoped_true_ = __webpack_require__(\"38ea\");\n\n// CONCATENATED MODULE: ./src/components/CalendarDay.vue\nvar CalendarDay_render, CalendarDay_staticRenderFns\n\n\n\n\n\n/* normalize component */\n\nvar CalendarDay_component = normalizeComponent(\n  components_CalendarDayvue_type_script_lang_js_,\n  CalendarDay_render,\n  CalendarDay_staticRenderFns,\n  false,\n  null,\n  \"a1110b40\",\n  null\n  \n)\n\n/* harmony default export */ var CalendarDay = (CalendarDay_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CalendarPane.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n/* harmony default export */ var CalendarPanevue_type_script_lang_js_ = ({\n  name: 'CalendarPane',\n  mixins: [mixins_childMixin, mixins_safeScopedSlotMixin],\n\n  render(h) {\n    var _this = this;\n\n    // Header\n    const header = this.safeScopedSlot('header', this.page) || h('div', {\n      class: 'vc-header'\n    }, [// Header title\n    h('div', {\n      class: `vc-title-layout align-${this.titlePosition}`\n    }, [h('div', {\n      class: 'vc-title-wrapper'\n    }, [// Title content\n    h('div', {\n      class: 'vc-title',\n      on: this.navPopoverEvents\n    }, [this.safeScopedSlot('header-title', this.page, this.page.title)]), // Navigation popover\n    h(Popover, {\n      props: {\n        id: this.navPopoverId,\n        contentClass: 'vc-nav-popover-container'\n      }\n    }, [// Navigation pane\n    h(CalendarNav, {\n      props: {\n        value: this.page,\n        validator: this.canMove\n      },\n      on: {\n        input: function ($event) {\n          return _this.move($event);\n        }\n      },\n      scopedSlots: this.$scopedSlots\n    })])])])]); // Weeks\n\n    const weeks = h(Grid, {\n      class: 'vc-weeks',\n      props: {\n        rows: 7,\n        columns: 7,\n        columnWidth: '1fr',\n        disableFocus: true\n      }\n    }, [...this.weekdayLabels.map(function (wl, i) {\n      return h('div', {\n        key: i + 1,\n        class: 'vc-weekday'\n      }, [wl]);\n    }), ...this.page.days.map(function (day) {\n      return h(CalendarDay, {\n        attrs: { ..._this.$attrs,\n          day\n        },\n        on: { ..._this.$listeners\n        },\n        scopedSlots: _this.$scopedSlots,\n        key: day.id,\n        ref: 'days',\n        refInFor: true\n      });\n    })]);\n    return h('div', {\n      class: 'vc-pane',\n      ref: 'pane'\n    }, [header, weeks]);\n  },\n\n  props: {\n    page: Object,\n    titlePosition: String,\n    navVisibility: String,\n    canMove: {\n      type: Function,\n      default: function () {\n        return true;\n      }\n    }\n  },\n\n  data() {\n    return {\n      navPopoverId: createGuid()\n    };\n  },\n\n  computed: {\n    navVisibility_() {\n      return this.propOrDefault('navVisibility', 'navVisibility');\n    },\n\n    navPlacement() {\n      switch (this.titlePosition) {\n        case 'left':\n          return 'bottom-start';\n\n        case 'right':\n          return 'bottom-end';\n\n        default:\n          return 'bottom';\n      }\n    },\n\n    navPopoverEvents() {\n      return getPopoverTriggerEvents({\n        id: this.navPopoverId,\n        visibility: this.navVisibility_,\n        placement: this.navPlacement,\n        modifiers: [{\n          name: 'flip',\n          options: {\n            fallbackPlacements: ['bottom']\n          }\n        }],\n        isInteractive: true\n      });\n    },\n\n    weekdayLabels() {\n      var _this2 = this;\n\n      return this.locale.getWeekdayDates().map(function (d) {\n        return _this2.format(d, _this2.masks.weekdays);\n      });\n    }\n\n  },\n  methods: {\n    move(page) {\n      this.$emit('update:page', page);\n    },\n\n    refresh() {\n      this.$refs.days.forEach(function (d) {\n        return d.refresh();\n      });\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/CalendarPane.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_CalendarPanevue_type_script_lang_js_ = (CalendarPanevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/CalendarPane.vue?vue&type=style&index=0&id=3491b290&lang=postcss&scoped=true&\nvar CalendarPanevue_type_style_index_0_id_3491b290_lang_postcss_scoped_true_ = __webpack_require__(\"bab4\");\n\n// EXTERNAL MODULE: ./src/components/CalendarPane.vue?vue&type=style&index=1&lang=css&\nvar CalendarPanevue_type_style_index_1_lang_css_ = __webpack_require__(\"4889\");\n\n// CONCATENATED MODULE: ./src/components/CalendarPane.vue\nvar CalendarPane_render, CalendarPane_staticRenderFns\n\n\n\n\n\n\n/* normalize component */\n\nvar CalendarPane_component = normalizeComponent(\n  components_CalendarPanevue_type_script_lang_js_,\n  CalendarPane_render,\n  CalendarPane_staticRenderFns,\n  false,\n  null,\n  \"3491b290\",\n  null\n  \n)\n\n/* harmony default export */ var CalendarPane = (CalendarPane_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CustomTransition.vue?vue&type=script&lang=js&\n/* harmony default export */ var CustomTransitionvue_type_script_lang_js_ = ({\n  name: 'CustomTransition',\n\n  render(h) {\n    return h('transition', {\n      props: {\n        name: this.name_,\n        appear: this.appear\n      },\n      on: {\n        beforeEnter: this.beforeEnter,\n        afterEnter: this.afterEnter\n      }\n    }, [this.$slots.default]);\n  },\n\n  props: {\n    name: String,\n    appear: Boolean\n  },\n  computed: {\n    name_() {\n      return this.name || 'none';\n    }\n\n  },\n  methods: {\n    beforeEnter(el) {\n      this.$emit('beforeEnter', el);\n      this.$emit('beforeTransition', el);\n    },\n\n    afterEnter(el) {\n      this.$emit('afterEnter', el);\n      this.$emit('afterTransition', el);\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/CustomTransition.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_CustomTransitionvue_type_script_lang_js_ = (CustomTransitionvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/CustomTransition.vue?vue&type=style&index=0&id=8466592e&lang=postcss&scoped=true&\nvar CustomTransitionvue_type_style_index_0_id_8466592e_lang_postcss_scoped_true_ = __webpack_require__(\"e76f\");\n\n// CONCATENATED MODULE: ./src/components/CustomTransition.vue\nvar CustomTransition_render, CustomTransition_staticRenderFns\n\n\n\n\n\n/* normalize component */\n\nvar CustomTransition_component = normalizeComponent(\n  components_CustomTransitionvue_type_script_lang_js_,\n  CustomTransition_render,\n  CustomTransition_staticRenderFns,\n  false,\n  null,\n  \"8466592e\",\n  null\n  \n)\n\n/* harmony default export */ var CustomTransition = (CustomTransition_component.exports);\n// CONCATENATED MODULE: ./src/utils/attributeStore.js\n\n\n\nclass attributeStore_AttributeStore {\n  constructor(theme, locale, attrs) {\n    this.theme = theme;\n    this.locale = locale;\n    this.map = {};\n    this.refresh(attrs, true);\n  }\n\n  refresh(attrs, reset) {\n    var _this = this;\n\n    const map = {};\n    const list = [];\n    let pinAttr = null; // Keep record of added and deleted attributes\n\n    const adds = [];\n    const deletes = reset ? new Set() : new Set(Object.keys(this.map));\n\n    if (arrayHasItems(attrs)) {\n      attrs.forEach(function (attr, i) {\n        if (!attr || !attr.dates) return;\n        const key = attr.key ? attr.key.toString() : i.toString();\n        const order = attr.order || 0;\n        const hashcode = helpers_hash(JSON.stringify(attr));\n        let exAttr = _this.map[key]; // If just tracking delta changes and attribute hash hasn't changed\n\n        if (!reset && exAttr && exAttr.hashcode === hashcode) {\n          // ...don't need to replace the attribute\n          deletes.delete(key);\n        } else {\n          // Otherwise, create attribute and add to the list of adds\n          exAttr = new attribute_Attribute({\n            key,\n            order,\n            hashcode,\n            ...attr\n          }, _this.theme, _this.locale);\n          adds.push(exAttr);\n        } // Keep track of attribute to pin for initial page\n\n\n        if (exAttr && exAttr.pinPage) {\n          pinAttr = exAttr;\n        } // Add attribute to map and list\n\n\n        map[key] = exAttr;\n        list.push(exAttr);\n      });\n    }\n\n    this.map = map;\n    this.list = list;\n    this.pinAttr = pinAttr;\n    return {\n      adds,\n      deletes: Array.from(deletes)\n    };\n  }\n\n}\n// EXTERNAL MODULE: ./src/styles/base.css\nvar base = __webpack_require__(\"3ee2\");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Calendar.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var Calendarvue_type_script_lang_js_ = ({\n  name: 'Calendar',\n\n  render(h) {\n    var _this = this;\n\n    // Renderer for calendar panes\n    const panes = this.pages.map(function (page, i) {\n      return h(CalendarPane, {\n        attrs: { ..._this.$attrs,\n          attributes: _this.store\n        },\n        props: {\n          titlePosition: _this.titlePosition_,\n          page,\n          minPage: _this.minPage_,\n          maxPage: _this.maxPage_,\n          canMove: _this.canMove\n        },\n        on: { ..._this.$listeners,\n          'update:page': function (e) {\n            return _this.refreshPages({\n              page: e,\n              position: i + 1\n            });\n          },\n          dayfocusin: function (e) {\n            _this.lastFocusedDay = e;\n\n            _this.$emit('dayfocusin', e);\n          },\n          dayfocusout: function (e) {\n            _this.lastFocusedDay = null;\n\n            _this.$emit('dayfocusout', e);\n          }\n        },\n        scopedSlots: _this.$scopedSlots,\n        key: page.key,\n        ref: 'pages',\n        refInFor: true\n      });\n    }); // Renderer for calendar arrows\n\n    const getArrowButton = function (isPrev) {\n      const click = function () {\n        return _this.move(isPrev ? -_this.step_ : _this.step_);\n      };\n\n      const keydown = function (e) {\n        return onSpaceOrEnter(e, click);\n      };\n\n      const isDisabled = isPrev ? !_this.canMovePrev : !_this.canMoveNext;\n      return h('div', {\n        class: ['vc-arrow', {\n          'is-disabled': isDisabled\n        }],\n        attrs: {\n          role: 'button'\n        },\n        on: {\n          click,\n          keydown\n        }\n      }, [(isPrev ? _this.safeScopedSlot('header-left-button', {\n        click\n      }) : _this.safeScopedSlot('header-right-button', {\n        click\n      })) || h(SvgIcon, {\n        props: {\n          name: isPrev ? 'left-arrow' : 'right-arrow'\n        }\n      })]);\n    }; // Day popover\n\n\n    const getDayPopover = function () {\n      return h(Popover, {\n        props: {\n          id: _this.sharedState.dayPopoverId,\n          contentClass: 'vc-day-popover-container'\n        },\n        scopedSlots: {\n          default: function ({\n            data: day,\n            updateLayout,\n            hide\n          }) {\n            const attributes = Object.values(day.attributes).filter(function (a) {\n              return a.popover;\n            });\n            const masks = _this.$locale.masks;\n            const format = _this.formatDate;\n            const dayTitle = format(day.date, masks.dayPopover);\n            return _this.safeScopedSlot('day-popover', {\n              day,\n              attributes,\n              masks,\n              format,\n              dayTitle,\n              updateLayout,\n              hide\n            }) || h('div', [// Show popover header only if format is defined\n            masks.dayPopover && h('div', {\n              class: ['vc-day-popover-header']\n            }, [dayTitle]), attributes.map(function (attribute) {\n              return h(PopoverRow, {\n                key: attribute.key,\n                props: {\n                  attribute\n                }\n              });\n            })]);\n          }\n        }\n      });\n    }; // Renderer for calendar container\n\n\n    const getContainerGrid = function () {\n      return h('div', {\n        attrs: {\n          'data-helptext': 'Press the arrow keys to navigate by day, Home and End to navigate to week ends, PageUp and PageDown to navigate by month, Alt+PageUp and Alt+PageDown to navigate by year'\n        },\n        class: ['vc-container', `vc-${_this.$theme.color}`, {\n          'vc-is-expanded': _this.isExpanded,\n          'vc-is-dark': _this.$theme.isDark\n        }],\n        on: {\n          keydown: _this.handleKeydown,\n          mouseup: function (e) {\n            return e.preventDefault();\n          }\n        },\n        ref: 'container'\n      }, [h('div', {\n        class: ['vc-pane-container', {\n          'in-transition': _this.inTransition\n        }]\n      }, [h(CustomTransition, {\n        props: {\n          name: _this.transitionName\n        },\n        on: {\n          beforeEnter: function () {\n            _this.inTransition = true;\n          },\n          afterEnter: function () {\n            _this.inTransition = false;\n          }\n        }\n      }, [h(Grid, {\n        class: 'grid',\n        props: {\n          rows: _this.rows,\n          columns: _this.columns,\n          columnWidth: 'minmax(256px, 1fr)',\n          disableFocus: true\n        },\n        attrs: { ..._this.$attrs\n        },\n        key: arrayHasItems(_this.pages) ? _this.pages[0].key : ''\n      }, panes)]), h('div', {\n        class: [`vc-arrows-container title-${_this.titlePosition_}`]\n      }, [getArrowButton(true), getArrowButton(false)]), _this.$scopedSlots.footer && _this.$scopedSlots.footer()]), getDayPopover()]);\n    };\n\n    return getContainerGrid();\n  },\n\n  mixins: [mixins_rootMixin, mixins_safeScopedSlotMixin],\n\n  provide() {\n    return {\n      sharedState: this.sharedState\n    };\n  },\n\n  props: {\n    rows: {\n      type: Number,\n      default: 1\n    },\n    columns: {\n      type: Number,\n      default: 1\n    },\n    step: Number,\n    titlePosition: String,\n    isExpanded: Boolean,\n    fromDate: Date,\n    toDate: Date,\n    fromPage: Object,\n    toPage: Object,\n    minPage: Object,\n    maxPage: Object,\n    transition: String,\n    attributes: [Object, Array],\n    disablePageSwipe: Boolean\n  },\n\n  data() {\n    return {\n      pages: [],\n      store: null,\n      lastFocusedDay: null,\n      focusableDay: new Date().getDate(),\n      transitionName: '',\n      inTransition: false,\n      sharedState: {\n        dayPopoverId: createGuid(),\n        theme: {},\n        masks: {},\n        locale: {}\n      }\n    };\n  },\n\n  computed: {\n    titlePosition_() {\n      return this.propOrDefault('titlePosition', 'titlePosition');\n    },\n\n    firstPage() {\n      return head_default()(this.pages);\n    },\n\n    lastPage() {\n      return last_default()(this.pages);\n    },\n\n    minPage_() {\n      return this.minPage || pageForDate(this.normalizeDate(this.minDate));\n    },\n\n    maxPage_() {\n      return this.maxPage || pageForDate(this.normalizeDate(this.maxDate));\n    },\n\n    count() {\n      return this.rows * this.columns;\n    },\n\n    step_() {\n      return this.step || this.count;\n    },\n\n    canMovePrev() {\n      return !pageIsValid(this.minPage_) || pageIsAfterPage(this.pages[0], this.minPage_);\n    },\n\n    canMoveNext() {\n      return !pageIsValid(this.maxPage_) || pageIsBeforePage(this.pages[this.pages.length - 1], this.maxPage_);\n    }\n\n  },\n  watch: {\n    $locale() {\n      this.refreshLocale();\n      this.refreshPages({\n        page: this.firstPage,\n        ignoreCache: true\n      });\n      this.initStore();\n    },\n\n    $theme() {\n      this.refreshTheme();\n      this.initStore();\n    },\n\n    timezone() {\n      // Refresh pages to reset the time boundaries\n      this.refreshPages({\n        ignoreCache: true\n      }); // Refresh attributes\n\n      this.refreshAttrs(this.pages, this.store.list, null, true);\n    },\n\n    fromDate() {\n      this.refreshPages();\n    },\n\n    fromPage(val) {\n      const firstPage = this.pages && this.pages[0];\n      if (pageIsEqualToPage(val, firstPage)) return;\n      this.refreshPages();\n    },\n\n    toPage(val) {\n      const lastPage = this.pages && this.pages[this.pages.length - 1];\n      if (pageIsEqualToPage(val, lastPage)) return;\n      this.refreshPages();\n    },\n\n    count() {\n      this.refreshPages();\n    },\n\n    attributes(val) {\n      const {\n        adds,\n        deletes\n      } = this.store.refresh(val);\n      this.refreshAttrs(this.pages, adds, deletes);\n    },\n\n    pages(val) {\n      this.refreshAttrs(val, this.store.list, null, true);\n    },\n\n    disabledAttribute() {\n      this.refreshDisabledDays();\n    },\n\n    lastFocusedDay(val) {\n      if (val) {\n        this.focusableDay = val.day;\n        this.refreshFocusableDays();\n      }\n    },\n\n    inTransition(val) {\n      if (val) {\n        this.$emit('transition-start');\n      } else {\n        this.$emit('transition-end');\n\n        if (this.transitionPromise) {\n          this.transitionPromise.resolve();\n          this.transitionPromise = null;\n        }\n      }\n    }\n\n  },\n\n  created() {\n    this.refreshLocale();\n    this.refreshTheme();\n    this.initStore();\n    this.refreshPages();\n  },\n\n  mounted() {\n    var _this2 = this;\n\n    if (!this.disablePageSwipe) {\n      // Add swipe handler to move to next and previous pages\n      const removeHandlers = addHorizontalSwipeHandler(this.$refs.container, function ({\n        toLeft,\n        toRight\n      }) {\n        if (toLeft) {\n          _this2.moveNext();\n        } else if (toRight) {\n          _this2.movePrev();\n        }\n      }, this.$defaults.touch); // Clean up on destroy\n\n      this.$once('beforeDestroy', function () {\n        return removeHandlers();\n      });\n    }\n  },\n\n  methods: {\n    refreshLocale() {\n      this.sharedState.locale = this.$locale;\n      this.sharedState.masks = this.$locale.masks;\n    },\n\n    refreshTheme() {\n      this.sharedState.theme = this.$theme;\n    },\n\n    canMove(page) {\n      return pageIsBetweenPages(page, this.minPage_, this.maxPage_);\n    },\n\n    async movePrev(opts) {\n      const result = await this.move(-this.step_, opts);\n      return result;\n    },\n\n    async moveNext(opts) {\n      const result = this.move(this.step_, opts);\n      return result;\n    },\n\n    async move(arg, opts) {\n      const page = this.$locale.toPage(arg, this.pages[0]);\n\n      if (!page) {\n        return null;\n      }\n\n      const result = await this.refreshPages({ ...opts,\n        page\n      });\n      return result;\n    },\n\n    async focusDate(date, opts = {}) {\n      const page = pageForDate(date); // Calculate new fromPage\n\n      let fromPage = null;\n\n      if (opts.position) {\n        fromPage = this.getTargetPageRange(page, opts.position).fromPage;\n      } else if (pageIsBeforePage(page, this.firstPage)) {\n        fromPage = this.getTargetPageRange(page, -1).fromPage;\n      } else if (pageIsAfterPage(page, this.lastPage)) {\n        fromPage = this.getTargetPageRange(page, 1).fromPage;\n      } // Move to new fromPage if it's different from the current one\n\n\n      if (fromPage && !pageIsEqualToPage(fromPage, this.pages[0])) {\n        await this.refreshPages({ ...opts,\n          position: 1,\n          page: fromPage\n        });\n      } // Set focus on the element for the date\n\n\n      const focusableEl = this.$el.querySelector(`.id-${this.$locale.getDayId(date)}.in-month .vc-focusable`);\n\n      if (focusableEl) {\n        focusableEl.focus();\n      }\n    },\n\n    async showPageRange(range, opts) {\n      let fromPage;\n      let toPage;\n\n      if (_isDate(range)) {\n        fromPage = pageForDate(range);\n      } else if (isObject(range)) {\n        const {\n          month,\n          year\n        } = range;\n        const {\n          from,\n          to\n        } = range;\n\n        if (isNumber_default()(month) && isNumber_default()(year)) {\n          fromPage = range;\n        } else if (from || to) {\n          fromPage = _isDate(from) ? pageForDate(from) : from;\n          toPage = _isDate(to) ? pageForDate(to) : to;\n        }\n      } else {\n        return;\n      }\n\n      const lastPage = this.lastPage;\n      let page = fromPage; // Offset page from the desired `toPage`\n\n      if (pageIsAfterPage(toPage, lastPage)) {\n        page = addPages(toPage, -(this.pages.length - 1));\n      } // But no earlier than the desired `fromPage`\n\n\n      if (pageIsBeforePage(page, fromPage)) {\n        page = fromPage;\n      }\n\n      await this.refreshPages({ ...opts,\n        page\n      });\n    },\n\n    getTargetPageRange(page, position) {\n      // Calculate the page to start displaying from\n      let fromPage = null; // 1. Try the page parameter\n\n      if (pageIsValid(page)) {\n        const pagesToAdd = position > 0 ? 1 - position : -(this.count + position);\n        fromPage = addPages(page, pagesToAdd);\n      } else {\n        // 2. Try the fromPage prop\n        fromPage = this.fromPage || pageForDate(this.normalizeDate(this.fromDate));\n\n        if (!pageIsValid(fromPage)) {\n          // 3. Try the toPage prop\n          const toPage = this.toPage || pageForDate(this.normalizeDate(this.toPage));\n\n          if (pageIsValid(toPage)) {\n            fromPage = addPages(toPage, 1 - this.count);\n          } else {\n            // 4. Try the first attribute\n            fromPage = this.getPageForAttributes();\n          }\n        }\n      } // 5. Fall back to today's page\n\n\n      fromPage = pageIsValid(fromPage) ? fromPage : pageForThisMonth(); // Adjust from page within allowed min/max pages\n\n      const toPage = addPages(fromPage, this.count - 1);\n\n      if (pageIsBeforePage(fromPage, this.minPage_)) {\n        fromPage = this.minPage_;\n      } else if (pageIsAfterPage(toPage, this.maxPage_)) {\n        fromPage = addPages(this.maxPage_, 1 - this.count);\n      }\n\n      return {\n        fromPage,\n        toPage\n      };\n    },\n\n    async refreshPages({\n      page,\n      position = 1,\n      transition,\n      ignoreCache\n    } = {}) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        const {\n          fromPage,\n          toPage\n        } = _this3.getTargetPageRange(page, position); // Create the new pages\n\n\n        const pages = [];\n\n        for (let i = 0; i < _this3.count; i++) {\n          pages.push(_this3.buildPage(addPages(fromPage, i), ignoreCache));\n        } // Refresh disabled days for new pages\n\n\n        _this3.refreshDisabledDays(pages); // Refresh focusable days for new pages\n\n\n        _this3.refreshFocusableDays(pages); // Assign the transition\n\n\n        _this3.transitionName = _this3.getPageTransition(_this3.pages[0], pages[0], transition); // Assign the new pages\n\n        _this3.pages = pages; // Emit page update events\n\n        _this3.$emit('update:from-page', fromPage);\n\n        _this3.$emit('update:to-page', toPage);\n\n        if (_this3.transitionName && _this3.transitionName !== 'none') {\n          _this3.transitionPromise = {\n            resolve,\n            reject\n          };\n        } else {\n          resolve();\n        }\n      });\n    },\n\n    refreshDisabledDays(pages) {\n      var _this4 = this;\n\n      this.getPageDays(pages).forEach(function (d) {\n        d.isDisabled = !!_this4.disabledAttribute && _this4.disabledAttribute.intersectsDay(d);\n      });\n    },\n\n    refreshFocusableDays(pages) {\n      var _this5 = this;\n\n      this.getPageDays(pages).forEach(function (d) {\n        d.isFocusable = d.inMonth && d.day === _this5.focusableDay;\n      });\n    },\n\n    getPageDays(pages = this.pages) {\n      return pages.reduce(function (prev, curr) {\n        return prev.concat(curr.days);\n      }, []);\n    },\n\n    getPageTransition(oldPage, newPage, transition = this.transition) {\n      if (transition === 'none') return transition;\n\n      if (transition === 'fade' || !transition && this.count > 1 || !pageIsValid(oldPage) || !pageIsValid(newPage)) {\n        return 'fade';\n      } // Moving to a previous page\n\n\n      const movePrev = pageIsBeforePage(newPage, oldPage); // Vertical slide\n\n      if (transition === 'slide-v') {\n        return movePrev ? 'slide-down' : 'slide-up';\n      } // Horizontal slide\n\n\n      return movePrev ? 'slide-right' : 'slide-left';\n    },\n\n    getPageForAttributes() {\n      let page = null;\n      const attr = this.store.pinAttr;\n\n      if (attr && attr.hasDates) {\n        let [date] = attr.dates;\n        date = date.start || date.date;\n        page = pageForDate(this.normalizeDate(date));\n      }\n\n      return page;\n    },\n\n    buildPage({\n      month,\n      year\n    }, ignoreCache) {\n      var _this6 = this;\n\n      const key = `${year.toString()}-${month.toString()}`;\n      let page = this.pages.find(function (p) {\n        return p.key === key;\n      });\n\n      if (!page || ignoreCache) {\n        const date = new Date(year, month - 1, 15);\n        const monthComps = this.$locale.getMonthComps(month, year);\n        const prevMonthComps = this.$locale.getPrevMonthComps(month, year);\n        const nextMonthComps = this.$locale.getNextMonthComps(month, year);\n        page = {\n          key,\n          month,\n          year,\n          title: this.$locale.format(date, this.$locale.masks.title),\n          shortMonthLabel: this.$locale.format(date, 'MMM'),\n          monthLabel: this.$locale.format(date, 'MMMM'),\n          shortYearLabel: year.toString().substring(2),\n          yearLabel: year.toString(),\n          monthComps,\n          prevMonthComps,\n          nextMonthComps,\n          canMove: function (pg) {\n            return _this6.canMove(pg);\n          },\n          move: function (pg) {\n            return _this6.move(pg);\n          },\n          moveThisMonth: function () {\n            return _this6.moveThisMonth();\n          },\n          movePrevMonth: function () {\n            return _this6.move(prevMonthComps);\n          },\n          moveNextMonth: function () {\n            return _this6.move(nextMonthComps);\n          },\n          refresh: true\n        }; // Assign day info\n\n        page.days = this.$locale.getCalendarDays(page, this.timezone);\n      }\n\n      return page;\n    },\n\n    initStore() {\n      // Create a new attribute store\n      this.store = new attributeStore_AttributeStore(this.$theme, this.$locale, this.attributes); // Refresh attributes for existing pages\n\n      this.refreshAttrs(this.pages, this.store.list, [], true);\n    },\n\n    refreshAttrs(pages = [], adds = [], deletes = [], reset) {\n      var _this7 = this;\n\n      if (!arrayHasItems(pages)) return; // For each page...\n\n      pages.forEach(function (p) {\n        // For each day...\n        p.days.forEach(function (d) {\n          let map = {}; // If resetting...\n\n          if (reset) {\n            d.refresh = true;\n          } else if (hasAny(d.attributesMap, deletes)) {\n            // Delete attributes from the delete list\n            map = omit_default()(d.attributesMap, deletes); // Flag day for refresh\n\n            d.refresh = true;\n          } else {\n            // Get the existing attributes\n            map = d.attributesMap || {};\n          } // For each attribute to add...\n\n\n          adds.forEach(function (attr) {\n            // Add it if it includes the current day\n            const targetDate = attr.intersectsDay(d);\n\n            if (targetDate) {\n              const newAttr = { ...attr,\n                targetDate\n              };\n              map[attr.key] = newAttr; // Flag day for refresh\n\n              d.refresh = true;\n            }\n          }); // Reassign day attributes\n\n          if (d.refresh) {\n            d.attributesMap = map;\n          }\n        });\n      }); // Refresh pages\n\n      this.$nextTick(function () {\n        _this7.$refs.pages.forEach(function (p) {\n          return p.refresh();\n        });\n      });\n    },\n\n    handleKeydown(e) {\n      const day = this.lastFocusedDay;\n\n      if (day != null) {\n        day.event = e;\n        this.handleDayKeydown(day);\n      }\n    },\n\n    handleDayKeydown(day) {\n      const {\n        date,\n        event\n      } = day;\n      let newDate = null;\n\n      switch (event.key) {\n        case 'ArrowLeft':\n          {\n            // Move to previous day\n            newDate = addDays(date, -1);\n            break;\n          }\n\n        case 'ArrowRight':\n          {\n            // Move to next day\n            newDate = addDays(date, 1);\n            break;\n          }\n\n        case 'ArrowUp':\n          {\n            // Move to previous week\n            newDate = addDays(date, -7);\n            break;\n          }\n\n        case 'ArrowDown':\n          {\n            // Move to next week\n            newDate = addDays(date, 7);\n            break;\n          }\n\n        case 'Home':\n          {\n            // Move to first weekday position\n            newDate = addDays(date, -day.weekdayPosition + 1);\n            break;\n          }\n\n        case 'End':\n          {\n            // Move to last weekday position\n            newDate = addDays(date, day.weekdayPositionFromEnd);\n            break;\n          }\n\n        case 'PageUp':\n          {\n            if (event.altKey) {\n              // Move to previous year w/ Alt/Option key\n              newDate = addYears(date, -1);\n            } else {\n              // Move to previous month\n              newDate = addMonths(date, -1);\n            }\n\n            break;\n          }\n\n        case 'PageDown':\n          {\n            if (event.altKey) {\n              // Move to next year w/ Alt/Option key\n              newDate = addYears(date, 1);\n            } else {\n              // Move to next month\n              newDate = addMonths(date, 1);\n            }\n\n            break;\n          }\n      }\n\n      if (newDate) {\n        event.preventDefault();\n        this.focusDate(newDate);\n      }\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/Calendar.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_Calendarvue_type_script_lang_js_ = (Calendarvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/Calendar.vue?vue&type=style&index=0&lang=postcss&\nvar Calendarvue_type_style_index_0_lang_postcss_ = __webpack_require__(\"de5e\");\n\n// CONCATENATED MODULE: ./src/components/Calendar.vue\nvar Calendar_render, Calendar_staticRenderFns\n\n\n\n\n\n/* normalize component */\n\nvar Calendar_component = normalizeComponent(\n  components_Calendarvue_type_script_lang_js_,\n  Calendar_render,\n  Calendar_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var Calendar = (Calendar_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"8773979e-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/TimePicker.vue?vue&type=template&id=31a34bc2&scoped=true&\nvar TimePickervue_type_template_id_31a34bc2_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"vc-time-container\",class:[{ 'vc-invalid': !_vm.value.isValid }]},[_c('div',[_c('svg',{staticClass:\"vc-time-icon\",attrs:{\"fill\":\"none\",\"stroke-linecap\":\"round\",\"stroke-linejoin\":\"round\",\"stroke-width\":\"2\",\"viewBox\":\"0 0 24 24\",\"stroke\":\"currentColor\"}},[_c('path',{attrs:{\"d\":\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\"}})])]),_c('div',{staticClass:\"vc-date-time\"},[_c('div',{staticClass:\"vc-date\"},[_c('span',{staticClass:\"vc-weekday\"},[_vm._v(\" \"+_vm._s(_vm.locale.format(_vm.date, 'WWW'))+\" \")]),_c('span',{staticClass:\"vc-month\"},[_vm._v(\" \"+_vm._s(_vm.locale.format(_vm.date, 'MMM'))+\" \")]),_c('span',{staticClass:\"vc-day\"},[_vm._v(\" \"+_vm._s(_vm.locale.format(_vm.date, 'DD'))+\" \")]),_c('span',{staticClass:\"vc-year\"},[_vm._v(\" \"+_vm._s(_vm.locale.format(_vm.date, 'YYYY'))+\" \")])]),_c('div',{staticClass:\"vc-time\"},[_c('time-select',{attrs:{\"options\":_vm.hourOptions},model:{value:(_vm.hours),callback:function ($$v) {_vm.hours=_vm._n($$v)},expression:\"hours\"}}),_c('span',{staticStyle:{\"margin\":\"0 4px\"}},[_vm._v(\":\")]),_c('time-select',{attrs:{\"options\":_vm.minuteOptions},model:{value:(_vm.minutes),callback:function ($$v) {_vm.minutes=_vm._n($$v)},expression:\"minutes\"}}),_c('div',{staticClass:\"vc-am-pm\"},[_c('button',{class:{ active: _vm.isAM },on:{\"click\":function($event){_vm.isAM = true}}},[_vm._v(\" AM \")]),_c('button',{class:{ active: !_vm.isAM },on:{\"click\":function($event){_vm.isAM = false}}},[_vm._v(\" PM \")])])],1)])])}\nvar TimePickervue_type_template_id_31a34bc2_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/TimePicker.vue?vue&type=template&id=31a34bc2&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"8773979e-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/TimeSelect.vue?vue&type=template&id=26a07a51&scoped=true&\nvar TimeSelectvue_type_template_id_26a07a51_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"vc-select\"},[_c('select',_vm._b({on:{\"change\":function($event){return _vm.$emit('input', $event.target.value)}}},'select',_vm.$attrs,false),_vm._l((_vm.options),function(option){return _c('option',{key:option.value,domProps:{\"value\":option.value}},[_vm._v(_vm._s(option.label))])}),0),_c('div',{staticClass:\"vc-select-arrow\"},[_c('svg',{attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 20 20\"}},[_c('path',{attrs:{\"d\":\"M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z\"}})])])])}\nvar TimeSelectvue_type_template_id_26a07a51_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/TimeSelect.vue?vue&type=template&id=26a07a51&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/TimeSelect.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ var TimeSelectvue_type_script_lang_js_ = ({\n  inheritAttrs: false,\n  props: {\n    options: Array\n  }\n});\n// CONCATENATED MODULE: ./src/components/TimeSelect.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_TimeSelectvue_type_script_lang_js_ = (TimeSelectvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/TimeSelect.vue?vue&type=style&index=0&id=26a07a51&lang=postcss&scoped=true&\nvar TimeSelectvue_type_style_index_0_id_26a07a51_lang_postcss_scoped_true_ = __webpack_require__(\"eefb\");\n\n// CONCATENATED MODULE: ./src/components/TimeSelect.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar TimeSelect_component = normalizeComponent(\n  components_TimeSelectvue_type_script_lang_js_,\n  TimeSelectvue_type_template_id_26a07a51_scoped_true_render,\n  TimeSelectvue_type_template_id_26a07a51_scoped_true_staticRenderFns,\n  false,\n  null,\n  \"26a07a51\",\n  null\n  \n)\n\n/* harmony default export */ var TimeSelect = (TimeSelect_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/TimePicker.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ var TimePickervue_type_script_lang_js_ = ({\n  name: 'TimePicker',\n  components: {\n    TimeSelect: TimeSelect\n  },\n  props: {\n    value: {\n      type: Object,\n      required: true\n    },\n    locale: {\n      type: Object,\n      required: true\n    },\n    theme: {\n      type: Object,\n      required: true\n    }\n  },\n\n  data() {\n    return {\n      hours: 0,\n      minutes: 0,\n      minuteIncrement: 1,\n      isAM: true\n    };\n  },\n\n  computed: {\n    date() {\n      let date = this.locale.normalizeDate(this.value);\n\n      if (this.value.hours === 24) {\n        date = new Date(date.getTime() - 1);\n      }\n\n      return date;\n    },\n\n    hourOptions() {\n      const options12 = [{\n        value: 0,\n        label: '12'\n      }, {\n        value: 1,\n        label: '1'\n      }, {\n        value: 2,\n        label: '2'\n      }, {\n        value: 3,\n        label: '3'\n      }, {\n        value: 4,\n        label: '4'\n      }, {\n        value: 5,\n        label: '5'\n      }, {\n        value: 6,\n        label: '6'\n      }, {\n        value: 7,\n        label: '7'\n      }, {\n        value: 8,\n        label: '8'\n      }, {\n        value: 9,\n        label: '9'\n      }, {\n        value: 10,\n        label: '10'\n      }, {\n        value: 11,\n        label: '11'\n      }];\n      const options24 = [{\n        value: 0,\n        label: '00'\n      }, {\n        value: 1,\n        label: '01'\n      }, {\n        value: 2,\n        label: '02'\n      }, {\n        value: 3,\n        label: '03'\n      }, {\n        value: 4,\n        label: '04'\n      }, {\n        value: 5,\n        label: '05'\n      }, {\n        value: 6,\n        label: '06'\n      }, {\n        value: 7,\n        label: '07'\n      }, {\n        value: 8,\n        label: '08'\n      }, {\n        value: 9,\n        label: '09'\n      }, {\n        value: 10,\n        label: '10'\n      }, {\n        value: 11,\n        label: '11'\n      }, {\n        value: 12,\n        label: '12'\n      }, {\n        value: 13,\n        label: '13'\n      }, {\n        value: 14,\n        label: '14'\n      }, {\n        value: 15,\n        label: '15'\n      }, {\n        value: 16,\n        label: '16'\n      }, {\n        value: 17,\n        label: '17'\n      }, {\n        value: 18,\n        label: '18'\n      }, {\n        value: 19,\n        label: '19'\n      }, {\n        value: 20,\n        label: '20'\n      }, {\n        value: 21,\n        label: '21'\n      }, {\n        value: 22,\n        label: '22'\n      }, {\n        value: 23,\n        label: '23'\n      }];\n      if (this.is24hr) return options24;\n      return options12;\n    },\n\n    minuteOptions() {\n      const options = [];\n      let m = 0;\n\n      while (m <= 59) {\n        options.push({\n          value: m,\n          label: pad(m, 2)\n        });\n        m += this.minuteIncrement;\n      }\n\n      return options;\n    }\n\n  },\n  watch: {\n    value() {\n      this.setup();\n    },\n\n    hours() {\n      this.updateValue();\n    },\n\n    minutes() {\n      this.updateValue();\n    },\n\n    isAM() {\n      this.updateValue();\n    }\n\n  },\n\n  created() {\n    this.setup();\n  },\n\n  methods: {\n    protected(fn) {\n      var _this = this;\n\n      if (this.busy) return;\n      this.busy = true;\n      fn();\n      this.$nextTick(function () {\n        return _this.busy = false;\n      });\n    },\n\n    setup() {\n      var _this2 = this;\n\n      this.protected(function () {\n        _this2.is24hr = _this2.locale.is24hr !== undefined ? _this2.locale.is24hr : false;\n        let {\n          hours\n        } = _this2.value;\n        if (hours === 24) hours = 0;\n        let isAM = true;\n\n        if (!_this2.is24hr && hours >= 12) {\n          hours -= 12;\n          isAM = false;\n        }\n\n        _this2.hours = hours;\n        _this2.minutes = _this2.value.minutes;\n        _this2.isAM = isAM;\n      });\n    },\n\n    updateValue() {\n      var _this3 = this;\n\n      this.protected(function () {\n        let hours = _this3.hours;\n\n        if (!_this3.is24hr && !_this3.isAM) {\n          hours += 12;\n        }\n\n        _this3.$emit('input', { ..._this3.value,\n          hours,\n          minutes: _this3.minutes\n        });\n      });\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/TimePicker.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_TimePickervue_type_script_lang_js_ = (TimePickervue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/TimePicker.vue?vue&type=style&index=0&id=31a34bc2&lang=postcss&scoped=true&\nvar TimePickervue_type_style_index_0_id_31a34bc2_lang_postcss_scoped_true_ = __webpack_require__(\"d6f8\");\n\n// CONCATENATED MODULE: ./src/components/TimePicker.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar TimePicker_component = normalizeComponent(\n  components_TimePickervue_type_script_lang_js_,\n  TimePickervue_type_template_id_31a34bc2_scoped_true_render,\n  TimePickervue_type_template_id_31a34bc2_scoped_true_staticRenderFns,\n  false,\n  null,\n  \"31a34bc2\",\n  null\n  \n)\n\n/* harmony default export */ var TimePicker = (TimePicker_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/DatePicker.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n\nconst _dateConfig = {\n  type: 'auto',\n  mask: 'iso',\n  // String mask when `type === 'string'`\n  timeAdjust: '' // 'HH:MM:SS', 'now'\n\n};\nconst _rangeConfig = {\n  start: { ..._dateConfig,\n    timeAdjust: '00:00:00'\n  },\n  end: { ..._dateConfig,\n    timeAdjust: '23:59:59'\n  }\n};\nconst PATCH_KEYS = {\n  1: ['year', 'month', 'day', 'hours', 'minutes', 'seconds'],\n  2: ['year', 'month', 'day'],\n  3: ['hours', 'minutes', 'seconds']\n};\nconst MODE_DATE = 'date';\nconst MODE_DATE_TIME = 'datetime';\nconst MODE_TIME = 'time';\nconst PATCH_DATE_TIME = 1;\nconst PATCH_DATE = 2;\nconst PATCH_TIME = 3;\n/* harmony default export */ var DatePickervue_type_script_lang_js_ = ({\n  name: 'DatePicker',\n\n  render(h) {\n    var _this = this;\n\n    // Timepicker renderer\n    const timePicker = function () {\n      if (!_this.dateParts) return null;\n      const parts = _this.isRange ? _this.dateParts : [_this.dateParts[0]];\n      return parts.map(function (dp, idx) {\n        return h(TimePicker, {\n          props: {\n            value: dp,\n            locale: _this.$locale,\n            theme: _this.$theme\n          },\n          on: {\n            input: function (p) {\n              return _this.onTimeInput(p, idx);\n            }\n          }\n        });\n      });\n    }; // Calendar renderer\n\n\n    const calendar = function () {\n      return h(Calendar, {\n        attrs: { ..._this.$attrs,\n          attributes: _this.attributes_,\n          theme: _this.$theme,\n          locale: _this.$locale,\n          timezone: _this.timezone\n        },\n        props: {\n          minDate: _this.minDate,\n          maxDate: _this.maxDate,\n          disabledDates: _this.disabledDates,\n          availableDates: _this.availableDates\n        },\n        on: { ..._this.$listeners,\n          dayclick: _this.onDayClick,\n          daykeydown: _this.onDayKeydown,\n          daymouseenter: _this.onDayMouseEnter\n        },\n        scopedSlots: { ..._this.$scopedSlots,\n          footer: _this.isDateTime && timePicker\n        },\n        ref: 'calendar'\n      });\n    }; // Content renderer\n\n\n    const content = function () {\n      if (_this.isTime) {\n        return h('div', {\n          class: ['vc-container', `vc-${_this.$theme.color}`, {\n            'vc-is-dark': _this.$theme.isDark\n          }]\n        }, [timePicker()]);\n      }\n\n      return calendar();\n    };\n\n    return this.$scopedSlots.default && // Convert this span to a fragment when supported in Vue\n    h('span', [// Slot content\n    this.$scopedSlots.default(this.slotArgs), // Popover content\n    h(Popover, {\n      props: {\n        id: this.datePickerPopoverId,\n        placement: 'bottom-start',\n        contentClass: `vc-container${this.isDark ? ' vc-is-dark' : ''}`\n      },\n      on: {\n        beforeShow: function (e) {\n          return _this.$emit('popoverWillShow', e);\n        },\n        afterShow: function (e) {\n          return _this.$emit('popoverDidShow', e);\n        },\n        beforeHide: function (e) {\n          return _this.$emit('popoverWillHide', e);\n        },\n        afterHide: function (e) {\n          return _this.$emit('popoverDidHide', e);\n        }\n      },\n      scopedSlots: {\n        default() {\n          return content();\n        }\n\n      },\n      ref: 'popover'\n    })]) || content();\n  },\n\n  mixins: [mixins_rootMixin],\n  props: {\n    mode: {\n      type: String,\n      default: MODE_DATE\n    },\n    value: {\n      type: null,\n      required: true\n    },\n    modelConfig: {\n      type: Object,\n      default: function () {\n        return { ..._dateConfig\n        };\n      }\n    },\n    isRequired: Boolean,\n    isRange: Boolean,\n    updateOnInput: Boolean,\n    inputDebounce: Number,\n    popover: {\n      type: Object,\n      default: function () {\n        return {};\n      }\n    },\n    dragAttribute: Object,\n    selectAttribute: Object,\n    attributes: Array\n  },\n\n  data() {\n    return {\n      value_: null,\n      dateParts: null,\n      activeDate: '',\n      dragValue: null,\n      inputValues: ['', ''],\n      updateTimeout: null,\n      watchValue: true,\n      datePickerPopoverId: createGuid()\n    };\n  },\n\n  computed: {\n    updateOnInput_() {\n      return this.propOrDefault('updateOnInput', 'datePicker.updateOnInput');\n    },\n\n    inputDebounce_() {\n      return this.propOrDefault('inputDebounce', 'datePicker.inputDebounce');\n    },\n\n    isDate() {\n      return this.mode.toLowerCase() === MODE_DATE;\n    },\n\n    isDateTime() {\n      return this.mode.toLowerCase() === MODE_DATE_TIME;\n    },\n\n    isTime() {\n      return this.mode.toLowerCase() === MODE_TIME;\n    },\n\n    isDragging() {\n      return !!this.dragValue;\n    },\n\n    slotArgs() {\n      var _this2 = this;\n\n      const inputConfig = {\n        type: 'string',\n        mask: this.$locale.masks.input,\n        patch: PATCH_DATE_TIME,\n        timezone: this.timezone\n      };\n      const {\n        isRange,\n        isDragging,\n        updateValue,\n        showPopover,\n        hidePopover,\n        togglePopover\n      } = this;\n      const inputValue = isRange ? {\n        start: this.inputValues[0],\n        end: this.inputValues[1]\n      } : this.inputValues[0];\n      const events = [true, false].map(function (isStart) {\n        return {\n          input: _this2.onInputInput(inputConfig, isStart),\n          change: _this2.onInputChange(inputConfig, isStart),\n          keyup: _this2.onInputKeyup,\n          ...getPopoverTriggerEvents({ ..._this2.popover_,\n            id: _this2.datePickerPopoverId,\n            callback: function (e) {\n              if (e.action === 'show' && e.completed) {\n                _this2.onInputShow(isStart);\n              }\n            }\n          })\n        };\n      });\n      const inputEvents = isRange ? {\n        start: events[0],\n        end: events[1]\n      } : events[0];\n      return {\n        inputValue,\n        inputEvents,\n        isDragging,\n        updateValue,\n        showPopover,\n        hidePopover,\n        togglePopover,\n        getPopoverTriggerEvents: getPopoverTriggerEvents\n      };\n    },\n\n    popover_() {\n      return this.propOrDefault('popover', 'datePicker.popover', 'merge');\n    },\n\n    canHidePopover() {\n      return !(this.popover.keepVisibleOnInput || this.popover_.visibility !== 'visible');\n    },\n\n    selectAttribute_() {\n      if (!this.hasValue(this.value_)) return null;\n      const attribute = {\n        key: 'select-drag',\n        ...this.selectAttribute,\n        dates: this.value_,\n        pinPage: true\n      };\n      const {\n        dot,\n        bar,\n        highlight,\n        content\n      } = attribute;\n\n      if (!dot && !bar && !highlight && !content) {\n        attribute.highlight = true;\n      }\n\n      return attribute;\n    },\n\n    dragAttribute_() {\n      if (!this.isRange || !this.hasValue(this.dragValue)) {\n        return null;\n      }\n\n      const attribute = {\n        key: 'select-drag',\n        ...this.dragAttribute,\n        dates: this.dragValue\n      };\n      const {\n        dot,\n        bar,\n        highlight,\n        content\n      } = attribute;\n\n      if (!dot && !bar && !highlight && !content) {\n        attribute.highlight = {\n          startEnd: {\n            fillMode: 'none'\n          }\n        };\n      }\n\n      return attribute;\n    },\n\n    attributes_() {\n      const attrs = isArrayLikeObject_default()(this.attributes) ? [...this.attributes] : [];\n\n      if (this.dragAttribute_) {\n        attrs.push(this.dragAttribute_);\n      } else if (this.selectAttribute_) {\n        attrs.push(this.selectAttribute_);\n      }\n\n      return attrs;\n    }\n\n  },\n  watch: {\n    isRange: {\n      immediate: true,\n\n      handler() {\n        this.initDateConfig();\n      }\n\n    },\n\n    value() {\n      if (!this.watchValue) return;\n      this.forceUpdateValue(this.value, {\n        config: this.modelConfig,\n        notify: false,\n        formatInput: true,\n        hidePopover: false\n      });\n    },\n\n    value_() {\n      this.refreshDateParts();\n    },\n\n    dragValue() {\n      this.refreshDateParts();\n    },\n\n    timezone() {\n      this.initDateConfig();\n      this.refreshDateParts();\n      this.forceUpdateValue(this.value_, {\n        notify: true,\n        formatInput: true\n      });\n    }\n\n  },\n\n  created() {\n    this.forceUpdateValue(this.value, {\n      config: this.modelConfig,\n      notify: false,\n      formatInput: true,\n      hidePopover: false\n    });\n    this.refreshDateParts();\n  },\n\n  mounted() {\n    var _this3 = this;\n\n    // Handle escape key presses\n    on(document, 'keydown', this.onDocumentKeyDown); // Clear drag on background click\n\n    const offTapOrClickHandler = addTapOrClickHandler(document, function (e) {\n      if (document.body.contains(e.target) && !elementContains(_this3.$el, e.target)) {\n        _this3.dragValue = null;\n      }\n    }); // Clean up handlers\n\n    this.$once('beforeDestroy', function () {\n      off(document, 'keydown', _this3.onDocumentKeyDown);\n      offTapOrClickHandler();\n    });\n  },\n\n  methods: {\n    initDateConfig() {\n      let config;\n      const timezone = this.timezone;\n\n      if (this.isRange) {\n        config = {\n          start: {\n            timezone,\n            ..._rangeConfig.start,\n            ...(this.modelConfig.start || this.modelConfig)\n          },\n          end: {\n            timezone,\n            ..._rangeConfig.end,\n            ...(this.modelConfig.end || this.modelConfig)\n          }\n        };\n      } else {\n        config = {\n          timezone,\n          ..._dateConfig,\n          ...this.modelConfig\n        };\n      }\n\n      this.dateConfig = config;\n    },\n\n    getDateParts(date) {\n      return this.$locale.getDateParts(date, this.timezone);\n    },\n\n    getDateFromParts(parts) {\n      return this.$locale.getDateFromParts(parts, this.timezone);\n    },\n\n    refreshDateParts() {\n      var _this4 = this;\n\n      const value = this.dragValue || this.value_;\n      const dateParts = [];\n\n      if (this.isRange) {\n        if (value && value.start) {\n          dateParts.push(this.getDateParts(value.start));\n        } else {\n          dateParts.push({});\n        }\n\n        if (value && value.end) {\n          dateParts.push(this.getDateParts(value.end));\n        } else {\n          dateParts.push({});\n        }\n      } else if (value) {\n        dateParts.push(this.getDateParts(value));\n      } else {\n        dateParts.push({});\n      }\n\n      this.$nextTick(function () {\n        return _this4.dateParts = dateParts;\n      });\n    },\n\n    onDocumentKeyDown(e) {\n      // Clear drag on escape keydown\n      if (this.dragValue && e.key === 'Escape') {\n        this.dragValue = null;\n      }\n    },\n\n    onDayClick(day) {\n      this.handleDayClick(day); // Re-emit event\n\n      this.$emit('dayclick', day);\n    },\n\n    onDayKeydown(day) {\n      switch (day.event.key) {\n        case ' ':\n        case 'Enter':\n          {\n            this.handleDayClick(day);\n            day.event.preventDefault();\n            break;\n          }\n\n        case 'Escape':\n          {\n            this.hidePopover();\n          }\n      } // Re-emit event\n\n\n      this.$emit('daykeydown', day);\n    },\n\n    handleDayClick(day) {\n      const opts = {\n        patch: PATCH_DATE,\n        adjustTime: true,\n        formatInput: true,\n        hidePopover: this.isDate\n      };\n\n      if (this.isRange) {\n        if (!this.isDragging) {\n          this.dragTrackingValue = { ...day.range\n          };\n        } else {\n          this.dragTrackingValue.end = day.range.start;\n        }\n\n        opts.isDragging = !this.isDragging;\n        opts.hidePopover = opts.hidePopover && !opts.isDragging;\n        this.updateValue(this.dragTrackingValue, opts);\n      } else {\n        this.updateValue(day.range.start, opts);\n      }\n    },\n\n    onDayMouseEnter(day) {\n      if (!this.isDragging) return;\n      this.dragTrackingValue.end = day.range.start;\n      this.updateValue(this.dragTrackingValue, {\n        patch: PATCH_DATE,\n        adjustTime: true\n      });\n    },\n\n    onTimeInput(parts, idx) {\n      const opts = {\n        config: {\n          timezone: this.timezone,\n          type: 'object'\n        },\n        patch: PATCH_TIME\n      };\n\n      if (this.isRange) {\n        const start = idx === 0 ? parts : this.dateParts[0];\n        const end = idx === 0 ? this.dateParts[1] : parts;\n        this.updateValue({\n          start,\n          end\n        }, opts);\n      } else {\n        this.updateValue(parts, opts);\n      }\n    },\n\n    onInputInput(config, isStart) {\n      var _this5 = this;\n\n      return async function (e) {\n        if (!_this5.updateOnInput_) return;\n        let inputValue = e.target.value;\n\n        _this5.inputValues.splice(isStart ? 0 : 1, 1, inputValue);\n\n        if (_this5.isRange) {\n          inputValue = {\n            start: _this5.inputValues[0],\n            end: _this5.inputValues[1]\n          };\n        }\n\n        await _this5.updateValue(inputValue, {\n          config,\n          patch: PATCH_DATE_TIME,\n          formatInput: false,\n          hidePopover: false,\n          debounce: _this5.inputDebounce_\n        });\n\n        _this5.adjustPageRange(isStart);\n      };\n    },\n\n    onInputChange(config, isStart) {\n      var _this6 = this;\n\n      const opts = {\n        config,\n        formatInput: true,\n        hidePopover: false\n      };\n      return function (e) {\n        const inputValue = e.target.value;\n\n        if (_this6.isRange) {\n          _this6.inputValues.splice(isStart ? 0 : 1, 1, inputValue);\n\n          _this6.updateValue({\n            start: _this6.inputValues[0],\n            end: _this6.inputValues[1]\n          }, opts);\n        } else {\n          _this6.inputValues.splice(0, 1, inputValue);\n\n          _this6.updateValue(inputValue, opts);\n        }\n      };\n    },\n\n    onInputShow(isStart) {\n      this.adjustPageRange(isStart);\n    },\n\n    onInputKeyup(e) {\n      // Escape key only\n      if (e.key !== 'Escape') return;\n      this.updateValue(this.value_, {\n        formatInput: true,\n        hidePopover: true\n      });\n    },\n\n    updateValue(value, opts = {}) {\n      var _this7 = this;\n\n      clearTimeout(this.updateTimeout);\n      return new Promise(function (resolve) {\n        const {\n          debounce,\n          ...args\n        } = opts;\n\n        if (debounce > 0) {\n          _this7.updateTimeout = setTimeout(function () {\n            _this7.forceUpdateValue(value, args);\n\n            resolve(_this7.value_);\n          }, debounce);\n        } else {\n          _this7.forceUpdateValue(value, args);\n\n          resolve(_this7.value_);\n        }\n      });\n    },\n\n    forceUpdateValue(value, {\n      config = this.dateConfig,\n      patch = PATCH_DATE_TIME,\n      notify = true,\n      formatInput = true,\n      hidePopover = false,\n      adjustTime = false,\n      isDragging = this.isDragging\n    } = {}) {\n      var _this8 = this;\n\n      // 1. Normalization\n      let normalizedValue = this.normalizeValue(value, config, patch, isDragging); // Time Adjustment\n\n      if (adjustTime) {\n        normalizedValue = this.adjustTimeForValue(normalizedValue, config);\n      } // 2. Validation (date or range)\n\n\n      if (this.hasValue(normalizedValue) && this.disabledAttribute && this.disabledAttribute.intersectsDate(normalizedValue)) {\n        if (isDragging) return;\n        normalizedValue = this.value_;\n      } // 3. Assignment\n\n\n      const valueKey = isDragging ? 'dragValue' : 'value_';\n      const valueChanged = !this.valuesAreEqual(this[valueKey], normalizedValue);\n\n      if (valueChanged) {\n        this.$set(this, valueKey, normalizedValue); // Clear drag value if needed\n\n        if (!isDragging) this.dragValue = null;\n      } // 4. Denormalization/Notification\n\n\n      if (notify && valueChanged) {\n        // 4A. Denormalization\n        const denormalizedValue = this.denormalizeValue(normalizedValue, this.dateConfig); // 4B. Notification\n\n        const event = this.isDragging ? 'drag' : 'input';\n        this.watchValue = false;\n        this.$emit(event, denormalizedValue);\n        this.$nextTick(function () {\n          return _this8.watchValue = true;\n        });\n      } // 5. Side effects for non-inline pickers\n\n\n      if (formatInput) this.formatInput();\n      if (hidePopover) this.hidePopover();\n    },\n\n    hasValue(value) {\n      if (this.isRange) {\n        return isObject(value) && value.start && value.end;\n      }\n\n      return !!value;\n    },\n\n    normalizeValue(value, config, patch, isDragging) {\n      if (!this.hasValue(value)) return null;\n      const patchKeys = PATCH_KEYS[patch];\n\n      if (this.isRange) {\n        const start = this.normalizeDate(value.start, config.start || config);\n        const end = this.normalizeDate(value.end, config.end || config);\n        const result = this.sortRange({\n          start,\n          end\n        });\n\n        if (patch !== PATCH_DATE_TIME) {\n          const startParts = { ...this.dateParts[0],\n            ...pick_default()(this.getDateParts(result.start), patchKeys)\n          };\n          result.start = this.getDateFromParts(startParts);\n          const endParts = { ...this.dateParts[1],\n            ...pick_default()(this.getDateParts(result.end), patchKeys)\n          };\n          result.end = this.getDateFromParts(endParts);\n        }\n\n        return isDragging ? result : this.sortRange(result);\n      }\n\n      let result = this.normalizeDate(value, config);\n      if (patch === PATCH_DATE_TIME) return result;\n      result = { ...this.dateParts[0],\n        ...pick_default()(this.getDateParts(result), patchKeys)\n      };\n      return this.getDateFromParts(result);\n    },\n\n    adjustTimeForValue(value, config) {\n      if (this.isRange) {\n        if (!this.hasValue(value)) return null;\n        return {\n          start: this.$locale.adjustTimeForDate(value.start, config.start || config),\n          end: this.$locale.adjustTimeForDate(value.end, config.end || config)\n        };\n      }\n\n      return this.$locale.adjustTimeForDate(value, config);\n    },\n\n    sortRange(range) {\n      const {\n        start,\n        end\n      } = range;\n\n      if (start > end) {\n        return {\n          start: end,\n          end: start\n        };\n      }\n\n      return {\n        start,\n        end\n      };\n    },\n\n    denormalizeValue(value, config) {\n      if (this.isRange) {\n        if (!this.hasValue(value)) return null;\n        return {\n          start: this.$locale.denormalizeDate(value.start, config.start || config),\n          end: this.$locale.denormalizeDate(value.end, config.end || config)\n        };\n      }\n\n      return this.$locale.denormalizeDate(value, config);\n    },\n\n    valuesAreEqual(a, b) {\n      if (this.isRange) {\n        const aHasValue = this.hasValue(a);\n        const bHasValue = this.hasValue(b);\n        if (!aHasValue && !bHasValue) return true;\n        if (aHasValue !== bHasValue) return false;\n        return datesAreEqual(a.start, b.start) && datesAreEqual(a.end, b.end);\n      }\n\n      return datesAreEqual(a, b);\n    },\n\n    formatInput() {\n      var _this9 = this;\n\n      this.$nextTick(function () {\n        const opts = {\n          type: 'string',\n          mask: _this9.$locale.masks.input,\n          timezone: _this9.timezone\n        };\n\n        const value = _this9.denormalizeValue(_this9.dragValue || _this9.value_, opts);\n\n        if (_this9.isRange) {\n          _this9.inputValues = [value && value.start, value && value.end];\n        } else {\n          _this9.inputValues = [value, ''];\n        }\n      });\n    },\n\n    showPopover(opts = {}) {\n      popovers_showPopover({\n        ref: this.$el,\n        ...opts,\n        isInteractive: true,\n        id: this.datePickerPopoverId\n      });\n    },\n\n    hidePopover(opts = {}) {\n      popovers_hidePopover({ ...opts,\n        id: this.datePickerPopoverId\n      });\n    },\n\n    togglePopover(opts) {\n      popovers_togglePopover({\n        ref: this.$el,\n        ...opts,\n        isInteractive: true,\n        id: this.datePickerPopoverId\n      });\n    },\n\n    adjustPageRange(isStart) {\n      var _this10 = this;\n\n      this.$nextTick(function () {\n        const calendar = _this10.$refs.calendar;\n\n        const page = _this10.getPageForValue(isStart);\n\n        const position = isStart ? 1 : -1;\n\n        if (page && calendar && !pageIsBetweenPages(page, calendar.firstPage, calendar.lastPage)) {\n          calendar.move(page, {\n            position,\n            transition: 'fade'\n          });\n        }\n      });\n    },\n\n    getPageForValue(isStart) {\n      if (this.hasValue(this.value_)) {\n        return pageForDate(this.isRange ? this.value_[isStart ? 'start' : 'end'] : this.value_);\n      }\n\n      return null;\n    }\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/DatePicker.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_DatePickervue_type_script_lang_js_ = (DatePickervue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/components/DatePicker.vue\nvar DatePicker_render, DatePicker_staticRenderFns\n\n\n\n\n/* normalize component */\n\nvar DatePicker_component = normalizeComponent(\n  components_DatePickervue_type_script_lang_js_,\n  DatePicker_render,\n  DatePicker_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var DatePicker = (DatePicker_component.exports);\n// CONCATENATED MODULE: C:/Projects/v-calendar/node_modules/@vue/cli-service/lib/commands/build/entry-lib.js\n\n\n/* harmony default export */ var entry_lib = __webpack_exports__[\"default\"] = (DatePicker);\n\n\n\n/***/ }),\n\n/***/ \"fba5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(\"cb5a\");\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n/***/ }),\n\n/***/ \"fc6a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(\"44ad\");\nvar requireObjectCoercible = __webpack_require__(\"1d80\");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n/***/ }),\n\n/***/ \"fdbc\":\n/***/ (function(module, exports) {\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nmodule.exports = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n\n/***/ }),\n\n/***/ \"fdbf\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar NATIVE_SYMBOL = __webpack_require__(\"4930\");\n\nmodule.exports = NATIVE_SYMBOL\n  // eslint-disable-next-line no-undef\n  && !Symbol.sham\n  // eslint-disable-next-line no-undef\n  && typeof Symbol.iterator == 'symbol';\n\n\n/***/ }),\n\n/***/ \"ffd6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(\"3729\"),\n    isObjectLike = __webpack_require__(\"1310\");\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n/***/ })\n\n/******/ })[\"default\"];\n});\n//# sourceMappingURL=date-picker.umd.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdi1jYWxlbmRhci9saWIvY29tcG9uZW50cy9kYXRlLXBpY2tlci51bWQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdi1jYWxlbmRhci9saWIvY29tcG9uZW50cy9kYXRlLXBpY2tlci51bWQuanM/NDA0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJ2dWVcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZGF0ZS1waWNrZXJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJ2dWVcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImRhdGUtcGlja2VyXCJdID0gZmFjdG9yeShyb290W1wiVnVlXCJdKTtcbn0pKCh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyksIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzhiYmZfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCJmYjE1XCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIjAwZmRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZTY5XCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjAzZGRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImVhYzVcIiksXG4gICAgbmF0aXZlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1N2E1XCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMDYyMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllNjlcIiksXG4gICAgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDM3MFwiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY3NDdcIik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMDZjZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODNhYlwiKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMWU3XCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1YzZjXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYzZhXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMwNGVcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxMzVcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGNmYlwiKTtcblxudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwN2M3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMDg3ZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjA4Y2NcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFhOGNcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMGE2YlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI3ZmVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ5OWVcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjM5Mjk5NTNmXCIsIGNvbnRlbnQsIHRydWUsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjBiMDdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc05hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNGFjXCIpLFxuICAgIGdldFZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM2OThcIik7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjBjZmJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNjMTJcIik7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwZDI0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHt2YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjNlXCIpLFxuICAgIHN0dWJGYWxzZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwN2M3XCIpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIHRydWUgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjJlNFwiKShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMGRhNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0ZmJcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaSwgXCIudmMtbmF2LWFycm93e2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtsaW5lLWhlaWdodDp2YXIoLS1sZWFkaW5nLXNudWcpO2JvcmRlci13aWR0aDoycHg7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6dmFyKC0tcm91bmRlZCl9LnZjLW5hdi1hcnJvdy5pcy1sZWZ0e21hcmdpbi1yaWdodDphdXRvfS52Yy1uYXYtYXJyb3cuaXMtcmlnaHR7bWFyZ2luLWxlZnQ6YXV0b30udmMtbmF2LWFycm93OmhvdmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZ3JheS05MDApfS52Yy1uYXYtYXJyb3c6Zm9jdXN7Ym9yZGVyLWNvbG9yOnZhcigtLWFjY2VudC02MDApfS52Yy1uYXYtdGl0bGV7Y29sb3I6dmFyKC0tYWNjZW50LTEwMCk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC1ib2xkKTtsaW5lLWhlaWdodDp2YXIoLS1sZWFkaW5nLXNudWcpO3BhZGRpbmc6NHB4IDhweDtib3JkZXItcmFkaXVzOnZhcigtLXJvdW5kZWQpO2JvcmRlci13aWR0aDoycHg7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50fS52Yy1uYXYtdGl0bGU6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1ncmF5LTkwMCl9LnZjLW5hdi10aXRsZTpmb2N1c3tib3JkZXItY29sb3I6dmFyKC0tYWNjZW50LTYwMCl9LnZjLW5hdi1pdGVte3dpZHRoOjQ4cHg7dGV4dC1hbGlnbjpjZW50ZXI7bGluZS1oZWlnaHQ6dmFyKC0tbGVhZGluZy1zbnVnKTtmb250LXdlaWdodDp2YXIoLS1mb250LXNlbWlib2xkKTtwYWRkaW5nOjRweCAwO2N1cnNvcjpwb2ludGVyO2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItd2lkdGg6MnB4O2JvcmRlci1yYWRpdXM6dmFyKC0tcm91bmRlZCl9LnZjLW5hdi1pdGVtOmhvdmVye2NvbG9yOnZhcigtLXdoaXRlKTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWdyYXktOTAwKTtib3gtc2hhZG93OnZhcigtLXNoYWRvdy1pbm5lcil9LnZjLW5hdi1pdGVtOmZvY3Vze2JvcmRlci1jb2xvcjp2YXIoLS1hY2NlbnQtNjAwKX0udmMtbmF2LWl0ZW0uaXMtYWN0aXZle2NvbG9yOnZhcigtLWFjY2VudC05MDApO2JhY2tncm91bmQ6dmFyKC0tYWNjZW50LTEwMCk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC1ib2xkKTtib3gtc2hhZG93OnZhcigtLXNoYWRvdyl9LnZjLW5hdi1pdGVtLmlzLWFjdGl2ZSwudmMtbmF2LWl0ZW0uaXMtaW5hY3RpdmV7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50fS52Yy1uYXYtaXRlbTppcy1pbmFjdGl2ZS1jdXJyZW50e2NvbG9yOnZhcigtLWFjY2VudC0xMDApO2ZvbnQtd2VpZ2h0OnZhcigtLWJvbGQpO2JvcmRlci1jb2xvcjp2YXIoLS1hY2NlbnQtMTAwKX0udmMtbmF2LWl0ZW0uaXMtZGlzYWJsZWR7b3BhY2l0eTouMjU7cG9pbnRlci1ldmVudHM6bm9uZX0udmMtaXMtZGFyayAudmMtbmF2LXRpdGxle2NvbG9yOnZhcigtLWdyYXktOTAwKX0udmMtaXMtZGFyayAudmMtbmF2LXRpdGxlOmhvdmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZ3JheS0yMDApfS52Yy1pcy1kYXJrIC52Yy1uYXYtdGl0bGU6Zm9jdXN7Ym9yZGVyLWNvbG9yOnZhcigtLWFjY2VudC00MDApfS52Yy1pcy1kYXJrIC52Yy1uYXYtYXJyb3c6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1ncmF5LTIwMCl9LnZjLWlzLWRhcmsgLnZjLW5hdi1hcnJvdzpmb2N1c3tib3JkZXItY29sb3I6dmFyKC0tYWNjZW50LTQwMCl9LnZjLWlzLWRhcmsgLnZjLW5hdi1pdGVtOmhvdmVye2NvbG9yOnZhcigtLWdyYXktOTAwKTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWdyYXktMjAwKTtib3gtc2hhZG93Om5vbmV9LnZjLWlzLWRhcmsgLnZjLW5hdi1pdGVtOmZvY3Vze2JvcmRlci1jb2xvcjp2YXIoLS1hY2NlbnQtNDAwKX0udmMtaXMtZGFyayAudmMtbmF2LWl0ZW0uaXMtYWN0aXZle2NvbG9yOnZhcigtLXdoaXRlKTtiYWNrZ3JvdW5kOnZhcigtLWFjY2VudC01MDApfS52Yy1pcy1kYXJrIC52Yy1uYXYtaXRlbS5pcy1pbmFjdGl2ZS1jdXJyZW50e2NvbG9yOnZhcigtLWFjY2VudC02MDApO2JvcmRlci1jb2xvcjp2YXIoLS1hY2NlbnQtNTAwKX1cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjBmMGZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGVlYlwiKSxcbiAgICBrZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTkzNFwiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwZjVjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE1OWFcIik7XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gKiBgcGF0aGAgY3JlYXRpb24uXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICogLy8gPT4gNFxuICpcbiAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAqIC8vID0+IDVcbiAqL1xuZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMGY2MlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE5OTdcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ5OWVcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjJmMzY5MjM0XCIsIGNvbnRlbnQsIHRydWUsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjEwMGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlkZW50aXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNkOWRcIiksXG4gICAgb3ZlclJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjI4NlwiKSxcbiAgICBzZXRUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjMWM5XCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxMDQxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3B5T2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhlZWJcIiksXG4gICAgZ2V0U3ltYm9sc0luID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImEwMjlcIik7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjEyOTBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxMzEwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxMzY4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3JlSnNEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhMDNcIik7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMTQ5N1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0ZmJcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaSwgXCIudmMtc3ZnLWljb25bZGF0YS12LTE5YjZjZjc4XXtkaXNwbGF5OmlubGluZS1ibG9jaztzdHJva2U6Y3VycmVudENvbG9yO3N0cm9rZS13aWR0aDowfS52Yy1zdmctaWNvbiBwYXRoW2RhdGEtdi0xOWI2Y2Y3OF17ZmlsbDpjdXJyZW50Q29sb3J9XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxNGMzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM2YjZcIik7XG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MjYzXCIpO1xuXG4vLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChjbGFzc29mKFIpICE9PSAnUmVnRXhwJykge1xuICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4cEV4ZWMuY2FsbChSLCBTKTtcbn07XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxNTlhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NpZ25WYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMmIzXCIpLFxuICAgIGNhc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyZTRcIiksXG4gICAgaXNJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjMDk4XCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFhOGNcIiksXG4gICAgdG9LZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjRkNlwiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxNWYzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlUGlja0J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg5ZDlcIiksXG4gICAgaGFzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYwNFwiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjE4MzhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc0VxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMwNWZcIiksXG4gICAgZ2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjliMDJcIiksXG4gICAgaGFzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYwNFwiKSxcbiAgICBpc0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjA4XCIpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwOGNjXCIpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIwZWNcIiksXG4gICAgdG9LZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjRkNlwiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMThkOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbWVtb2l6ZUNhcHBlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyMzRkXCIpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjFhMmRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0MmEyXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMzEwXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWE4Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxYjIzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmUxZFwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDk5ZVwiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiYjI3M2JhMDRcIiwgY29udGVudCwgdHJ1ZSwge1wic291cmNlTWFwXCI6ZmFsc2UsXCJzaGFkb3dNb2RlXCI6ZmFsc2V9KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWJhY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldEFsbEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2QxZlwiKSxcbiAgICBnZXRTeW1ib2xzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTAyOVwiKSxcbiAgICBrZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTkzNFwiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWJlNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDY2XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjFjM2NcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZTY5XCIpLFxuICAgIFVpbnQ4QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjQ3NFwiKSxcbiAgICBlcSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5NjM4XCIpLFxuICAgIGVxdWFsQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImEyYmVcIiksXG4gICAgbWFwVG9BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlZGZhXCIpLFxuICAgIHNldFRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWM0MVwiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjFjZWNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE5hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwYjA3XCIpLFxuICAgIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmIzZVwiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjFkODBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWVmY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWZjOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TWFwRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0MjQ1XCIpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjBlY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjI4NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXBwbHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODVlM1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyMzRkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtZW1vaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUzODBcIik7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjIzYTVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OLnBhcnNlKFwie1xcXCJtYXhTd2lwZVRpbWVcXFwiOjMwMCxcXFwibWluSG9yaXpvbnRhbFN3aXBlRGlzdGFuY2VcXFwiOjYwLFxcXCJtYXhWZXJ0aWNhbFN3aXBlRGlzdGFuY2VcXFwiOjgwfVwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjNjYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE2OTFcIik7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyM2U3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGE4NFwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDZjZlwiKS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MTEyXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZlZWJcIik7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlNGVcIik7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlODkzXCIpO1xudmFyIGlzRm9yY2VkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk0Y2FcIik7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNDExXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlTWVyZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjkwOVwiKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZWMxXCIpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAqXG4gKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAqL1xudmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlV2l0aDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNDFjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2E4NFwiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ODM5XCIpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNDJlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjcyYWZcIiksXG4gICAga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlYzY5XCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNDc0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiM2VcIik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNDc4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRNYXBEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQyNDVcIik7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNGZiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjI1MjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG5hdGl2ZUNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MDQ0XCIpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjI1M2NcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzcyOVwiKSxcbiAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTMxMFwiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjU1ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU5MDVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ5OWVcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjRkNGJkOGQ5XCIsIGNvbnRlbnQsIHRydWUsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjI1OTNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VQaWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE1ZjNcIiksXG4gICAgZmxhdFJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzZjZlwiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjZlOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjhjOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjlmM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyYjEwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMmIyN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfUG9wb3ZlclJvd192dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF80OTc1ZDY5ZV9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTg0OVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfUG9wb3ZlclJvd192dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF80OTc1ZDY5ZV9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX1BvcG92ZXJSb3dfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfNDk3NWQ2OWVfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19Qb3BvdmVyUm93X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzQ5NzVkNjllX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpOyBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMmIzZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZnJlZUdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1ODVhXCIpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyZDdjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyZGNiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBvdmVyQXJnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkxZTlcIik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyZTFkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjRmYlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcIi52Yy1kYXlbZGF0YS12LWExMTEwYjQwXXtwb3NpdGlvbjpyZWxhdGl2ZTttaW4taGVpZ2h0OjI4cHg7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt6LWluZGV4OjF9LnZjLWRheS5pcy1ub3QtaW4tbW9udGggKltkYXRhLXYtYTExMTBiNDBde29wYWNpdHk6MDtwb2ludGVyLWV2ZW50czpub25lfS52Yy1kYXktbGF5ZXJbZGF0YS12LWExMTEwYjQwXXtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7cmlnaHQ6MDt0b3A6MDtib3R0b206MDtwb2ludGVyLWV2ZW50czpub25lfS52Yy1kYXktYm94LWNlbnRlci1jZW50ZXJbZGF0YS12LWExMTEwYjQwXXtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7aGVpZ2h0OjEwMCU7dHJhbnNmb3JtLW9yaWdpbjo1MCUgNTAlfS52Yy1kYXktYm94LWxlZnQtY2VudGVyW2RhdGEtdi1hMTExMGI0MF17ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O2FsaWduLWl0ZW1zOmNlbnRlcjtoZWlnaHQ6MTAwJTt0cmFuc2Zvcm0tb3JpZ2luOjAgNTAlfS52Yy1kYXktYm94LXJpZ2h0LWNlbnRlcltkYXRhLXYtYTExMTBiNDBde2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7YWxpZ24taXRlbXM6Y2VudGVyO2hlaWdodDoxMDAlO3RyYW5zZm9ybS1vcmlnaW46MTAwJSA1MCV9LnZjLWRheS1ib3gtY2VudGVyLWJvdHRvbVtkYXRhLXYtYTExMTBiNDBde2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmZsZXgtZW5kfS52Yy1kYXktY29udGVudFtkYXRhLXYtYTExMTBiNDBde2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LXNpemU6dmFyKC0tdGV4dC1zbSk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC1tZWRpdW0pO3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHg7bWFyZ2luOjEuNnB4IGF1dG87Ym9yZGVyLXJhZGl1czp2YXIoLS1yb3VuZGVkLWZ1bGwpOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2N1cnNvcjpwb2ludGVyfS52Yy1kYXktY29udGVudFtkYXRhLXYtYTExMTBiNDBdOmhvdmVye2JhY2tncm91bmQtY29sb3I6cmdiYSgyMDQsMjE0LDIyNCwuMyl9LnZjLWRheS1jb250ZW50W2RhdGEtdi1hMTExMGI0MF06Zm9jdXN7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC1ib2xkKTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjA0LDIxNCwyMjQsLjQpfS52Yy1kYXktY29udGVudC5pcy1kaXNhYmxlZFtkYXRhLXYtYTExMTBiNDBde2NvbG9yOnZhcigtLWdyYXktNDAwKX0udmMtaXMtZGFyayAudmMtZGF5LWNvbnRlbnRbZGF0YS12LWExMTEwYjQwXTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMTE0LDEyOSwxNTEsLjMpfS52Yy1pcy1kYXJrIC52Yy1kYXktY29udGVudFtkYXRhLXYtYTExMTBiNDBdOmZvY3Vze2JhY2tncm91bmQtY29sb3I6cmdiYSgxMTQsMTI5LDE1MSwuNCl9LnZjLWlzLWRhcmsgLnZjLWRheS1jb250ZW50LmlzLWRpc2FibGVkW2RhdGEtdi1hMTExMGI0MF17Y29sb3I6dmFyKC0tZ3JheS02MDApfS52Yy1oaWdobGlnaHRzW2RhdGEtdi1hMTExMGI0MF17b3ZlcmZsb3c6aGlkZGVuO3BvaW50ZXItZXZlbnRzOm5vbmU7ei1pbmRleDotMX0udmMtaGlnaGxpZ2h0W2RhdGEtdi1hMTExMGI0MF17d2lkdGg6MjhweDtoZWlnaHQ6MjhweH0udmMtaGlnaGxpZ2h0LnZjLWhpZ2hsaWdodC1iYXNlLXN0YXJ0W2RhdGEtdi1hMTExMGI0MF17d2lkdGg6NTAlIWltcG9ydGFudDtib3JkZXItcmFkaXVzOjAhaW1wb3J0YW50O2JvcmRlci1yaWdodC13aWR0aDowIWltcG9ydGFudH0udmMtaGlnaGxpZ2h0LnZjLWhpZ2hsaWdodC1iYXNlLWVuZFtkYXRhLXYtYTExMTBiNDBde3dpZHRoOjUwJSFpbXBvcnRhbnQ7Ym9yZGVyLXJhZGl1czowIWltcG9ydGFudDtib3JkZXItbGVmdC13aWR0aDowIWltcG9ydGFudH0udmMtaGlnaGxpZ2h0LnZjLWhpZ2hsaWdodC1iYXNlLW1pZGRsZVtkYXRhLXYtYTExMTBiNDBde3dpZHRoOjEwMCU7Ym9yZGVyLXJhZGl1czowIWltcG9ydGFudDtib3JkZXItbGVmdC13aWR0aDowIWltcG9ydGFudDtib3JkZXItcmlnaHQtd2lkdGg6MCFpbXBvcnRhbnQ7bWFyZ2luOjAgLTFweH0udmMtZG90c1tkYXRhLXYtYTExMTBiNDBde2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0udmMtZG90W2RhdGEtdi1hMTExMGI0MF17d2lkdGg6NXB4O2hlaWdodDo1cHg7Ym9yZGVyLXJhZGl1czo1MCU7dHJhbnNpdGlvbjphbGwgdmFyKC0tZGF5LWNvbnRlbnQtdHJhbnNpdGlvbi10aW1lKX0udmMtZG90W2RhdGEtdi1hMTExMGI0MF06bm90KDpsYXN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6M3B4fS52Yy1iYXJzW2RhdGEtdi1hMTExMGI0MF17ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O2FsaWduLWl0ZW1zOmNlbnRlcjt3aWR0aDo3NSV9LnZjLWJhcltkYXRhLXYtYTExMTBiNDBde2ZsZXgtZ3JvdzoxO2hlaWdodDozcHg7dHJhbnNpdGlvbjphbGwgdmFyKC0tZGF5LWNvbnRlbnQtdHJhbnNpdGlvbi10aW1lKX1cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJlYzFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VSZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjEwMGVcIiksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWFmZlwiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyZmNjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzMDkyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheVNvbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDI4NFwiKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYmFkZlwiKSxcbiAgICBiYXNlU29tZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNjFkXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjc0N1wiKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YWZmXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb21lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjMwYzlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTUyMFwiKSxcbiAgICBpc0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiMjE4XCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzMmIzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODcyYVwiKSxcbiAgICBlcSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5NjM4XCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjMyZjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5RmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJkN2NcIiksXG4gICAgc3R1YkFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQzMjdcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM0YWNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTUyMFwiKSxcbiAgICBpc01hc2tlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMzY4XCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFhOGNcIiksXG4gICAgdG9Tb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGM1N1wiKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzYxZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDhhMFwiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgcmV0dXJuICFyZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gISFyZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNvbWU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzY5OFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzNzI5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWU2OVwiKSxcbiAgICBnZXRSYXdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDBmZFwiKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyOWYzXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM3ZThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWJmMlwiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4MjVhXCIpO1xudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGY3NVwiKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgUHJvcGVydGllc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM4MThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN0YWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdlNjRcIiksXG4gICAgYXJyYXlFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgwNTdcIiksXG4gICAgYXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzJiM1wiKSxcbiAgICBiYXNlQXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjViMDFcIiksXG4gICAgYmFzZUFzc2lnbkluID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBmMGZcIiksXG4gICAgY2xvbmVCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTUzOFwiKSxcbiAgICBjb3B5QXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDM1OVwiKSxcbiAgICBjb3B5U3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NGViXCIpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTA0MVwiKSxcbiAgICBnZXRBbGxLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE5OTRcIiksXG4gICAgZ2V0QWxsS2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFiYWNcIiksXG4gICAgZ2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQyYTJcIiksXG4gICAgaW5pdENsb25lQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzg3Y1wiKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjMmI2XCIpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYTIxXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjc0N1wiKSxcbiAgICBpc0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwZDI0XCIpLFxuICAgIGlzTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNjNDVcIiksXG4gICAgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWE4Y1wiKSxcbiAgICBpc1NldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkN2VlXCIpLFxuICAgIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWM2OVwiKSxcbiAgICBrZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTkzNFwiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM4NTJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTZmM1wiKSxcbiAgICBoYXNQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyYzBcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG90aGVyLCAnYScpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzOGVhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19DYWxlbmRhckRheV92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF9hMTExMGI0MF9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWIyM1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfQ2FsZW5kYXJEYXlfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfYTExMTBiNDBfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19DYWxlbmRhckRheV92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF9hMTExMGI0MF9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogdW51c2VkIGhhcm1vbnkgcmVleHBvcnQgKiAqL1xuIC8qIHVudXNlZCBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBfdW51c2VkX3dlYnBhY2tfZGVmYXVsdF9leHBvcnQgPSAoX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0NhbGVuZGFyRGF5X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkX2ExMTEwYjQwX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpOyBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzlmZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBiMDdcIiksXG4gICAgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjNlXCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiM2I0YVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBiMDdcIik7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjNiYjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwOGNjXCIpLFxuICAgIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWM2OVwiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjNiYmVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2MWRcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpICYmIGl0ICE9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiICsgU3RyaW5nKGl0KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjNjNTVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0NhbGVuZGFyTmF2X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfcG9zdGNzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlOTY5XCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19DYWxlbmRhck5hdl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Bvc3Rjc3NfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0NhbGVuZGFyTmF2X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfcG9zdGNzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiB1bnVzZWQgaGFybW9ueSByZWV4cG9ydCAqICovXG4gLyogdW51c2VkIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIF91bnVzZWRfd2VicGFja19kZWZhdWx0X2V4cG9ydCA9IChfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfQ2FsZW5kYXJOYXZfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19wb3N0Y3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7IFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzZWUyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGM4Y1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDk5ZVwiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiMTNkNDFhZjVcIiwgY29udGVudCwgdHJ1ZSwge1wic291cmNlTWFwXCI6ZmFsc2UsXCJzaGFkb3dNb2RlXCI6ZmFsc2V9KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiM2VlYVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzk0OFwiKSxcbiAgICBiYXNlQ2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzgxOFwiKSxcbiAgICBiYXNlVW5zZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGJiNVwiKSxcbiAgICBjYXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMmU0XCIpLFxuICAgIGNvcHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGVlYlwiKSxcbiAgICBjdXN0b21PbWl0Q2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTBlN1wiKSxcbiAgICBmbGF0UmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNmNmXCIpLFxuICAgIGdldEFsbEtleXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYmFjXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2InOiAnMicgfVxuICovXG52YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSk7XG4gIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gb21pdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzZjg0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcHBseSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NWUzXCIpLFxuICAgIGJhc2VSZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjEwMGVcIiksXG4gICAgY3VzdG9tRGVmYXVsdHNNZXJnZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMDMxXCIpLFxuICAgIG1lcmdlV2l0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNDExXCIpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMTAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmRlZmF1bHRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAqL1xudmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0c0RlZXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiM2Y4Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQxYzNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFhOGNcIiksXG4gICAgaXNQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWFjNVwiKSxcbiAgICBuYXRpdmVLZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWM4Y1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQyNDVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzS2V5YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMjkwXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0Mjg0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQyOGZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0MmEyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNWE3XCIpLFxuICAgIE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3OWJjXCIpLFxuICAgIFByb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWNlY1wiKSxcbiAgICBTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzg2OVwiKSxcbiAgICBXZWFrTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM5ZmZcIiksXG4gICAgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNzI5XCIpLFxuICAgIHRvU291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRjNTdcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQzNTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ0MTZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0NGFkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzZiNlwiKTtcblxudmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0NGQyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2M3M1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YmYyXCIpO1xuXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ4ODlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfNl9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0NhbGVuZGFyUGFuZV92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMV9sYW5nX2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkZjllXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfNl9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzZfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19DYWxlbmRhclBhbmVfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzFfbGFuZ19jc3NfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfNl9vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0NhbGVuZGFyUGFuZV92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMV9sYW5nX2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiB1bnVzZWQgaGFybW9ueSByZWV4cG9ydCAqICovXG4gLyogdW51c2VkIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIF91bnVzZWRfd2VicGFja19kZWZhdWx0X2V4cG9ydCA9IChfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl82X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfNl9vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfNl9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfQ2FsZW5kYXJQYW5lX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8xX2xhbmdfY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7IFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0OGEwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRm9yT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0MmVcIiksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTUwYVwiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDkzMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHJldHVybiAhU3RyaW5nKFN5bWJvbCgpKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ5OWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gYWRkU3R5bGVzQ2xpZW50OyB9KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxuXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIG9wdGlvbnMgPSBudWxsXG52YXIgc3NySWRLZXkgPSAnZGF0YS12dWUtc3NyLWlkJ1xuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNDbGllbnQgKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uLCBfb3B0aW9ucykge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbJyArIHNzcklkS2V5ICsgJ349XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG4gIGlmIChvcHRpb25zLnNzcklkKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShzc3JJZEtleSwgb2JqLmlkKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDlmNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYwNDRcIik7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0YmI1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjYXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMmU0XCIpLFxuICAgIGxhc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDQxNlwiKSxcbiAgICBwYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODI5NlwiKSxcbiAgICB0b0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNGQ2XCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuc2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjRjZmVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVW5kZWZpbmVkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjRkNjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYzZhXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUwYzRcIik7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzY2JcIik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjRkOGNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VGbGF0dGVuID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjNjlcIik7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNGY1MFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNzYwXCIpLFxuICAgIGNsb25lQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU1MzhcIiksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM4ZmVcIiksXG4gICAgY29weUFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQzNTlcIiksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZhMjFcIiksXG4gICAgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDM3MFwiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY3NDdcIiksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGNiZVwiKSxcbiAgICBpc0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwZDI0XCIpLFxuICAgIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTUyMFwiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYThjXCIpLFxuICAgIGlzUGxhaW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjBlZFwiKSxcbiAgICBpc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzNhY1wiKSxcbiAgICBzYWZlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhhZGJcIiksXG4gICAgdG9QbGFpbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4ZGUyXCIpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTAxZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNzI5XCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMzEwXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTBjNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE2OTFcIik7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1MGQ4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUxMzVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUzMTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNzg0XCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgyNWFcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2IwYlwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MGM0XCIpO1xudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNjkxXCIpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWQ4MFwiKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGFhNVwiKTtcbnZhciByZWdFeHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE0YzNcIik7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJidgXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJidgXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoUkVQTEFDRSwgbmF0aXZlUmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlLCByZWFzb24pIHtcbiAgdmFyIFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFID0gcmVhc29uLlJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFO1xuICB2YXIgUkVQTEFDRV9LRUVQU18kMCA9IHJlYXNvbi5SRVBMQUNFX0tFRVBTXyQwO1xuICB2YXIgVU5TQUZFX1NVQlNUSVRVVEUgPSBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA/ICckJyA6ICckMCc7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciByZXBsYWNlciA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgICAgcmV0dXJuIHJlcGxhY2VyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXBsYWNlci5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgIDogbmF0aXZlUmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgaWYgKFxuICAgICAgICAoIVJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFICYmIFJFUExBQ0VfS0VFUFNfJDApIHx8XG4gICAgICAgICh0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnc3RyaW5nJyAmJiByZXBsYWNlVmFsdWUuaW5kZXhPZihVTlNBRkVfU1VCU1RJVFVURSkgPT09IC0xKVxuICAgICAgKSB7XG4gICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcblxuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuXG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcblxuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1heChtaW4odG9JbnRlZ2VyKHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICAgIHZhciBjYXB0dXJlcyA9IFtdO1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcbiAgICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG4gICAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXCJkb2Vzbid0IHdvcmtcIiBpbiBzYWZhcmkgOSBhbmRcbiAgICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIGNhcHR1cmVzLnB1c2gobWF5YmVUb1N0cmluZyhyZXN1bHRbal0pKTtcbiAgICAgICAgdmFyIG5hbWVkQ2FwdHVyZXMgPSByZXN1bHQuZ3JvdXBzO1xuICAgICAgICBpZiAoZnVuY3Rpb25hbFJlcGxhY2UpIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZXJBcmdzID0gW21hdGNoZWRdLmNvbmNhdChjYXB0dXJlcywgcG9zaXRpb24sIFMpO1xuICAgICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHJlcGxhY2VyQXJncy5wdXNoKG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IFN0cmluZyhyZXBsYWNlVmFsdWUuYXBwbHkodW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbikgKyByZXBsYWNlbWVudDtcbiAgICAgICAgICBuZXh0U291cmNlUG9zaXRpb24gPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0ZWRSZXN1bHQgKyBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbik7XG4gICAgfVxuICBdO1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVwbGFjZS5jYWxsKHJlcGxhY2VtZW50LCBzeW1ib2xzLCBmdW5jdGlvbiAobWF0Y2gsIGNoKSB7XG4gICAgICB2YXIgY2FwdHVyZTtcbiAgICAgIHN3aXRjaCAoY2guY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJyQnOiByZXR1cm4gJyQnO1xuICAgICAgICBjYXNlICcmJzogcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgIGNhc2UgJ2AnOiByZXR1cm4gc3RyLnNsaWNlKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHN0ci5zbGljZSh0YWlsUG9zKTtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbY2guc2xpY2UoMSwgLTEpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gXFxkXFxkP1xuICAgICAgICAgIHZhciBuID0gK2NoO1xuICAgICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgaWYgKG4gPiBtKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZsb29yKG4gLyAxMCk7XG4gICAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgaWYgKGYgPD0gbSkgcmV0dXJuIGNhcHR1cmVzW2YgLSAxXSA9PT0gdW5kZWZpbmVkID8gY2guY2hhckF0KDEpIDogY2FwdHVyZXNbZiAtIDFdICsgY2guY2hhckF0KDEpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcbiAgICB9KTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTRlYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29weU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4ZWViXCIpLFxuICAgIGdldFN5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzJmNFwiKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjU1YTNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1NjkyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM0MzBcIik7XG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzZjZFwiKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjYuNScsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjU2ZWZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDA2NlwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0MWNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc0MThcIik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODI1YVwiKTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTdhNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgb3ZlckFyZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MWU5XCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1ODQ5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjgwM1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDk5ZVwiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiMGE5NzYzYTdcIiwgY29udGVudCwgdHJ1ZSwge1wic291cmNlTWFwXCI6ZmFsc2UsXCJzaGFkb3dNb2RlXCI6ZmFsc2V9KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTg1YVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyhcImM4YmFcIikpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1OTA1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjRmYlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcIi5ub25lLWVudGVyLWFjdGl2ZVtkYXRhLXYtODQ2NjU5MmVdLC5ub25lLWxlYXZlLWFjdGl2ZVtkYXRhLXYtODQ2NjU5MmVde3RyYW5zaXRpb24tZHVyYXRpb246MHN9LmZhZGUtZW50ZXItYWN0aXZlW2RhdGEtdi04NDY2NTkyZV0sLmZhZGUtbGVhdmUtYWN0aXZlW2RhdGEtdi04NDY2NTkyZV0sLnNsaWRlLWRvd24tZW50ZXItYWN0aXZlW2RhdGEtdi04NDY2NTkyZV0sLnNsaWRlLWRvd24tbGVhdmUtYWN0aXZlW2RhdGEtdi04NDY2NTkyZV0sLnNsaWRlLWxlZnQtZW50ZXItYWN0aXZlW2RhdGEtdi04NDY2NTkyZV0sLnNsaWRlLWxlZnQtbGVhdmUtYWN0aXZlW2RhdGEtdi04NDY2NTkyZV0sLnNsaWRlLXJpZ2h0LWVudGVyLWFjdGl2ZVtkYXRhLXYtODQ2NjU5MmVdLC5zbGlkZS1yaWdodC1sZWF2ZS1hY3RpdmVbZGF0YS12LTg0NjY1OTJlXSwuc2xpZGUtdXAtZW50ZXItYWN0aXZlW2RhdGEtdi04NDY2NTkyZV0sLnNsaWRlLXVwLWxlYXZlLWFjdGl2ZVtkYXRhLXYtODQ2NjU5MmVde3RyYW5zaXRpb246dHJhbnNmb3JtIHZhcigtLXNsaWRlLWR1cmF0aW9uKSB2YXIoLS1zbGlkZS10aW1pbmcpLG9wYWNpdHkgdmFyKC0tc2xpZGUtZHVyYXRpb24pIHZhcigtLXNsaWRlLXRpbWluZyk7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbn0uZmFkZS1sZWF2ZS1hY3RpdmVbZGF0YS12LTg0NjY1OTJlXSwubm9uZS1sZWF2ZS1hY3RpdmVbZGF0YS12LTg0NjY1OTJlXSwuc2xpZGUtZG93bi1sZWF2ZS1hY3RpdmVbZGF0YS12LTg0NjY1OTJlXSwuc2xpZGUtbGVmdC1sZWF2ZS1hY3RpdmVbZGF0YS12LTg0NjY1OTJlXSwuc2xpZGUtcmlnaHQtbGVhdmUtYWN0aXZlW2RhdGEtdi04NDY2NTkyZV0sLnNsaWRlLXVwLWxlYXZlLWFjdGl2ZVtkYXRhLXYtODQ2NjU5MmVde3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCV9LmZhZGUtZW50ZXJbZGF0YS12LTg0NjY1OTJlXSwuZmFkZS1sZWF2ZS10b1tkYXRhLXYtODQ2NjU5MmVdLC5ub25lLWVudGVyW2RhdGEtdi04NDY2NTkyZV0sLm5vbmUtbGVhdmUtdG9bZGF0YS12LTg0NjY1OTJlXSwuc2xpZGUtZG93bi1lbnRlcltkYXRhLXYtODQ2NjU5MmVdLC5zbGlkZS1kb3duLWxlYXZlLXRvW2RhdGEtdi04NDY2NTkyZV0sLnNsaWRlLWxlZnQtZW50ZXJbZGF0YS12LTg0NjY1OTJlXSwuc2xpZGUtbGVmdC1sZWF2ZS10b1tkYXRhLXYtODQ2NjU5MmVdLC5zbGlkZS1yaWdodC1lbnRlcltkYXRhLXYtODQ2NjU5MmVdLC5zbGlkZS1yaWdodC1sZWF2ZS10b1tkYXRhLXYtODQ2NjU5MmVdLC5zbGlkZS11cC1lbnRlcltkYXRhLXYtODQ2NjU5MmVdLC5zbGlkZS11cC1sZWF2ZS10b1tkYXRhLXYtODQ2NjU5MmVde29wYWNpdHk6MH0uc2xpZGUtbGVmdC1lbnRlcltkYXRhLXYtODQ2NjU5MmVdLC5zbGlkZS1yaWdodC1sZWF2ZS10b1tkYXRhLXYtODQ2NjU5MmVde3RyYW5zZm9ybTp0cmFuc2xhdGVYKHZhcigtLXNsaWRlLXRyYW5zbGF0ZSkpfS5zbGlkZS1sZWZ0LWxlYXZlLXRvW2RhdGEtdi04NDY2NTkyZV0sLnNsaWRlLXJpZ2h0LWVudGVyW2RhdGEtdi04NDY2NTkyZV17dHJhbnNmb3JtOnRyYW5zbGF0ZVgoY2FsYyh2YXIoLS1zbGlkZS10cmFuc2xhdGUpKi0xKSl9LnNsaWRlLWRvd24tbGVhdmUtdG9bZGF0YS12LTg0NjY1OTJlXSwuc2xpZGUtdXAtZW50ZXJbZGF0YS12LTg0NjY1OTJlXXt0cmFuc2Zvcm06dHJhbnNsYXRlWSh2YXIoLS1zbGlkZS10cmFuc2xhdGUpKX0uc2xpZGUtZG93bi1lbnRlcltkYXRhLXYtODQ2NjU5MmVdLC5zbGlkZS11cC1sZWF2ZS10b1tkYXRhLXYtODQ2NjU5MmVde3RyYW5zZm9ybTp0cmFuc2xhdGVZKGNhbGModmFyKC0tc2xpZGUtdHJhbnNsYXRlKSotMSkpfVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWIwMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29weU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4ZWViXCIpLFxuICAgIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWM2OVwiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWM2OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlQdXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjA4N2RcIiksXG4gICAgaXNGbGF0dGVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwNjIxXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1YzZjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWQ4OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2xvbmVBcnJheUJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmOGFmXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWUyZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbGlzdENhY2hlQ2xlYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjhjOVwiKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlkNVwiKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjRjMFwiKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmJhNVwiKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjdjYVwiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2MDQ0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGIwN1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjBlZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNzI5XCIpLFxuICAgIGdldFByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZGNiXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMzEwXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2MjIwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNEYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImIxZDJcIiksXG4gICAgYmFzZVVuYXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImIwNDdcIiksXG4gICAgbm9kZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTlkM1wiKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNEYXRlID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNEYXRlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0RhdGUobmV3IERhdGUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRGF0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2MmU0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2NDJhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNNYXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5NjZmXCIpLFxuICAgIGdldE1hdGNoRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzYmI0XCIpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIwZWNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjY1NDdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNjkxXCIpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWQ4MFwiKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBjb2RlUG9pbnRBdCwgYXQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2NTZiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjYXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMmU0XCIpLFxuICAgIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY0ZDZcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2Njc5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM3MjlcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjEzMTBcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQm9vbGVhbihudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCb29sZWFuO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjY3NDdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2N2NhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2I1YVwiKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2OWQ1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2I1YVwiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2OWYzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBOQVRJVkVfV0VBS19NQVAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2Y5YVwiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGE4NFwiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NjFkXCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MTEyXCIpO1xudmFyIG9iamVjdEhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTM1XCIpO1xudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNzcyXCIpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAxMlwiKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVApIHtcbiAgdmFyIHN0b3JlID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHdtZ2V0ID0gc3RvcmUuZ2V0O1xuICB2YXIgd21oYXMgPSBzdG9yZS5oYXM7XG4gIHZhciB3bXNldCA9IHN0b3JlLnNldDtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQuY2FsbChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMuY2FsbChzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNmVlYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkxMTJcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxMzVcIik7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlNGVcIik7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4OTI1XCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlmM1wiKTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJyAmJiAhaGFzKHZhbHVlLCAnbmFtZScpKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodmFsdWUsICduYW1lJywga2V5KTtcbiAgICBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSkuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogJycpO1xuICB9XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICAgIHNpbXBsZSA9IHRydWU7XG4gIH1cbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNmY2Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjZmY2RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VUaW1lcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MGQ4XCIpLFxuICAgIGlzQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQzNzBcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NzQ3XCIpLFxuICAgIGlzQnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBkMjRcIiksXG4gICAgaXNJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjMDk4XCIpLFxuICAgIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3M2FjXCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3MmFmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjcmVhdGVCYXNlRm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk5Y2RcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjcyZjBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzJmNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllMmVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ5OWVcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjI5OTdmYmRmXCIsIGNvbnRlbnQsIHRydWUsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjczYWNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzQzZlwiKSxcbiAgICBiYXNlVW5hcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjA0N1wiKSxcbiAgICBub2RlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5OWQzXCIpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzQxOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjc0M2ZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzcyOVwiKSxcbiAgICBpc0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiMjE4XCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMzEwXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3NTMwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYThjXCIpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzZkZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlODZcIik7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3ODM5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjc5NDhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3OWJjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGIwN1wiKSxcbiAgICByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiM2VcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3YTQ4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBuYXRpdmVDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjA0NFwiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2IwYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxZDgwXCIpO1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3YjgzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtYXBDYWNoZUNsZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdjNjRcIiksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTNlZFwiKSxcbiAgICBtYXBDYWNoZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNDc4XCIpLFxuICAgIG1hcENhY2hlSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE1MjRcIiksXG4gICAgbWFwQ2FjaGVTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWZjOFwiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2I5N1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3RhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2U2NFwiKSxcbiAgICBlcXVhbEFycmF5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhMmJlXCIpLFxuICAgIGVxdWFsQnlUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWMzY1wiKSxcbiAgICBlcXVhbE9iamVjdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjFlNVwiKSxcbiAgICBnZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDJhMlwiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY3NDdcIiksXG4gICAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGQyNFwiKSxcbiAgICBpc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzNhY1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjdjNjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIEhhc2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTI0YlwiKSxcbiAgICBMaXN0Q2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWUyZVwiKSxcbiAgICBNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzliY1wiKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2M3M1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODI1YVwiKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM3ZThcIik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzgzOVwiKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMTJcIik7XG52YXIgaHRtbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYmU0XCIpO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYzEyXCIpO1xudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNzcyXCIpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG4gICAgYWN0aXZlWERvY3VtZW50ID0gZG9jdW1lbnQuZG9tYWluICYmIG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKTtcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3ZDFmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheVB1c2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDg3ZFwiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY3NDdcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3ZGQwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyM2U3XCIpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWVkM1wiKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMTYzXCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQyYmJcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDQ0ZVwiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTExMlwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ZWViXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNjIyXCIpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzQzMFwiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiM2Y4Y1wiKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFlOTNcIik7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjdlNjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1ZTJlXCIpLFxuICAgIHN0YWNrQ2xlYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWZiNlwiKSxcbiAgICBzdGFja0RlbGV0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZmNjXCIpLFxuICAgIHN0YWNrR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgwMmFcIiksXG4gICAgc3RhY2tIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTVhM1wiKSxcbiAgICBzdGFja1NldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDJjXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2VkMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3ZWZlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTi5wYXJzZShcIntcXFwidGl0bGVcXFwiOlxcXCJNTU1NIFlZWVlcXFwiLFxcXCJ3ZWVrZGF5c1xcXCI6XFxcIldcXFwiLFxcXCJuYXZNb250aHNcXFwiOlxcXCJNTU1cXFwiLFxcXCJpbnB1dFxcXCI6W1xcXCJMXFxcIixcXFwiWVlZWS1NTS1ERFxcXCIsXFxcIllZWVkvTU0vRERcXFwiXSxcXFwiZGF5UG9wb3ZlclxcXCI6XFxcIldXVywgTU1NIEQsIFlZWVlcXFwiLFxcXCJkYXRhXFxcIjpbXFxcIkxcXFwiLFxcXCJZWVlZLU1NLUREXFxcIixcXFwiWVlZWS9NTS9ERFxcXCJdLFxcXCJtb2RlbFxcXCI6XFxcImlzb1xcXCIsXFxcImlzb1xcXCI6XFxcIllZWVktTU0tRERUSEg6bW06c3NYWFhcXFwifVwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2Y5YVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4OTI1XCIpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlKFdlYWtNYXApKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4MDJhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4MDU3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODI1YVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYxZFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODI5NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NTZiXCIpLFxuICAgIGJhc2VTbGljZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjEwXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjgzODRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgfVxuICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xhbXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODNhYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODVhOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT04ucGFyc2UoXCJ7XFxcInNtXFxcIjpcXFwiNjQwcHhcXFwiLFxcXCJtZFxcXCI6XFxcIjc2OHB4XFxcIixcXFwibGdcXFwiOlxcXCIxMDI0cHhcXFwiLFxcXCJ4bFxcXCI6XFxcIjEyODBweFxcXCJ9XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4NWUzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4NjA0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSGFzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjZlOFwiKSxcbiAgICBoYXNQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyYzBcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4NjFkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjg3MmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjNiNGFcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjg5MjVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM2Y2RcIik7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmc7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAodHlwZW9mIHN0b3JlLmluc3BlY3RTb3VyY2UgIT0gJ2Z1bmN0aW9uJykge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4OWQ5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY1NmJcIiksXG4gICAgYmFzZVNldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxNTlhXCIpLFxuICAgIGNhc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyZTRcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOGFhNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNoYXJBdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NTQ3XCIpLmNoYXJBdDtcblxuLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOGFkYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjhiYmZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX184YmJmX187XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjhkYWRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxNDk3XCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTllXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCJlNTllNTcwY1wiLCBjb250ZW50LCB0cnVlLCB7XCJzb3VyY2VNYXBcIjpmYWxzZSxcInNoYWRvd01vZGVcIjpmYWxzZX0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4ZGUyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb3B5T2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhlZWJcIiksXG4gICAga2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk5MzRcIik7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BsYWluT2JqZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjhlMmVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNTQ3XCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTllXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCIzNDhkNzg1NVwiLCBjb250ZW50LCB0cnVlLCB7XCJzb3VyY2VNYXBcIjpmYWxzZSxcInNoYWRvd01vZGVcIjpmYWxzZX0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4ZWViXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NpZ25WYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMmIzXCIpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NzJhXCIpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkwZTNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkxMTJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWJmMlwiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWM2Y1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOTFlOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkyNjNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZWdleHBGbGFncyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZDZkXCIpO1xudmFyIHN0aWNreUhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWY3ZlwiKTtcblxudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7XG4vLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxuLy8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxudmFyIG5hdGl2ZVJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG5cbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvO1xuICB2YXIgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTEubGFzdEluZGV4ICE9PSAwIHx8IHJlMi5sYXN0SW5kZXggIT09IDA7XG59KSgpO1xuXG52YXIgVU5TVVBQT1JURURfWSA9IHN0aWNreUhlbHBlcnMuVU5TVVBQT1JURURfWSB8fCBzdGlja3lIZWxwZXJzLkJST0tFTl9DQVJFVDtcblxuLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQgfHwgVU5TVVBQT1JURURfWTtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG4gICAgdmFyIHN0aWNreSA9IFVOU1VQUE9SVEVEX1kgJiYgcmUuc3RpY2t5O1xuICAgIHZhciBmbGFncyA9IHJlZ2V4cEZsYWdzLmNhbGwocmUpO1xuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2U7XG4gICAgdmFyIGNoYXJzQWRkZWQgPSAwO1xuICAgIHZhciBzdHJDb3B5ID0gc3RyO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgZmxhZ3MgPSBmbGFncy5yZXBsYWNlKCd5JywgJycpO1xuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ2cnKSA9PT0gLTEpIHtcbiAgICAgICAgZmxhZ3MgKz0gJ2cnO1xuICAgICAgfVxuXG4gICAgICBzdHJDb3B5ID0gU3RyaW5nKHN0cikuc2xpY2UocmUubGFzdEluZGV4KTtcbiAgICAgIC8vIFN1cHBvcnQgYW5jaG9yZWQgc3RpY2t5IGJlaGF2aW9yLlxuICAgICAgaWYgKHJlLmxhc3RJbmRleCA+IDAgJiYgKCFyZS5tdWx0aWxpbmUgfHwgcmUubXVsdGlsaW5lICYmIHN0cltyZS5sYXN0SW5kZXggLSAxXSAhPT0gJ1xcbicpKSB7XG4gICAgICAgIHNvdXJjZSA9ICcoPzogJyArIHNvdXJjZSArICcpJztcbiAgICAgICAgc3RyQ29weSA9ICcgJyArIHN0ckNvcHk7XG4gICAgICAgIGNoYXJzQWRkZWQrKztcbiAgICAgIH1cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBzdHIgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14oPzonICsgc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgfVxuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcblxuICAgIG1hdGNoID0gbmF0aXZlRXhlYy5jYWxsKHN0aWNreSA/IHJlQ29weSA6IHJlLCBzdHJDb3B5KTtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaC5pbnB1dCA9IG1hdGNoLmlucHV0LnNsaWNlKGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaC5pbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcmUubGFzdEluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSByZS5sYXN0SW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZS5sYXN0SW5kZXggPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgbmF0aXZlUmVwbGFjZS5jYWxsKG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hlZEV4ZWM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOTNlZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TWFwRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0MjQ1XCIpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5NGNhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IHR5cGVvZiBkZXRlY3Rpb24gPT0gJ2Z1bmN0aW9uJyA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjk1MGFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMwYzlcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOTUyMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNzI5XCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFhOGNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5NWFlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlUmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMDBlXCIpLFxuICAgIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk2MzhcIiksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWFmZlwiKSxcbiAgICBrZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTkzNFwiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgIGxlbmd0aCA9IDE7XG4gIH1cblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjk2MzhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOTY2ZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3RhY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2U2NFwiKSxcbiAgICBiYXNlSXNFcXVhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjMDVmXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5NmYzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjk3ZDNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ4YTBcIiksXG4gICAgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzBjOVwiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWFwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjk5MzRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5TGlrZUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmZjZFwiKSxcbiAgICBiYXNlS2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQxYzNcIiksXG4gICAgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzBjOVwiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjk5Y2RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5OWQzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHt2YXIgZnJlZUdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1ODVhXCIpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIHRydWUgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYyZTRcIikobW9kdWxlKSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjlhZmZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk2MzhcIiksXG4gICAgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzBjOVwiKSxcbiAgICBpc0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMwOThcIiksXG4gICAgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWE4Y1wiKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjliMDJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjU2YlwiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5YjVmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjRmYlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcIi52Yy1ncmlkLWNvbnRhaW5lcltkYXRhLXYtNWU4MmU3ZWRde3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtc2hyaW5rOjE7ZGlzcGxheTpncmlkO292ZXJmbG93OmF1dG87LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2h9LnZjLWdyaWQtY2VsbFtkYXRhLXYtNWU4MmU3ZWRde2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn1cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjliZjJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzYWJcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGNmYlwiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4MjVhXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMwNGVcIik7XG5cbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5ZTJlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjRmYlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcIi52Yy1wYW5lLWNvbnRhaW5lcnt3aWR0aDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlfS52Yy1wYW5lLWNvbnRhaW5lci5pbi10cmFuc2l0aW9ue292ZXJmbG93OmhpZGRlbn0udmMtYXJyb3d7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3BvaW50ZXItZXZlbnRzOmF1dG87Y29sb3I6dmFyKC0tZ3JheS02MDApO2JvcmRlci13aWR0aDoycHg7Ym9yZGVyLXJhZGl1czp2YXIoLS1yb3VuZGVkKTtib3JkZXItY29sb3I6dHJhbnNwYXJlbnR9LnZjLWFycm93OmhvdmVye2JhY2tncm91bmQ6dmFyKC0tZ3JheS0yMDApfS52Yy1hcnJvdzpmb2N1c3tib3JkZXItY29sb3I6dmFyKC0tZ3JheS0zMDApfS52Yy1hcnJvdy5pcy1kaXNhYmxlZHtvcGFjaXR5Oi4yNTtwb2ludGVyLWV2ZW50czpub25lO2N1cnNvcjpub3QtYWxsb3dlZH0udmMtZGF5LXBvcG92ZXItY29udGFpbmVye2NvbG9yOnZhcigtLXdoaXRlKTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWdyYXktODAwKTtib3JkZXI6MXB4IHNvbGlkO2JvcmRlci1jb2xvcjp2YXIoLS1ncmF5LTcwMCk7Ym9yZGVyLXJhZGl1czp2YXIoLS1yb3VuZGVkKTtmb250LXNpemU6dmFyKC0tdGV4dC14cyk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC1tZWRpdW0pO3BhZGRpbmc6NHB4IDhweDtib3gtc2hhZG93OnZhcigtLXNoYWRvdyl9LnZjLWRheS1wb3BvdmVyLWhlYWRlcntmb250LXNpemU6dmFyKC0tdGV4dC14cyk7Y29sb3I6dmFyKC0tZ3JheS0zMDApO2ZvbnQtd2VpZ2h0OnZhcigtLWZvbnQtc2VtaWJvbGQpO3RleHQtYWxpZ246Y2VudGVyfS52Yy1hcnJvd3MtY29udGFpbmVye3dpZHRoOjEwMCU7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3BhZGRpbmc6OHB4IDEwcHg7cG9pbnRlci1ldmVudHM6bm9uZX0udmMtYXJyb3dzLWNvbnRhaW5lci50aXRsZS1sZWZ0e2p1c3RpZnktY29udGVudDpmbGV4LWVuZH0udmMtYXJyb3dzLWNvbnRhaW5lci50aXRsZS1yaWdodHtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydH0udmMtaXMtZGFyayAudmMtYXJyb3d7Y29sb3I6dmFyKC0td2hpdGUpfS52Yy1pcy1kYXJrIC52Yy1hcnJvdzpob3ZlcntiYWNrZ3JvdW5kOnZhcigtLWdyYXktODAwKX0udmMtaXMtZGFyayAudmMtYXJyb3c6Zm9jdXN7Ym9yZGVyLWNvbG9yOnZhcigtLWdyYXktNzAwKX0udmMtaXMtZGFyayAudmMtZGF5LXBvcG92ZXItY29udGFpbmVye2NvbG9yOnZhcigtLWdyYXktODAwKTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLXdoaXRlKTtib3JkZXItY29sb3I6dmFyKC0tZ3JheS0xMDApfS52Yy1pcy1kYXJrIC52Yy1kYXktcG9wb3Zlci1oZWFkZXJ7Y29sb3I6dmFyKC0tZ3JheS03MDApfVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWU2OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjNlXCIpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWU4M1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0ZmJcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaSwgXCIudmMtbmF2LXBvcG92ZXItY29udGFpbmVye2NvbG9yOnZhcigtLXdoaXRlKTtmb250LXNpemU6dmFyKC0tdGV4dC1zbSk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC1zZW1pYm9sZCk7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1ncmF5LTgwMCk7Ym9yZGVyOjFweCBzb2xpZDtib3JkZXItY29sb3I6dmFyKC0tZ3JheS03MDApO2JvcmRlci1yYWRpdXM6dmFyKC0tcm91bmRlZC1sZyk7cGFkZGluZzo0cHg7Ym94LXNoYWRvdzp2YXIoLS1zaGFkb3cpfS52Yy1pcy1kYXJrIC52Yy1uYXYtcG9wb3Zlci1jb250YWluZXJ7Y29sb3I6dmFyKC0tZ3JheS04MDApO2JhY2tncm91bmQtY29sb3I6dmFyKC0td2hpdGUpO2JvcmRlci1jb2xvcjp2YXIoLS1ncmF5LTEwMCl9XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5ZTg2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODcyYVwiKSxcbiAgICBiYXNlRm9yT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0MmVcIiksXG4gICAgYmFzZUl0ZXJhdGVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJhZGZcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gKiBAc2VlIF8ubWFwS2V5c1xuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICogfTtcbiAqXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFZhbHVlcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5ZWQzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWU5M1wiKS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2M3M1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWM2Y1wiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNDRlXCIpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzZjhjXCIpO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UsIHRydWUpO1xuICBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWY3ZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDAzOVwiKTtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCdhJywgJ3knKSAtPiAvYS95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3IsXG4vLyBzbyB3ZSB1c2UgYW4gaW50ZXJtZWRpYXRlIGZ1bmN0aW9uLlxuZnVuY3Rpb24gUkUocywgZikge1xuICByZXR1cm4gUmVnRXhwKHMsIGYpO1xufVxuXG5leHBvcnRzLlVOU1VQUE9SVEVEX1kgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG4gIHZhciByZSA9IFJFKCdhJywgJ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xufSk7XG5cbmV4cG9ydHMuQlJPS0VOX0NBUkVUID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NzM2ODdcbiAgdmFyIHJlID0gUkUoJ15yJywgJ2d5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdzdHInKSAhPSBudWxsO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYTAyOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlQdXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjA4N2RcIiksXG4gICAgZ2V0UHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJkY2JcIiksXG4gICAgZ2V0U3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMmY0XCIpLFxuICAgIHN0dWJBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMzI3XCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhMmJlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTZXRDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNjEyXCIpLFxuICAgIGFycmF5U29tZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0Mjg0XCIpLFxuICAgIGNhY2hlSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1ODRcIik7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhMmRiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWU2OVwiKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImEzZmRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5TWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5NDhcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9QYWlyc2AgYW5kIGBfLnRvUGFpcnNJbmAgd2hpY2ggY3JlYXRlcyBhbiBhcnJheVxuICogb2Yga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9QYWlycztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhNDU0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb25zdGFudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3MmYwXCIpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjNiNGFcIiksXG4gICAgaWRlbnRpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2Q5ZFwiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImE1MjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDI0NVwiKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhNTliXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBmaXJzdFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDFcbiAqXG4gKiBfLmhlYWQoW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGVhZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhNjkxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYFRvSW50ZWdlcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2ludGVnZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc05hTihhcmd1bWVudCA9ICthcmd1bWVudCkgPyAwIDogKGFyZ3VtZW50ID4gMCA/IGZsb29yIDogY2VpbCkoYXJndW1lbnQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhOTk0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0QWxsS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ZDFmXCIpLFxuICAgIGdldFN5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzJmNFwiKSxcbiAgICBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImVjNjlcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhOTk3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjRmYlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcIi52Yy1wYW5lW2RhdGEtdi0zNDkxYjI5MF17ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6c3RyZXRjaH0udmMtaG9yaXpvbnRhbC1kaXZpZGVyW2RhdGEtdi0zNDkxYjI5MF17YWxpZ24tc2VsZjpjZW50ZXJ9LnZjLWhlYWRlcltkYXRhLXYtMzQ5MWIyOTBde2ZsZXgtc2hyaW5rOjA7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOnN0cmV0Y2g7Y29sb3I6dmFyKC0tZ3JheS05MDApOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3BhZGRpbmc6MTBweCAxMHB4IDAgMTBweH0udmMtaGVhZGVyLmFsaWduLWxlZnRbZGF0YS12LTM0OTFiMjkwXXtvcmRlcjotMTtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydH0udmMtaGVhZGVyLmFsaWduLXJpZ2h0W2RhdGEtdi0zNDkxYjI5MF17b3JkZXI6MTtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9LnZjLXRpdGxlLWxheW91dFtkYXRhLXYtMzQ5MWIyOTBde2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtmbGV4LWdyb3c6MX0udmMtdGl0bGUtbGF5b3V0LmFsaWduLWxlZnRbZGF0YS12LTM0OTFiMjkwXXtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydH0udmMtdGl0bGUtbGF5b3V0LmFsaWduLXJpZ2h0W2RhdGEtdi0zNDkxYjI5MF17anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfS52Yy10aXRsZS13cmFwcGVyW2RhdGEtdi0zNDkxYjI5MF17cG9zaXRpb246cmVsYXRpdmV9LnZjLXRpdGxlW2RhdGEtdi0zNDkxYjI5MF17Zm9udC1zaXplOnZhcigtLXRleHQtbGcpO2NvbG9yOnZhcigtLWdyYXktODAwKTtmb250LXdlaWdodDp2YXIoLS1mb250LXNlbWlib2xkKTtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt3aGl0ZS1zcGFjZTpub3dyYXA7cGFkZGluZzowIDhweH0udmMtdGl0bGVbZGF0YS12LTM0OTFiMjkwXTpob3ZlcntvcGFjaXR5Oi43NX0udmMtd2Vla2RheVtkYXRhLXYtMzQ5MWIyOTBde2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtmbGV4OjE7Y29sb3I6dmFyKC0tZ3JheS01MDApO2ZvbnQtc2l6ZTp2YXIoLS10ZXh0LXNtKTtmb250LXdlaWdodDp2YXIoLS1mb250LWJvbGQpO3BhZGRpbmc6NXB4IDA7Y3Vyc29yOmRlZmF1bHQ7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LnZjLXdlZWtzW2RhdGEtdi0zNDkxYjI5MF17ZmxleC1zaHJpbms6MTtmbGV4LWdyb3c6MTtwYWRkaW5nOjVweCA2cHggN3B4IDZweH0udmMtaXMtZGFyayAudmMtaGVhZGVyW2RhdGEtdi0zNDkxYjI5MF17Y29sb3I6dmFyKC0tZ3JheS0yMDApfS52Yy1pcy1kYXJrIC52Yy10aXRsZVtkYXRhLXYtMzQ5MWIyOTBde2NvbG9yOnZhcigtLWdyYXktMTAwKX0udmMtaXMtZGFyayAudmMtd2Vla2RheVtkYXRhLXYtMzQ5MWIyOTBde2NvbG9yOnZhcigtLWFjY2VudC0yMDApfVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYWMxZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjNlN1wiKTtcbnZhciBleGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkyNjNcIik7XG5cbiQoeyB0YXJnZXQ6ICdSZWdFeHAnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAvLi8uZXhlYyAhPT0gZXhlYyB9LCB7XG4gIGV4ZWM6IGV4ZWNcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImFjNDFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImFkNmRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4MjVhXCIpO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LmRvdEFsbCkgcmVzdWx0ICs9ICdzJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhZTkzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTE2M1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTExMlwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM0MzBcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbmlmIChJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5pZiAoIUlTX1BVUkUgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImIwNDdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiMWQyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM3MjlcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjEzMTBcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGRhdGVUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRGF0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiMWU1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRBbGxLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE5OTRcIik7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiMjE4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiNGIwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYThjXCIpLFxuICAgIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZmZDZcIik7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiNGMwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2I1YVwiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYjVhN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBiMDdcIiksXG4gICAgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjNlXCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYjYyMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2OTJcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxMzVcIik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkwZTNcIik7XG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTMwXCIpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZkYmZcIik7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkpIHtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXMoU3ltYm9sLCBuYW1lKSkgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xuICAgIGVsc2UgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImI3NjBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VBc3NpZ25WYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4NzJhXCIpLFxuICAgIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk2MzhcIik7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiN2ZlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjRmYlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcIi52Yy1zZWxlY3RbZGF0YS12LTI2YTA3YTUxXXtwb3NpdGlvbjpyZWxhdGl2ZX0udmMtc2VsZWN0IHNlbGVjdFtkYXRhLXYtMjZhMDdhNTFde2ZsZXgtZ3JvdzoxO2Rpc3BsYXk6YmxvY2s7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7YXBwZWFyYW5jZTpub25lO3dpZHRoOjUycHg7aGVpZ2h0OjMwcHg7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC1tZWRpdW0pO3RleHQtYWxpZ246bGVmdDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWdyYXktMjAwKTtib3JkZXI6MnB4IHNvbGlkO2JvcmRlci1jb2xvcjp2YXIoLS1ncmF5LTIwMCk7Y29sb3I6dmFyKC0tZ3JheS03MDApO3BhZGRpbmc6MCAyMHB4IDAgOHB4O2JvcmRlci1yYWRpdXM6dmFyKC0tcm91bmRlZCk7bGluZS1oZWlnaHQ6dmFyKC0tbGVhZGluZy10aWdodCk7dGV4dC1pbmRlbnQ6MDtjdXJzb3I6cG9pbnRlcjstbW96LXBhZGRpbmctc3RhcnQ6M3B4fS52Yy1zZWxlY3Qgc2VsZWN0W2RhdGEtdi0yNmEwN2E1MV06aG92ZXJ7Y29sb3I6dmFyKC0tZ3JheS02MDApfS52Yy1zZWxlY3Qgc2VsZWN0W2RhdGEtdi0yNmEwN2E1MV06Zm9jdXN7b3V0bGluZTowO2JvcmRlci1jb2xvcjp2YXIoLS1hY2NlbnQtNDAwKTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLXdoaXRlKX0udmMtc2VsZWN0LWFycm93W2RhdGEtdi0yNmEwN2E1MV17ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO3JpZ2h0OjA7cGFkZGluZzowIDRweCAwIDA7Y29sb3I6dmFyKC0tZ3JheS03MDApfS52Yy1zZWxlY3QtYXJyb3cgc3ZnW2RhdGEtdi0yNmEwN2E1MV17d2lkdGg6MTZweDtoZWlnaHQ6MTZweDtmaWxsOmN1cnJlbnRDb2xvcn0udmMtaXMtZGFyayBzZWxlY3RbZGF0YS12LTI2YTA3YTUxXXtiYWNrZ3JvdW5kOnZhcigtLWdyYXktNzAwKTtjb2xvcjp2YXIoLS1ncmF5LTEwMCk7Ym9yZGVyLWNvbG9yOnZhcigtLWdyYXktNzAwKX0udmMtaXMtZGFyayBzZWxlY3RbZGF0YS12LTI2YTA3YTUxXTpob3Zlcntjb2xvcjp2YXIoLS1ncmF5LTQwMCl9LnZjLWlzLWRhcmsgc2VsZWN0W2RhdGEtdi0yNmEwN2E1MV06Zm9jdXN7Ym9yZGVyLWNvbG9yOnZhcigtLWFjY2VudC01MDApO2JhY2tncm91bmQtY29sb3I6dmFyKC0tZ3JheS04MDApfS52Yy1pcy1kYXJrIC52Yy1zZWxlY3QtYXJyb3dbZGF0YS12LTI2YTA3YTUxXXtjb2xvcjp2YXIoLS1ncmF5LTMwMCl9XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiODAzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjRmYlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcIi52Yy1kYXktcG9wb3Zlci1yb3dbZGF0YS12LTQ5NzVkNjllXXstLWRheS1jb250ZW50LXRyYW5zaXRpb24tdGltZTowLjEzcyBlYXNlLWluO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7dHJhbnNpdGlvbjphbGwgdmFyKC0tZGF5LWNvbnRlbnQtdHJhbnNpdGlvbi10aW1lKX0udmMtZGF5LXBvcG92ZXItcm93W2RhdGEtdi00OTc1ZDY5ZV06bm90KDpmaXJzdC1jaGlsZCl7bWFyZ2luLXRvcDozcHh9LnZjLWRheS1wb3BvdmVyLXJvdy1pbmRpY2F0b3JbZGF0YS12LTQ5NzVkNjllXXtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7ZmxleC1ncm93OjA7d2lkdGg6MTVweDttYXJnaW4tcmlnaHQ6M3B4fS52Yy1kYXktcG9wb3Zlci1yb3ctaW5kaWNhdG9yIHNwYW5bZGF0YS12LTQ5NzVkNjllXXt0cmFuc2l0aW9uOmFsbCB2YXIoLS1kYXktY29udGVudC10cmFuc2l0aW9uLXRpbWUpfS52Yy1kYXktcG9wb3Zlci1yb3ctY29udGVudFtkYXRhLXYtNDk3NWQ2OWVde2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7ZmxleC13cmFwOm5vbmU7ZmxleC1ncm93OjE7d2lkdGg6LXdlYmtpdC1tYXgtY29udGVudDt3aWR0aDptYXgtY29udGVudH1cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImJhYjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0NhbGVuZGFyUGFuZV92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF8zNDkxYjI5MF9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGY2MlwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfQ2FsZW5kYXJQYW5lX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzM0OTFiMjkwX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfQ2FsZW5kYXJQYW5lX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzM0OTFiMjkwX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiB1bnVzZWQgaGFybW9ueSByZWV4cG9ydCAqICovXG4gLyogdW51c2VkIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIF91bnVzZWRfd2VicGFja19kZWZhdWx0X2V4cG9ydCA9IChfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfQ2FsZW5kYXJQYW5lX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzM0OTFiMjkwX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpOyBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYmFkZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZU1hdGNoZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjQyYVwiKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE4MzhcIiksXG4gICAgaWRlbnRpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2Q5ZFwiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY3NDdcIiksXG4gICAgcHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjljZVwiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYmJjMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYwNDRcIik7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImMwNGVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2MWRcIik7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgUFJFRkVSUkVEX1NUUklORykge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFBSRUZFUlJFRF9TVFJJTkcgJiYgdHlwZW9mIChmbiA9IGlucHV0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaW5wdXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVBSRUZFUlJFRF9TVFJJTkcgJiYgdHlwZW9mIChmbiA9IGlucHV0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzA1ZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzRXF1YWxEZWVwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdiOTdcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjEzMTBcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImMwOThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzFjOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVNldFRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE0NTRcIiksXG4gICAgc2hvcnRPdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjNjMVwiKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjMmI2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbG9uZUFycmF5QnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY4YWZcIiksXG4gICAgY2xvbmVEYXRhVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1ZDg5XCIpLFxuICAgIGNsb25lUmVnRXhwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZmNmNcIiksXG4gICAgY2xvbmVTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTJkYlwiKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzhmZVwiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzNlYVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzZfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl82X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfNl9vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfNl9vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfR3JpZF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF81ZTgyZTdlZF9zY29wZWRfdHJ1ZV9sYW5nX2Nzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNTdkXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfNl9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzZfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19HcmlkX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzVlODJlN2VkX3Njb3BlZF90cnVlX2xhbmdfY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfNl9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzZfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19HcmlkX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzVlODJlN2VkX3Njb3BlZF90cnVlX2xhbmdfY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfNl9vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzZfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl82X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19HcmlkX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzVlODJlN2VkX3Njb3BlZF90cnVlX2xhbmdfY3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7IFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjM2ZjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDJhMlwiKSxcbiAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTMxMFwiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImM0MzBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNTQ3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjRmYlwiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pLCBcIi52Yy1wb3BvdmVyLWNvbnRlbnQtd3JhcHBlcltkYXRhLXYtNmM4YTJhM2Ndey0tcG9wb3Zlci1ob3Jpem9udGFsLWNvbnRlbnQtb2Zmc2V0OjhweDstLXBvcG92ZXItdmVydGljYWwtY29udGVudC1vZmZzZXQ6MTBweDstLXBvcG92ZXItc2xpZGUtdHJhbnNsYXRpb246MTVweDstLXBvcG92ZXItdHJhbnNpdGlvbi10aW1lOjAuMTRzIGVhc2UtaW4tb3V0Oy0tcG9wb3Zlci1jYXJldC1ob3Jpem9udGFsLW9mZnNldDoxOHB4Oy0tcG9wb3Zlci1jYXJldC12ZXJ0aWNhbC1vZmZzZXQ6OHB4O3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7b3V0bGluZTpub25lO3otaW5kZXg6MTB9LnZjLXBvcG92ZXItY29udGVudC13cmFwcGVyW2RhdGEtdi02YzhhMmEzY106bm90KC5pcy1pbnRlcmFjdGl2ZSl7cG9pbnRlci1ldmVudHM6bm9uZX0udmMtcG9wb3Zlci1jb250ZW50W2RhdGEtdi02YzhhMmEzY117cG9zaXRpb246cmVsYXRpdmU7b3V0bGluZTpub25lO3otaW5kZXg6MTA7Ym94LXNoYWRvdzp2YXIoLS1zaGFkb3ctbGcpfS52Yy1wb3BvdmVyLWNvbnRlbnQuZGlyZWN0aW9uLWJvdHRvbVtkYXRhLXYtNmM4YTJhM2Nde21hcmdpbi10b3A6dmFyKC0tcG9wb3Zlci12ZXJ0aWNhbC1jb250ZW50LW9mZnNldCl9LnZjLXBvcG92ZXItY29udGVudC5kaXJlY3Rpb24tdG9wW2RhdGEtdi02YzhhMmEzY117bWFyZ2luLWJvdHRvbTp2YXIoLS1wb3BvdmVyLXZlcnRpY2FsLWNvbnRlbnQtb2Zmc2V0KX0udmMtcG9wb3Zlci1jb250ZW50LmRpcmVjdGlvbi1sZWZ0W2RhdGEtdi02YzhhMmEzY117bWFyZ2luLXJpZ2h0OnZhcigtLXBvcG92ZXItaG9yaXpvbnRhbC1jb250ZW50LW9mZnNldCl9LnZjLXBvcG92ZXItY29udGVudC5kaXJlY3Rpb24tcmlnaHRbZGF0YS12LTZjOGEyYTNjXXttYXJnaW4tbGVmdDp2YXIoLS1wb3BvdmVyLWhvcml6b250YWwtY29udGVudC1vZmZzZXQpfS52Yy1wb3BvdmVyLWNhcmV0W2RhdGEtdi02YzhhMmEzY117Y29udGVudDpcXFwiXFxcIjtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEycHg7aGVpZ2h0OjEycHg7Ym9yZGVyLXRvcDppbmhlcml0O2JvcmRlci1sZWZ0OmluaGVyaXQ7YmFja2dyb3VuZC1jb2xvcjppbmhlcml0O3otaW5kZXg6LTF9LnZjLXBvcG92ZXItY2FyZXQuZGlyZWN0aW9uLWJvdHRvbVtkYXRhLXYtNmM4YTJhM2Nde3RvcDowfS52Yy1wb3BvdmVyLWNhcmV0LmRpcmVjdGlvbi1ib3R0b20uYWxpZ24tbGVmdFtkYXRhLXYtNmM4YTJhM2Nde3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpIHJvdGF0ZSg0NWRlZyl9LnZjLXBvcG92ZXItY2FyZXQuZGlyZWN0aW9uLWJvdHRvbS5hbGlnbi1jZW50ZXJbZGF0YS12LTZjOGEyYTNjXXt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpIHJvdGF0ZSg0NWRlZyl9LnZjLXBvcG92ZXItY2FyZXQuZGlyZWN0aW9uLWJvdHRvbS5hbGlnbi1yaWdodFtkYXRhLXYtNmM4YTJhM2Nde3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpIHJvdGF0ZSg0NWRlZyl9LnZjLXBvcG92ZXItY2FyZXQuZGlyZWN0aW9uLXRvcFtkYXRhLXYtNmM4YTJhM2Nde3RvcDoxMDAlfS52Yy1wb3BvdmVyLWNhcmV0LmRpcmVjdGlvbi10b3AuYWxpZ24tbGVmdFtkYXRhLXYtNmM4YTJhM2Nde3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpIHJvdGF0ZSgtMTM1ZGVnKX0udmMtcG9wb3Zlci1jYXJldC5kaXJlY3Rpb24tdG9wLmFsaWduLWNlbnRlcltkYXRhLXYtNmM4YTJhM2Nde3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKC0xMzVkZWcpfS52Yy1wb3BvdmVyLWNhcmV0LmRpcmVjdGlvbi10b3AuYWxpZ24tcmlnaHRbZGF0YS12LTZjOGEyYTNjXXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoLTEzNWRlZyl9LnZjLXBvcG92ZXItY2FyZXQuZGlyZWN0aW9uLWxlZnRbZGF0YS12LTZjOGEyYTNjXXtsZWZ0OjEwMCV9LnZjLXBvcG92ZXItY2FyZXQuZGlyZWN0aW9uLWxlZnQuYWxpZ24tdG9wW2RhdGEtdi02YzhhMmEzY117dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgcm90YXRlKDEzNWRlZyl9LnZjLXBvcG92ZXItY2FyZXQuZGlyZWN0aW9uLWxlZnQuYWxpZ24tbWlkZGxlW2RhdGEtdi02YzhhMmEzY117dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSkgdHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoMTM1ZGVnKX0udmMtcG9wb3Zlci1jYXJldC5kaXJlY3Rpb24tbGVmdC5hbGlnbi1ib3R0b21bZGF0YS12LTZjOGEyYTNjXXt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoMTM1ZGVnKX0udmMtcG9wb3Zlci1jYXJldC5kaXJlY3Rpb24tcmlnaHRbZGF0YS12LTZjOGEyYTNjXXtsZWZ0OjB9LnZjLXBvcG92ZXItY2FyZXQuZGlyZWN0aW9uLXJpZ2h0LmFsaWduLXRvcFtkYXRhLXYtNmM4YTJhM2Nde3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpfS52Yy1wb3BvdmVyLWNhcmV0LmRpcmVjdGlvbi1yaWdodC5hbGlnbi1taWRkbGVbZGF0YS12LTZjOGEyYTNjXXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKSB0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpfS52Yy1wb3BvdmVyLWNhcmV0LmRpcmVjdGlvbi1yaWdodC5hbGlnbi1ib3R0b21bZGF0YS12LTZjOGEyYTNjXXt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoLTQ1ZGVnKX0udmMtcG9wb3Zlci1jYXJldC5hbGlnbi1sZWZ0W2RhdGEtdi02YzhhMmEzY117bGVmdDp2YXIoLS1wb3BvdmVyLWNhcmV0LWhvcml6b250YWwtb2Zmc2V0KX0udmMtcG9wb3Zlci1jYXJldC5hbGlnbi1jZW50ZXJbZGF0YS12LTZjOGEyYTNjXXtsZWZ0OjUwJX0udmMtcG9wb3Zlci1jYXJldC5hbGlnbi1yaWdodFtkYXRhLXYtNmM4YTJhM2Nde3JpZ2h0OnZhcigtLXBvcG92ZXItY2FyZXQtaG9yaXpvbnRhbC1vZmZzZXQpfS52Yy1wb3BvdmVyLWNhcmV0LmFsaWduLXRvcFtkYXRhLXYtNmM4YTJhM2Nde3RvcDp2YXIoLS1wb3BvdmVyLWNhcmV0LXZlcnRpY2FsLW9mZnNldCl9LnZjLXBvcG92ZXItY2FyZXQuYWxpZ24tbWlkZGxlW2RhdGEtdi02YzhhMmEzY117dG9wOjUwJX0udmMtcG9wb3Zlci1jYXJldC5hbGlnbi1ib3R0b21bZGF0YS12LTZjOGEyYTNjXXtib3R0b206dmFyKC0tcG9wb3Zlci1jYXJldC12ZXJ0aWNhbC1vZmZzZXQpfS5mYWRlLWVudGVyLWFjdGl2ZVtkYXRhLXYtNmM4YTJhM2NdLC5mYWRlLWxlYXZlLWFjdGl2ZVtkYXRhLXYtNmM4YTJhM2NdLC5zbGlkZS1mYWRlLWVudGVyLWFjdGl2ZVtkYXRhLXYtNmM4YTJhM2NdLC5zbGlkZS1mYWRlLWxlYXZlLWFjdGl2ZVtkYXRhLXYtNmM4YTJhM2Nde3RyYW5zaXRpb246YWxsIHZhcigtLXBvcG92ZXItdHJhbnNpdGlvbi10aW1lKTtwb2ludGVyLWV2ZW50czpub25lfS5mYWRlLWVudGVyW2RhdGEtdi02YzhhMmEzY10sLmZhZGUtbGVhdmUtdG9bZGF0YS12LTZjOGEyYTNjXSwuc2xpZGUtZmFkZS1lbnRlcltkYXRhLXYtNmM4YTJhM2NdLC5zbGlkZS1mYWRlLWxlYXZlLXRvW2RhdGEtdi02YzhhMmEzY117b3BhY2l0eTowfS5zbGlkZS1mYWRlLWVudGVyLmRpcmVjdGlvbi1ib3R0b21bZGF0YS12LTZjOGEyYTNjXSwuc2xpZGUtZmFkZS1sZWF2ZS10by5kaXJlY3Rpb24tYm90dG9tW2RhdGEtdi02YzhhMmEzY117dHJhbnNmb3JtOnRyYW5zbGF0ZVkoY2FsYyh2YXIoLS1wb3BvdmVyLXNsaWRlLXRyYW5zbGF0aW9uKSotMSkpfS5zbGlkZS1mYWRlLWVudGVyLmRpcmVjdGlvbi10b3BbZGF0YS12LTZjOGEyYTNjXSwuc2xpZGUtZmFkZS1sZWF2ZS10by5kaXJlY3Rpb24tdG9wW2RhdGEtdi02YzhhMmEzY117dHJhbnNmb3JtOnRyYW5zbGF0ZVkodmFyKC0tcG9wb3Zlci1zbGlkZS10cmFuc2xhdGlvbikpfS5zbGlkZS1mYWRlLWVudGVyLmRpcmVjdGlvbi1sZWZ0W2RhdGEtdi02YzhhMmEzY10sLnNsaWRlLWZhZGUtbGVhdmUtdG8uZGlyZWN0aW9uLWxlZnRbZGF0YS12LTZjOGEyYTNjXXt0cmFuc2Zvcm06dHJhbnNsYXRlWCh2YXIoLS1wb3BvdmVyLXNsaWRlLXRyYW5zbGF0aW9uKSl9LnNsaWRlLWZhZGUtZW50ZXIuZGlyZWN0aW9uLXJpZ2h0W2RhdGEtdi02YzhhMmEzY10sLnNsaWRlLWZhZGUtbGVhdmUtdG8uZGlyZWN0aW9uLXJpZ2h0W2RhdGEtdi02YzhhMmEzY117dHJhbnNmb3JtOnRyYW5zbGF0ZVgoY2FsYyh2YXIoLS1wb3BvdmVyLXNsaWRlLXRyYW5zbGF0aW9uKSotMSkpfVwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzU4NFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNmI2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNmNkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGE4NFwiKTtcbnZhciBzZXRHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2U0ZVwiKTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImM2Y2ZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZsYXR0ZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGQ4Y1wiKSxcbiAgICBvdmVyUmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyMjg2XCIpLFxuICAgIHNldFRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMxYzlcIik7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjODY5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGIwN1wiKSxcbiAgICByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJiM2VcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjODdjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzhiYVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzhmZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2xvbmVBcnJheUJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmOGFmXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjYTg0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmM2YVwiKTtcbnZhciBpbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRkNjRcIikuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMTJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2I1YVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTYzOFwiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2MxMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODYxZFwiKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2MyZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfU3ZnSWNvbl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF8xOWI2Y2Y3OF9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGRhZFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfU3ZnSWNvbl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF8xOWI2Y2Y3OF9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX1N2Z0ljb25fdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfMTliNmNmNzhfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19TdmdJY29uX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzE5YjZjZjc4X2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpOyBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2M0NVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFhMmRcIiksXG4gICAgYmFzZVVuYXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImIwNDdcIiksXG4gICAgbm9kZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTlkM1wiKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc01hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjZDlkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2U0ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkxMTJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoZ2xvYmFsLCBrZXksIHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2U4NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllNjlcIiksXG4gICAgYXJyYXlNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzk0OFwiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY3NDdcIiksXG4gICAgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmZkNlwiKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2ViZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1BhaXJzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQwMTJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMDJjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBMaXN0Q2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWUyZVwiKSxcbiAgICBNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzliY1wiKSxcbiAgICBNYXBDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3YjgzXCIpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMDM5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDA2NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0MjhmXCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkYTg0XCIpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT0gJ2Z1bmN0aW9uJyA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGhbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKVxuICAgIDogcGF0aFtuYW1lc3BhY2VdICYmIHBhdGhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQxZTdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICFuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMjNlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTIwN1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDk5ZVwiKS5kZWZhdWx0XG52YXIgdXBkYXRlID0gYWRkKFwiNGU2MzQ4NWFcIiwgY29udGVudCwgdHJ1ZSwge1wic291cmNlTWFwXCI6ZmFsc2UsXCJzaGFkb3dNb2RlXCI6ZmFsc2V9KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDJiYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODI1YVwiKTtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiM2JiZVwiKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDMyN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMzcwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjUzY1wiKSxcbiAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTMxMFwiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDQ0ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWJmMlwiKS5mO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTM1XCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNjIyXCIpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRBRywgU1RBVElDKSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gU1RBVElDID8gaXQgOiBpdC5wcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoaXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQ1N2RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YjVmXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTllXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCI1MjkyZTJhYVwiLCBjb250ZW50LCB0cnVlLCB7XCJzb3VyY2VNYXBcIjpmYWxzZSxcInNoYWRvd01vZGVcIjpmYWxzZX0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkNjEyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBNYXBDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3YjgzXCIpLFxuICAgIHNldENhY2hlQWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdlZDJcIiksXG4gICAgc2V0Q2FjaGVIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGMwZlwiKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQ2ZjhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX1RpbWVQaWNrZXJfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfMzFhMzRiYzJfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQyM2VcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX1RpbWVQaWNrZXJfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfMzFhMzRiYzJfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19UaW1lUGlja2VyX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzMxYTM0YmMyX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiB1bnVzZWQgaGFybW9ueSByZWV4cG9ydCAqICovXG4gLyogdW51c2VkIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIF91bnVzZWRfd2VicGFja19kZWZhdWx0X2V4cG9ydCA9IChfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfVGltZVBpY2tlcl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF8zMWEzNGJjMl9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTsgXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQ3ODRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3MgbW92ZWQgdG8gZW50cnkgcG9pbnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWMxZlwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ZWViXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQwMzlcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI2MjJcIik7XG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MjYzXCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MTEyXCIpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG4vLyBJRSA8PSAxMSByZXBsYWNlcyAkMCB3aXRoIHRoZSB3aG9sZSBtYXRjaCwgYXMgaWYgaXQgd2FzICQmXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDI0NjY2L2dldHRpbmctaWUtdG8tcmVwbGFjZS1hLXJlZ2V4LXdpdGgtdGhlLWxpdGVyYWwtc3RyaW5nLTBcbnZhciBSRVBMQUNFX0tFRVBTXyQwID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdhJy5yZXBsYWNlKC8uLywgJyQwJykgPT09ICckMCc7XG59KSgpO1xuXG52YXIgUkVQTEFDRSA9IHdlbGxLbm93blN5bWJvbCgncmVwbGFjZScpO1xuLy8gU2FmYXJpIDw9IDEzLjAuMyg/KSBzdWJzdGl0dXRlcyBudGggY2FwdHVyZSB3aGVyZSBuPm0gd2l0aCBhbiBlbXB0eSBzdHJpbmdcbnZhciBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRSA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICgvLi9bUkVQTEFDRV0pIHtcbiAgICByZXR1cm4gLy4vW1JFUExBQ0VdKCdhJywgJyQwJykgPT09ICcnO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0pKCk7XG5cbi8vIENocm9tZSA1MSBoYXMgYSBidWdneSBcInNwbGl0XCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xuLy8gV2VleCBKUyBoYXMgZnJvemVuIGJ1aWx0LWluIHByb3RvdHlwZXMsIHNvIHVzZSB0cnkgLyBjYXRjaCB3cmFwcGVyXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICE9PSAyIHx8IHJlc3VsdFswXSAhPT0gJ2EnIHx8IHJlc3VsdFsxXSAhPT0gJ2InO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjLCBzaGFtKSB7XG4gIHZhciBTWU1CT0wgPSB3ZWxsS25vd25TeW1ib2woS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcblxuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFdlIGNhbid0IHVzZSByZWFsIHJlZ2V4IGhlcmUgc2luY2UgaXQgY2F1c2VzIGRlb3B0aW1pemF0aW9uXG4gICAgICAvLyBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiBpbiBWOFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMwNlxuICAgICAgcmUgPSB7fTtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICAgIHJlLmZsYWdzID0gJyc7XG4gICAgICByZVtTWU1CT0xdID0gLy4vW1NZTUJPTF07XG4gICAgfVxuXG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuXG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KTtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICAoS0VZID09PSAncmVwbGFjZScgJiYgIShcbiAgICAgIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTICYmXG4gICAgICBSRVBMQUNFX0tFRVBTXyQwICYmXG4gICAgICAhUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkVcbiAgICApKSB8fFxuICAgIChLRVkgPT09ICdzcGxpdCcgJiYgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQylcbiAgKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBtZXRob2RzID0gZXhlYyhTWU1CT0wsICcnW0tFWV0sIGZ1bmN0aW9uIChuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG4gICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVSZWdFeHBNZXRob2QuY2FsbChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgIH0sIHtcbiAgICAgIFJFUExBQ0VfS0VFUFNfJDA6IFJFUExBQ0VfS0VFUFNfJDAsXG4gICAgICBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRTogUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkVcbiAgICB9KTtcbiAgICB2YXIgc3RyaW5nTWV0aG9kID0gbWV0aG9kc1swXTtcbiAgICB2YXIgcmVnZXhNZXRob2QgPSBtZXRob2RzWzFdO1xuXG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJpbmdNZXRob2QpO1xuICAgIHJlZGVmaW5lKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcmVnZXhNZXRob2QuY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByZWdleE1ldGhvZC5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG5cbiAgaWYgKHNoYW0pIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShSZWdFeHAucHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQ3ZWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc1NldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjM2ZjXCIpLFxuICAgIGJhc2VVbmFyeSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiMDQ3XCIpLFxuICAgIG5vZGVVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk5ZDNcIik7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGEwM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjNlXCIpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGE4NFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7dmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oXCJjOGJhXCIpKSlcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGMwZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGM1N1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGM4Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0ZmJcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaSwgXCIudmMtY29udGFpbmVyey0td2hpdGU6I2ZmZjstLWJsYWNrOiMwMDA7LS1ncmF5LTEwMDojZjdmYWZjOy0tZ3JheS0yMDA6I2VkZjJmNzstLWdyYXktMzAwOiNlMmU4ZjA7LS1ncmF5LTQwMDojY2JkNWUwOy0tZ3JheS01MDA6I2EwYWVjMDstLWdyYXktNjAwOiM3MTgwOTY7LS1ncmF5LTcwMDojNGE1NTY4Oy0tZ3JheS04MDA6IzJkMzc0ODstLWdyYXktOTAwOiMxYTIwMmM7LS1yZWQtMTAwOiNmZmY1ZjU7LS1yZWQtMjAwOiNmZWQ3ZDc7LS1yZWQtMzAwOiNmZWIyYjI7LS1yZWQtNDAwOiNmYzgxODE7LS1yZWQtNTAwOiNmNTY1NjU7LS1yZWQtNjAwOiNlNTNlM2U7LS1yZWQtNzAwOiNjNTMwMzA7LS1yZWQtODAwOiM5YjJjMmM7LS1yZWQtOTAwOiM3NDJhMmE7LS1vcmFuZ2UtMTAwOiNmZmZhZjA7LS1vcmFuZ2UtMjAwOiNmZWViYzg7LS1vcmFuZ2UtMzAwOiNmYmQzOGQ7LS1vcmFuZ2UtNDAwOiNmNmFkNTU7LS1vcmFuZ2UtNTAwOiNlZDg5MzY7LS1vcmFuZ2UtNjAwOiNkZDZiMjA7LS1vcmFuZ2UtNzAwOiNjMDU2MjE7LS1vcmFuZ2UtODAwOiM5YzQyMjE7LS1vcmFuZ2UtOTAwOiM3YjM0MWU7LS15ZWxsb3ctMTAwOml2b3J5Oy0teWVsbG93LTIwMDojZmVmY2JmOy0teWVsbG93LTMwMDojZmFmMDg5Oy0teWVsbG93LTQwMDojZjZlMDVlOy0teWVsbG93LTUwMDojZWNjOTRiOy0teWVsbG93LTYwMDojZDY5ZTJlOy0teWVsbG93LTcwMDojYjc3OTFmOy0teWVsbG93LTgwMDojOTc1YTE2Oy0teWVsbG93LTkwMDojNzQ0MjEwOy0tZ3JlZW4tMTAwOiNmMGZmZjQ7LS1ncmVlbi0yMDA6I2M2ZjZkNTstLWdyZWVuLTMwMDojOWFlNmI0Oy0tZ3JlZW4tNDAwOiM2OGQzOTE7LS1ncmVlbi01MDA6IzQ4YmI3ODstLWdyZWVuLTYwMDojMzhhMTY5Oy0tZ3JlZW4tNzAwOiMyZjg1NWE7LS1ncmVlbi04MDA6IzI3Njc0OTstLWdyZWVuLTkwMDojMjI1NDNkOy0tdGVhbC0xMDA6I2U2ZmZmYTstLXRlYWwtMjAwOiNiMmY1ZWE7LS10ZWFsLTMwMDojODFlNmQ5Oy0tdGVhbC00MDA6IzRmZDFjNTstLXRlYWwtNTAwOiMzOGIyYWM7LS10ZWFsLTYwMDojMzE5Nzk1Oy0tdGVhbC03MDA6IzJjN2E3YjstLXRlYWwtODAwOiMyODVlNjE7LS10ZWFsLTkwMDojMjM0ZTUyOy0tYmx1ZS0xMDA6I2ViZjhmZjstLWJsdWUtMjAwOiNiZWUzZjg7LS1ibHVlLTMwMDojOTBjZGY0Oy0tYmx1ZS00MDA6IzYzYjNlZDstLWJsdWUtNTAwOiM0Mjk5ZTE7LS1ibHVlLTYwMDojMzE4MmNlOy0tYmx1ZS03MDA6IzJiNmNiMDstLWJsdWUtODAwOiMyYzUyODI7LS1ibHVlLTkwMDojMmE0MzY1Oy0taW5kaWdvLTEwMDojZWJmNGZmOy0taW5kaWdvLTIwMDojYzNkYWZlOy0taW5kaWdvLTMwMDojYTNiZmZhOy0taW5kaWdvLTQwMDojN2Y5Y2Y1Oy0taW5kaWdvLTUwMDojNjY3ZWVhOy0taW5kaWdvLTYwMDojNWE2N2Q4Oy0taW5kaWdvLTcwMDojNGM1MWJmOy0taW5kaWdvLTgwMDojNDM0MTkwOy0taW5kaWdvLTkwMDojM2MzNjZiOy0tcHVycGxlLTEwMDojZmFmNWZmOy0tcHVycGxlLTIwMDojZTlkOGZkOy0tcHVycGxlLTMwMDojZDZiY2ZhOy0tcHVycGxlLTQwMDojYjc5NGY0Oy0tcHVycGxlLTUwMDojOWY3YWVhOy0tcHVycGxlLTYwMDojODA1YWQ1Oy0tcHVycGxlLTcwMDojNmI0NmMxOy0tcHVycGxlLTgwMDojNTUzYzlhOy0tcHVycGxlLTkwMDojNDQzMzdhOy0tcGluay0xMDA6I2ZmZjVmNzstLXBpbmstMjAwOiNmZWQ3ZTI7LS1waW5rLTMwMDojZmJiNmNlOy0tcGluay00MDA6I2Y2ODdiMzstLXBpbmstNTAwOiNlZDY0YTY7LS1waW5rLTYwMDojZDUzZjhjOy0tcGluay03MDA6I2I4MzI4MDstLXBpbmstODAwOiM5NzI2NmQ7LS1waW5rLTkwMDojNzAyNDU5fS52Yy1jb250YWluZXIudmMtcmVkey0tYWNjZW50LTEwMDp2YXIoLS1yZWQtMTAwKTstLWFjY2VudC0yMDA6dmFyKC0tcmVkLTIwMCk7LS1hY2NlbnQtMzAwOnZhcigtLXJlZC0zMDApOy0tYWNjZW50LTQwMDp2YXIoLS1yZWQtNDAwKTstLWFjY2VudC01MDA6dmFyKC0tcmVkLTUwMCk7LS1hY2NlbnQtNjAwOnZhcigtLXJlZC02MDApOy0tYWNjZW50LTcwMDp2YXIoLS1yZWQtNzAwKTstLWFjY2VudC04MDA6dmFyKC0tcmVkLTgwMCk7LS1hY2NlbnQtOTAwOnZhcigtLXJlZC05MDApfS52Yy1jb250YWluZXIudmMtb3Jhbmdley0tYWNjZW50LTEwMDp2YXIoLS1vcmFuZ2UtMTAwKTstLWFjY2VudC0yMDA6dmFyKC0tb3JhbmdlLTIwMCk7LS1hY2NlbnQtMzAwOnZhcigtLW9yYW5nZS0zMDApOy0tYWNjZW50LTQwMDp2YXIoLS1vcmFuZ2UtNDAwKTstLWFjY2VudC01MDA6dmFyKC0tb3JhbmdlLTUwMCk7LS1hY2NlbnQtNjAwOnZhcigtLW9yYW5nZS02MDApOy0tYWNjZW50LTcwMDp2YXIoLS1vcmFuZ2UtNzAwKTstLWFjY2VudC04MDA6dmFyKC0tb3JhbmdlLTgwMCk7LS1hY2NlbnQtOTAwOnZhcigtLW9yYW5nZS05MDApfS52Yy1jb250YWluZXIudmMteWVsbG93ey0tYWNjZW50LTEwMDp2YXIoLS15ZWxsb3ctMTAwKTstLWFjY2VudC0yMDA6dmFyKC0teWVsbG93LTIwMCk7LS1hY2NlbnQtMzAwOnZhcigtLXllbGxvdy0zMDApOy0tYWNjZW50LTQwMDp2YXIoLS15ZWxsb3ctNDAwKTstLWFjY2VudC01MDA6dmFyKC0teWVsbG93LTUwMCk7LS1hY2NlbnQtNjAwOnZhcigtLXllbGxvdy02MDApOy0tYWNjZW50LTcwMDp2YXIoLS15ZWxsb3ctNzAwKTstLWFjY2VudC04MDA6dmFyKC0teWVsbG93LTgwMCk7LS1hY2NlbnQtOTAwOnZhcigtLXllbGxvdy05MDApfS52Yy1jb250YWluZXIudmMtZ3JlZW57LS1hY2NlbnQtMTAwOnZhcigtLWdyZWVuLTEwMCk7LS1hY2NlbnQtMjAwOnZhcigtLWdyZWVuLTIwMCk7LS1hY2NlbnQtMzAwOnZhcigtLWdyZWVuLTMwMCk7LS1hY2NlbnQtNDAwOnZhcigtLWdyZWVuLTQwMCk7LS1hY2NlbnQtNTAwOnZhcigtLWdyZWVuLTUwMCk7LS1hY2NlbnQtNjAwOnZhcigtLWdyZWVuLTYwMCk7LS1hY2NlbnQtNzAwOnZhcigtLWdyZWVuLTcwMCk7LS1hY2NlbnQtODAwOnZhcigtLWdyZWVuLTgwMCk7LS1hY2NlbnQtOTAwOnZhcigtLWdyZWVuLTkwMCl9LnZjLWNvbnRhaW5lci52Yy10ZWFsey0tYWNjZW50LTEwMDp2YXIoLS10ZWFsLTEwMCk7LS1hY2NlbnQtMjAwOnZhcigtLXRlYWwtMjAwKTstLWFjY2VudC0zMDA6dmFyKC0tdGVhbC0zMDApOy0tYWNjZW50LTQwMDp2YXIoLS10ZWFsLTQwMCk7LS1hY2NlbnQtNTAwOnZhcigtLXRlYWwtNTAwKTstLWFjY2VudC02MDA6dmFyKC0tdGVhbC02MDApOy0tYWNjZW50LTcwMDp2YXIoLS10ZWFsLTcwMCk7LS1hY2NlbnQtODAwOnZhcigtLXRlYWwtODAwKTstLWFjY2VudC05MDA6dmFyKC0tdGVhbC05MDApfS52Yy1jb250YWluZXIudmMtYmx1ZXstLWFjY2VudC0xMDA6dmFyKC0tYmx1ZS0xMDApOy0tYWNjZW50LTIwMDp2YXIoLS1ibHVlLTIwMCk7LS1hY2NlbnQtMzAwOnZhcigtLWJsdWUtMzAwKTstLWFjY2VudC00MDA6dmFyKC0tYmx1ZS00MDApOy0tYWNjZW50LTUwMDp2YXIoLS1ibHVlLTUwMCk7LS1hY2NlbnQtNjAwOnZhcigtLWJsdWUtNjAwKTstLWFjY2VudC03MDA6dmFyKC0tYmx1ZS03MDApOy0tYWNjZW50LTgwMDp2YXIoLS1ibHVlLTgwMCk7LS1hY2NlbnQtOTAwOnZhcigtLWJsdWUtOTAwKX0udmMtY29udGFpbmVyLnZjLWluZGlnb3stLWFjY2VudC0xMDA6dmFyKC0taW5kaWdvLTEwMCk7LS1hY2NlbnQtMjAwOnZhcigtLWluZGlnby0yMDApOy0tYWNjZW50LTMwMDp2YXIoLS1pbmRpZ28tMzAwKTstLWFjY2VudC00MDA6dmFyKC0taW5kaWdvLTQwMCk7LS1hY2NlbnQtNTAwOnZhcigtLWluZGlnby01MDApOy0tYWNjZW50LTYwMDp2YXIoLS1pbmRpZ28tNjAwKTstLWFjY2VudC03MDA6dmFyKC0taW5kaWdvLTcwMCk7LS1hY2NlbnQtODAwOnZhcigtLWluZGlnby04MDApOy0tYWNjZW50LTkwMDp2YXIoLS1pbmRpZ28tOTAwKX0udmMtY29udGFpbmVyLnZjLXB1cnBsZXstLWFjY2VudC0xMDA6dmFyKC0tcHVycGxlLTEwMCk7LS1hY2NlbnQtMjAwOnZhcigtLXB1cnBsZS0yMDApOy0tYWNjZW50LTMwMDp2YXIoLS1wdXJwbGUtMzAwKTstLWFjY2VudC00MDA6dmFyKC0tcHVycGxlLTQwMCk7LS1hY2NlbnQtNTAwOnZhcigtLXB1cnBsZS01MDApOy0tYWNjZW50LTYwMDp2YXIoLS1wdXJwbGUtNjAwKTstLWFjY2VudC03MDA6dmFyKC0tcHVycGxlLTcwMCk7LS1hY2NlbnQtODAwOnZhcigtLXB1cnBsZS04MDApOy0tYWNjZW50LTkwMDp2YXIoLS1wdXJwbGUtOTAwKX0udmMtY29udGFpbmVyLnZjLXBpbmt7LS1hY2NlbnQtMTAwOnZhcigtLXBpbmstMTAwKTstLWFjY2VudC0yMDA6dmFyKC0tcGluay0yMDApOy0tYWNjZW50LTMwMDp2YXIoLS1waW5rLTMwMCk7LS1hY2NlbnQtNDAwOnZhcigtLXBpbmstNDAwKTstLWFjY2VudC01MDA6dmFyKC0tcGluay01MDApOy0tYWNjZW50LTYwMDp2YXIoLS1waW5rLTYwMCk7LS1hY2NlbnQtNzAwOnZhcigtLXBpbmstNzAwKTstLWFjY2VudC04MDA6dmFyKC0tcGluay04MDApOy0tYWNjZW50LTkwMDp2YXIoLS1waW5rLTkwMCl9LnZjLWNvbnRhaW5lcnstLWZvbnQtbm9ybWFsOjQwMDstLWZvbnQtbWVkaXVtOjUwMDstLWZvbnQtc2VtaWJvbGQ6NjAwOy0tZm9udC1ib2xkOjcwMDstLXRleHQteHM6MTJweDstLXRleHQtc206MTRweDstLXRleHQtYmFzZToxNnB4Oy0tdGV4dC1sZzoxOHB4Oy0tbGVhZGluZy1zbnVnOjEuMzc1Oy0tcm91bmRlZDowLjI1cmVtOy0tcm91bmRlZC1sZzowLjVyZW07LS1yb3VuZGVkLWZ1bGw6OTk5OXB4Oy0tc2hhZG93OjAgMXB4IDNweCAwIHJnYmEoMCwwLDAsMC4xKSwwIDFweCAycHggMCByZ2JhKDAsMCwwLDAuMDYpOy0tc2hhZG93LWxnOjAgMTBweCAxNXB4IC0zcHggcmdiYSgwLDAsMCwwLjEpLDAgNHB4IDZweCAtMnB4IHJnYmEoMCwwLDAsMC4wNSk7LS1zaGFkb3ctaW5uZXI6aW5zZXQgMCAycHggNHB4IDAgcmdiYSgwLDAsMCwwLjA2KTstLXNsaWRlLXRyYW5zbGF0ZToyMnB4Oy0tc2xpZGUtZHVyYXRpb246MC4xNXM7LS1zbGlkZS10aW1pbmc6ZWFzZTstLWRheS1jb250ZW50LXRyYW5zaXRpb24tdGltZTowLjEzcyBlYXNlLWluO2ZvbnQtZmFtaWx5OkJsaW5rTWFjU3lzdGVtRm9udCwtYXBwbGUtc3lzdGVtLFNlZ29lIFVJLFJvYm90byxPeHlnZW4sVWJ1bnR1LENhbnRhcmVsbCxGaXJhIFNhbnMsRHJvaWQgU2FucyxIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtjb2xvcjp2YXIoLS1ncmF5LTkwMCk7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS13aGl0ZSk7Ym9yZGVyOjFweCBzb2xpZDtib3JkZXItY29sb3I6dmFyKC0tZ3JheS00MDApO2JvcmRlci1yYWRpdXM6dmFyKC0tcm91bmRlZC1sZyk7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6LXdlYmtpdC1tYXgtY29udGVudDt3aWR0aDptYXgtY29udGVudDstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LnZjLWNvbnRhaW5lciwudmMtY29udGFpbmVyICp7Ym94LXNpemluZzpib3JkZXItYm94fS52Yy1jb250YWluZXI6Zm9jdXMsLnZjLWNvbnRhaW5lciA6Zm9jdXN7b3V0bGluZTpub25lfS52Yy1jb250YWluZXIgW3JvbGU9YnV0dG9uXSwudmMtY29udGFpbmVyIGJ1dHRvbntjdXJzb3I6cG9pbnRlcn0udmMtY29udGFpbmVyLnZjLWlzLWV4cGFuZGVke21pbi13aWR0aDoxMDAlfS52Yy1jb250YWluZXIgLnZjLWNvbnRhaW5lcntib3JkZXI6bm9uZX0udmMtY29udGFpbmVyLnZjLWlzLWRhcmt7Y29sb3I6dmFyKC0tZ3JheS0xMDApO2JhY2tncm91bmQtY29sb3I6dmFyKC0tZ3JheS05MDApO2JvcmRlci1jb2xvcjp2YXIoLS1ncmF5LTcwMCl9XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkY2JlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMGM5XCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMzEwXCIpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGQ2MVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzk0OFwiKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYmFkZlwiKSxcbiAgICBiYXNlTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk3ZDNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NzQ3XCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGQ3MVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfUG9wb3Zlcl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF82YzhhMmEzY19sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGUyZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfUG9wb3Zlcl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF82YzhhMmEzY19sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX1BvcG92ZXJfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfNmM4YTJhM2NfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19Qb3BvdmVyX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzZjOGEyYTNjX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEpOyBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGRiMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRhODRcIik7XG52YXIgRE9NSXRlcmFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZkYmNcIik7XG52YXIgQXJyYXlJdGVyYXRvck1ldGhvZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTI2MFwiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTExMlwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjYyMlwiKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUddKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgICB9XG4gICAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSkgdHJ5IHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZGU1ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfQ2FsZW5kYXJfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19wb3N0Y3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjcyZjVcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0NhbGVuZGFyX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfcG9zdGNzc19fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfQ2FsZW5kYXJfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19wb3N0Y3NzX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cbiAvKiB1bnVzZWQgaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgX3VudXNlZF93ZWJwYWNrX2RlZmF1bHRfZXhwb3J0ID0gKF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19DYWxlbmRhcl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Bvc3Rjc3NfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hKTsgXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImRmNzVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYTg0XCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc4MzlcIik7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImRmOWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZTgzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIGFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTllXCIpLmRlZmF1bHRcbnZhciB1cGRhdGUgPSBhZGQoXCIyOWY0OGU1ZlwiLCBjb250ZW50LCB0cnVlLCB7XCJzb3VyY2VNYXBcIjpmYWxzZSxcInNoYWRvd01vZGVcIjpmYWxzZX0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlMDMxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlTWVyZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjkwOVwiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYThjXCIpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21EZWZhdWx0c01lcmdlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImUwZTdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzUGxhaW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjBlZFwiKTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICogb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21PbWl0Q2xvbmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTE2M1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUxMzVcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2IwYlwiKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjc3MlwiKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTE3N1wiKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlMTc3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMDM5XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImUyMDdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNGZiXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmksIFwiLnZjLXRpbWUtY29udGFpbmVyW2RhdGEtdi0zMWEzNGJjMl17ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nOjAgOHB4IDhweCA4cHh9LnZjLXRpbWUtY29udGFpbmVyLnZjLWludmFsaWRbZGF0YS12LTMxYTM0YmMyXXtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MSV9LnZjLXRpbWUtY29udGFpbmVyW2RhdGEtdi0zMWEzNGJjMl06bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLXRvcDoxcHggc29saWQgdmFyKC0tZ3JheS00MDApfS52Yy1kYXRlLXRpbWVbZGF0YS12LTMxYTM0YmMyXXttYXJnaW4tbGVmdDo4cHh9LnZjLXRpbWUtaWNvbltkYXRhLXYtMzFhMzRiYzJde3dpZHRoOjE2cHg7aGVpZ2h0OjE2cHg7Y29sb3I6dmFyKC0tZ3JheS02MDApfS52Yy1kYXRlW2RhdGEtdi0zMWEzNGJjMl17ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LXNpemU6dmFyKC0tdGV4dC1zbSk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC1zZW1pYm9sZCk7dGV4dC10cmFuc2Zvcm06dXBwZXJjYXNlO3BhZGRpbmc6NHB4IDAgNHB4IDRweH0udmMtZGF0ZSAudmMtd2Vla2RheVtkYXRhLXYtMzFhMzRiYzJde2NvbG9yOnZhcigtLWdyYXktNzAwKTtsZXR0ZXItc3BhY2luZzp2YXIoLS10cmFja2luZy13aWRlKX0udmMtZGF0ZSAudmMtbW9udGhbZGF0YS12LTMxYTM0YmMyXXtjb2xvcjp2YXIoLS1hY2NlbnQtNjAwKTttYXJnaW4tbGVmdDo4cHh9LnZjLWRhdGUgLnZjLWRheVtkYXRhLXYtMzFhMzRiYzJde2NvbG9yOnZhcigtLWFjY2VudC02MDApO21hcmdpbi1sZWZ0OjRweH0udmMtZGF0ZSAudmMteWVhcltkYXRhLXYtMzFhMzRiYzJde2NvbG9yOnZhcigtLWdyYXktNTAwKTttYXJnaW4tbGVmdDo4cHh9LnZjLWFtLXBtW2RhdGEtdi0zMWEzNGJjMl0sLnZjLXRpbWVbZGF0YS12LTMxYTM0YmMyXXtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyfS52Yy1hbS1wbVtkYXRhLXYtMzFhMzRiYzJde2JhY2tncm91bmQ6dmFyKC0tZ3JheS0yMDApO2NvbG9yOnZhcigtLWdyYXktODAwKTttYXJnaW4tbGVmdDo4cHg7cGFkZGluZzo0cHg7Ym9yZGVyLXJhZGl1czp2YXIoLS1yb3VuZGVkKTtoZWlnaHQ6MzBweH0udmMtYW0tcG0gYnV0dG9uW2RhdGEtdi0zMWEzNGJjMl17Zm9udC1zaXplOnZhcigtLXRleHQtc20pO2ZvbnQtd2VpZ2h0OnZhcigtLWZvbnQtbWVkaXVtKTtwYWRkaW5nOjAgNHB4O2JvcmRlcjoycHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJhZGl1czp2YXIoLS1yb3VuZGVkKTtsaW5lLWhlaWdodDp2YXIoLS1sZWFkaW5nLXNudWcpfS52Yy1hbS1wbSBidXR0b25bZGF0YS12LTMxYTM0YmMyXTpob3Zlcntjb2xvcjp2YXIoLS1ncmF5LTYwMCl9LnZjLWFtLXBtIGJ1dHRvbltkYXRhLXYtMzFhMzRiYzJdOmZvY3Vze2JvcmRlci1jb2xvcjp2YXIoLS1hY2NlbnQtNDAwKX0udmMtYW0tcG0gYnV0dG9uLmFjdGl2ZVtkYXRhLXYtMzFhMzRiYzJde2JhY2tncm91bmQ6dmFyKC0tYWNjZW50LTYwMCk7Y29sb3I6dmFyKC0td2hpdGUpfS52Yy1hbS1wbSBidXR0b24uYWN0aXZlW2RhdGEtdi0zMWEzNGJjMl06aG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1hY2NlbnQtNTAwKX0udmMtYW0tcG0gYnV0dG9uLmFjdGl2ZVtkYXRhLXYtMzFhMzRiYzJdOmZvY3Vze2JvcmRlci1jb2xvcjp2YXIoLS1hY2NlbnQtNDAwKX0udmMtaXMtZGFyayAudmMtdGltZS1jb250YWluZXJbZGF0YS12LTMxYTM0YmMyXXtib3JkZXItY29sb3I6dmFyKC0tZ3JheS03MDApfS52Yy1pcy1kYXJrIC52Yy10aW1lLWljb25bZGF0YS12LTMxYTM0YmMyXSwudmMtaXMtZGFyayAudmMtd2Vla2RheVtkYXRhLXYtMzFhMzRiYzJde2NvbG9yOnZhcigtLWdyYXktNDAwKX0udmMtaXMtZGFyayAudmMtZGF5W2RhdGEtdi0zMWEzNGJjMl0sLnZjLWlzLWRhcmsgLnZjLW1vbnRoW2RhdGEtdi0zMWEzNGJjMl17Y29sb3I6dmFyKC0tYWNjZW50LTQwMCl9LnZjLWlzLWRhcmsgLnZjLXllYXJbZGF0YS12LTMxYTM0YmMyXXtjb2xvcjp2YXIoLS1ncmF5LTUwMCl9LnZjLWlzLWRhcmsgLnZjLWFtLXBtW2RhdGEtdi0zMWEzNGJjMl17YmFja2dyb3VuZDp2YXIoLS1ncmF5LTcwMCk7Y29sb3I6dmFyKC0tZ3JheS0xMDApfS52Yy1pcy1kYXJrIC52Yy1hbS1wbVtkYXRhLXYtMzFhMzRiYzJdOmZvY3Vze2JvcmRlci1jb2xvcjp2YXIoLS1hY2NlbnQtNTAwKX0udmMtaXMtZGFyayAudmMtYW0tcG0gYnV0dG9uW2RhdGEtdi0zMWEzNGJjMl06aG92ZXJ7Y29sb3I6dmFyKC0tZ3JheS00MDApfS52Yy1pcy1kYXJrIC52Yy1hbS1wbSBidXR0b25bZGF0YS12LTMxYTM0YmMyXTpmb2N1c3tib3JkZXItY29sb3I6dmFyKC0tYWNjZW50LTUwMCl9LnZjLWlzLWRhcmsgLnZjLWFtLXBtIGJ1dHRvbi5hY3RpdmVbZGF0YS12LTMxYTM0YmMyXXtiYWNrZ3JvdW5kOnZhcigtLWFjY2VudC01MDApO2NvbG9yOnZhcigtLXdoaXRlKX0udmMtaXMtZGFyayAudmMtYW0tcG0gYnV0dG9uLmFjdGl2ZVtkYXRhLXYtMzFhMzRiYzJdOmhvdmVye2JhY2tncm91bmQ6dmFyKC0tYWNjZW50LTYwMCl9LnZjLWlzLWRhcmsgLnZjLWFtLXBtIGJ1dHRvbi5hY3RpdmVbZGF0YS12LTMxYTM0YmMyXTpmb2N1c3tib3JkZXItY29sb3I6dmFyKC0tYWNjZW50LTUwMCl9XCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlMjRiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXNoQ2xlYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDlmNFwiKSxcbiAgICBoYXNoRGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFlZmNcIiksXG4gICAgaGFzaEdldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiYmMwXCIpLFxuICAgIGhhc2hIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2E0OFwiKSxcbiAgICBoYXNoU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI1MjRcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTI2MFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYzZhXCIpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDRkMlwiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiM2Y4Y1wiKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY5ZjNcIik7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2RkMFwiKTtcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlMmEwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM3MjlcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NzQ3XCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMzEwXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlMmMwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjYXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMmU0XCIpLFxuICAgIGlzQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQzNzBcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NzQ3XCIpLFxuICAgIGlzSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzA5OFwiKSxcbiAgICBpc0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiMjE4XCIpLFxuICAgIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY0ZDZcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1BhdGg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTJlNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2NzQ3XCIpLFxuICAgIGlzS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY2MDhcIiksXG4gICAgc3RyaW5nVG9QYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE4ZDhcIiksXG4gICAgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzZkZFwiKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlMzgwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBNYXBDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3YjgzXCIpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlM2Y4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY1NmJcIik7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTUzOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlKSB7dmFyIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmIzZVwiKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9ICB0cnVlICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oXCI2MmU0XCIpKG1vZHVsZSkpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlNzZmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19DdXN0b21UcmFuc2l0aW9uX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzg0NjY1OTJlX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNTVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19DdXN0b21UcmFuc2l0aW9uX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzg0NjY1OTJlX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfQ3VzdG9tVHJhbnNpdGlvbl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF84NDY2NTkyZV9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogdW51c2VkIGhhcm1vbnkgcmVleHBvcnQgKiAqL1xuIC8qIHVudXNlZCBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBfdW51c2VkX3dlYnBhY2tfZGVmYXVsdF9leHBvcnQgPSAoX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX0N1c3RvbVRyYW5zaXRpb25fdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfODQ2NjU5MmVfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7IFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlODkzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTEzNVwiKTtcbnZhciBvd25LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZWZcIik7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjA2Y2ZcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWJmMlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTk2OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBkYTVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgYWRkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ5OWVcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjYxYzJiZDVlXCIsIGNvbnRlbnQsIHRydWUsIHtcInNvdXJjZU1hcFwiOmZhbHNlLFwic2hhZG93TW9kZVwiOmZhbHNlfSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImVhYzVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImVjNDdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VUb1BhaXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImEzZmRcIiksXG4gICAgZ2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQyYTJcIiksXG4gICAgbWFwVG9BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlZGZhXCIpLFxuICAgIHNldFRvUGFpcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2ViZFwiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFpcnMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRvUGFpcnM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZWM2OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlMaWtlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ZmNkXCIpLFxuICAgIGJhc2VLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzZGRcIiksXG4gICAgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzBjOVwiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlYzhjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlZGZhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlZWZiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19UaW1lU2VsZWN0X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzI2YTA3YTUxX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwYTZiXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfdnVlX3N0eWxlX2xvYWRlcl9pbmRleF9qc19yZWZfN19vbmVPZl8xXzBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfcmVmXzdfb25lT2ZfMV8xX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9sb2FkZXJzX3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMl9ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX3JlZl83X29uZU9mXzFfM19ub2RlX21vZHVsZXNfY2FjaGVfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl8wXzBfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2luZGV4X2pzX3Z1ZV9sb2FkZXJfb3B0aW9uc19UaW1lU2VsZWN0X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzI2YTA3YTUxX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX3Z1ZV9zdHlsZV9sb2FkZXJfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8wX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX3JlZl83X29uZU9mXzFfMV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfbG9hZGVyc19zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzJfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19yZWZfN19vbmVPZl8xXzNfbm9kZV9tb2R1bGVzX2NhY2hlX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfMF8wX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9pbmRleF9qc192dWVfbG9hZGVyX29wdGlvbnNfVGltZVNlbGVjdF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF8yNmEwN2E1MV9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogdW51c2VkIGhhcm1vbnkgcmVleHBvcnQgKiAqL1xuIC8qIHVudXNlZCBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBfdW51c2VkX3dlYnBhY2tfZGVmYXVsdF9leHBvcnQgPSAoX25vZGVfbW9kdWxlc192dWVfc3R5bGVfbG9hZGVyX2luZGV4X2pzX3JlZl83X29uZU9mXzFfMF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19yZWZfN19vbmVPZl8xXzFfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX2xvYWRlcnNfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8yX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfcmVmXzdfb25lT2ZfMV8zX25vZGVfbW9kdWxlc19jYWNoZV9sb2FkZXJfZGlzdF9janNfanNfcmVmXzBfMF9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfaW5kZXhfanNfdnVlX2xvYWRlcl9vcHRpb25zX1RpbWVTZWxlY3RfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfMjZhMDdhNTFfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYSk7IFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlZjVkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImVmYjZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1ZTJlXCIpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjNjMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjRkNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmZkNlwiKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjU0MlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY3JlYXRlVG9QYWlycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlYzQ3XCIpLFxuICAgIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWM2OVwiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAqIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcCBvciBzZXQsIGl0c1xuICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGVudHJpZXNcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG52YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QYWlycztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmNjA4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY3NDdcIiksXG4gICAgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmZkNlwiKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImY2NzhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VDbGFtcCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4Mzg0XCIpLFxuICAgIHRvTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI0YjBcIik7XG5cbi8qKlxuICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAqIC8vID0+IC01XG4gKlxuICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICogLy8gPT4gNVxuICovXG5mdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHVwcGVyID0gbG93ZXI7XG4gICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgfVxuICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgIGxvd2VyID0gbG93ZXIgPT09IGxvd2VyID8gbG93ZXIgOiAwO1xuICB9XG4gIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFtcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmNzcyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTY5MlwiKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTBlM1wiKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjhhZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVWludDhBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNDc0XCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmOTA5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ZTY0XCIpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjc2MFwiKSxcbiAgICBiYXNlRm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjcyYWZcIiksXG4gICAgYmFzZU1lcmdlRGVlcCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ZjUwXCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjFhOGNcIiksXG4gICAga2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk5MzRcIiksXG4gICAgc2FmZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4YWRiXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImY5Y2VcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlZjVkXCIpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTNmOFwiKSxcbiAgICBpc0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjA4XCIpLFxuICAgIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY0ZDZcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmYTIxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc1MzBcIiksXG4gICAgZ2V0UHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJkY2JcIiksXG4gICAgaXNQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWFjNVwiKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmYjE1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IEM6L1Byb2plY3RzL3YtY2FsZW5kYXIvbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2UvbGliL2NvbW1hbmRzL2J1aWxkL3NldFB1YmxpY1BhdGguanNcbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBpbnRvIGxpYi93YyBjbGllbnQgYnVuZGxlcy5cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBjdXJyZW50U2NyaXB0ID0gd2luZG93LmRvY3VtZW50LmN1cnJlbnRTY3JpcHRcbiAgaWYgKGZhbHNlKSB7IHZhciBnZXRDdXJyZW50U2NyaXB0OyB9XG5cbiAgdmFyIHNyYyA9IGN1cnJlbnRTY3JpcHQgJiYgY3VycmVudFNjcmlwdC5zcmMubWF0Y2goLyguK1xcLylbXi9dK1xcLmpzKFxcPy4qKT8kLylcbiAgaWYgKHNyYykge1xuICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IHNyY1sxXSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cbn1cblxuLy8gSW5kaWNhdGUgdG8gd2VicGFjayB0aGF0IHRoaXMgZmlsZSBjYW4gYmUgY29uY2F0ZW5hdGVkXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzZXRQdWJsaWNQYXRoID0gKG51bGwpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXG52YXIgd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkZGIwXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi90b0ludGVnZXIvaW5kZXguanNcbmZ1bmN0aW9uIHRvSW50ZWdlcihkaXJ0eU51bWJlcikge1xuICBpZiAoZGlydHlOdW1iZXIgPT09IG51bGwgfHwgZGlydHlOdW1iZXIgPT09IHRydWUgfHwgZGlydHlOdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuXG4gIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBudW1iZXIgPCAwID8gTWF0aC5jZWlsKG51bWJlcikgOiBNYXRoLmZsb29yKG51bWJlcik7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcbmZ1bmN0aW9uIHJlcXVpcmVkQXJncyhyZXF1aXJlZCwgYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPCByZXF1aXJlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocmVxdWlyZWQgKyAnIGFyZ3VtZW50JyArIChyZXF1aXJlZCA+IDEgPyAncycgOiAnJykgKyAnIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJncy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3RvRGF0ZS9pbmRleC5qc1xuXG4vKipcbiAqIEBuYW1lIHRvRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgbm9uZSBvZiB0aGUgYWJvdmUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIEludmFsaWQgRGF0ZS5cbiAqXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDbG9uZSB0aGUgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZShuZXcgRGF0ZSgyMDE0LCAxLCAxMSwgMTEsIDMwLCAzMCkpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHRoZSB0aW1lc3RhbXAgdG8gZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZSgxMzkyMDk4NDMwMDAwKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqL1xuXG5mdW5jdGlvbiB0b0RhdGUoYXJndW1lbnQpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBhcmdTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpOyAvLyBDbG9uZSB0aGUgZGF0ZVxuXG4gIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGFyZ3VtZW50ID09PSAnb2JqZWN0JyAmJiBhcmdTdHIgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudC5nZXRUaW1lKCkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ251bWJlcicgfHwgYXJnU3RyID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgU3RyaW5nXScpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIlN0YXJ0aW5nIHdpdGggdjIuMC4wLWJldGEuMSBkYXRlLWZucyBkb2Vzbid0IGFjY2VwdCBzdHJpbmdzIGFzIGRhdGUgYXJndW1lbnRzLiBQbGVhc2UgdXNlIGBwYXJzZUlTT2AgdG8gcGFyc2Ugc3RyaW5ncy4gU2VlOiBodHRwczovL2dpdC5pby9manVsZVwiKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2FkZERheXMvaW5kZXguanNcblxuXG5cbi8qKlxuICogQG5hbWUgYWRkRGF5c1xuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGF5cyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkYXlzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGRheXMgdG8gYmUgYWRkZWQuIFBvc2l0aXZlIGRlY2ltYWxzIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5mbG9vcmAsIGRlY2ltYWxzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5jZWlsYC5cbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgZGF5cyBhZGRlZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgMTAgZGF5cyB0byAxIFNlcHRlbWJlciAyMDE0OlxuICogdmFyIHJlc3VsdCA9IGFkZERheXMobmV3IERhdGUoMjAxNCwgOCwgMSksIDEwKVxuICogLy89PiBUaHUgU2VwIDExIDIwMTQgMDA6MDA6MDBcbiAqL1xuXG5mdW5jdGlvbiBhZGREYXlzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIoZGlydHlBbW91bnQpO1xuXG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICBpZiAoIWFtb3VudCkge1xuICAgIC8vIElmIDAgZGF5cywgbm8tb3AgdG8gYXZvaWQgY2hhbmdpbmcgdGltZXMgaW4gdGhlIGhvdXIgYmVmb3JlIGVuZCBvZiBEU1RcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIGFtb3VudCk7XG4gIHJldHVybiBkYXRlO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2FkZE1vbnRocy9pbmRleC5qc1xuXG5cblxuLyoqXG4gKiBAbmFtZSBhZGRNb250aHNcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbW9udGhzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1vbnRocyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtb250aHMgdG8gYmUgYWRkZWQuIFBvc2l0aXZlIGRlY2ltYWxzIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5mbG9vcmAsIGRlY2ltYWxzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5jZWlsYC5cbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbW9udGhzIGFkZGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCA1IG1vbnRocyB0byAxIFNlcHRlbWJlciAyMDE0OlxuICogdmFyIHJlc3VsdCA9IGFkZE1vbnRocyhuZXcgRGF0ZSgyMDE0LCA4LCAxKSwgNSlcbiAqIC8vPT4gU3VuIEZlYiAwMSAyMDE1IDAwOjAwOjAwXG4gKi9cblxuZnVuY3Rpb24gYWRkTW9udGhzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIoZGlydHlBbW91bnQpO1xuXG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICBpZiAoIWFtb3VudCkge1xuICAgIC8vIElmIDAgbW9udGhzLCBuby1vcCB0byBhdm9pZCBjaGFuZ2luZyB0aW1lcyBpbiB0aGUgaG91ciBiZWZvcmUgZW5kIG9mIERTVFxuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIGRheU9mTW9udGggPSBkYXRlLmdldERhdGUoKTsgLy8gVGhlIEpTIERhdGUgb2JqZWN0IHN1cHBvcnRzIGRhdGUgbWF0aCBieSBhY2NlcHRpbmcgb3V0LW9mLWJvdW5kcyB2YWx1ZXMgZm9yXG4gIC8vIG1vbnRoLCBkYXksIGV0Yy4gRm9yIGV4YW1wbGUsIG5ldyBEYXRlKDIwMjAsIDEsIDApIHJldHVybnMgMzEgRGVjIDIwMTkgYW5kXG4gIC8vIG5ldyBEYXRlKDIwMjAsIDEzLCAxKSByZXR1cm5zIDEgRmViIDIwMjEuICBUaGlzIGlzICphbG1vc3QqIHRoZSBiZWhhdmlvciB3ZVxuICAvLyB3YW50IGV4Y2VwdCB0aGF0IGRhdGVzIHdpbGwgd3JhcCBhcm91bmQgdGhlIGVuZCBvZiBhIG1vbnRoLCBtZWFuaW5nIHRoYXRcbiAgLy8gbmV3IERhdGUoMjAyMCwgMTMsIDMxKSB3aWxsIHJldHVybiAzIE1hciAyMDIxIG5vdCAyOCBGZWIgMjAyMSBhcyBkZXNpcmVkLiBTb1xuICAvLyB3ZSdsbCBkZWZhdWx0IHRvIHRoZSBlbmQgb2YgdGhlIGRlc2lyZWQgbW9udGggYnkgYWRkaW5nIDEgdG8gdGhlIGRlc2lyZWRcbiAgLy8gbW9udGggYW5kIHVzaW5nIGEgZGF0ZSBvZiAwIHRvIGJhY2sgdXAgb25lIGRheSB0byB0aGUgZW5kIG9mIHRoZSBkZXNpcmVkXG4gIC8vIG1vbnRoLlxuXG4gIHZhciBlbmRPZkRlc2lyZWRNb250aCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgZW5kT2ZEZXNpcmVkTW9udGguc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgYW1vdW50ICsgMSwgMCk7XG4gIHZhciBkYXlzSW5Nb250aCA9IGVuZE9mRGVzaXJlZE1vbnRoLmdldERhdGUoKTtcblxuICBpZiAoZGF5T2ZNb250aCA+PSBkYXlzSW5Nb250aCkge1xuICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgbW9udGgsIHRoZW4gdGhpcyBpcyB0aGUgY29ycmVjdCBkYXRlXG4gICAgLy8gYW5kIHdlJ3JlIGRvbmUuXG4gICAgcmV0dXJuIGVuZE9mRGVzaXJlZE1vbnRoO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgd2Ugbm93IGtub3cgdGhhdCBzZXR0aW5nIHRoZSBvcmlnaW5hbCBkYXktb2YtbW9udGggdmFsdWUgd29uJ3RcbiAgICAvLyBjYXVzZSBhbiBvdmVyZmxvdywgc28gc2V0IHRoZSBkZXNpcmVkIGRheS1vZi1tb250aC4gTm90ZSB0aGF0IHdlIGNhbid0XG4gICAgLy8ganVzdCBzZXQgdGhlIGRhdGUgb2YgYGVuZE9mRGVzaXJlZE1vbnRoYCBiZWNhdXNlIHRoYXQgb2JqZWN0IG1heSBoYXZlIGhhZFxuICAgIC8vIGl0cyB0aW1lIGNoYW5nZWQgaW4gdGhlIHVudXN1YWwgY2FzZSB3aGVyZSB3aGVyZSBhIERTVCB0cmFuc2l0aW9uIHdhcyBvblxuICAgIC8vIHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGggYW5kIGl0cyBsb2NhbCB0aW1lIHdhcyBpbiB0aGUgaG91ciBza2lwcGVkIG9yXG4gICAgLy8gcmVwZWF0ZWQgbmV4dCB0byBhIERTVCB0cmFuc2l0aW9uLiAgU28gd2UgdXNlIGBkYXRlYCBpbnN0ZWFkIHdoaWNoIGlzXG4gICAgLy8gZ3VhcmFudGVlZCB0byBzdGlsbCBoYXZlIHRoZSBvcmlnaW5hbCB0aW1lLlxuICAgIGRhdGUuc2V0RnVsbFllYXIoZW5kT2ZEZXNpcmVkTW9udGguZ2V0RnVsbFllYXIoKSwgZW5kT2ZEZXNpcmVkTW9udGguZ2V0TW9udGgoKSwgZGF5T2ZNb250aCk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9hZGRZZWFycy9pbmRleC5qc1xuXG5cblxuLyoqXG4gKiBAbmFtZSBhZGRZZWFyc1xuICogQGNhdGVnb3J5IFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHllYXJzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHllYXJzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIHllYXJzIHRvIGJlIGFkZGVkLiBQb3NpdGl2ZSBkZWNpbWFscyB3aWxsIGJlIHJvdW5kZWQgdXNpbmcgYE1hdGguZmxvb3JgLCBkZWNpbWFscyBsZXNzIHRoYW4gemVybyB3aWxsIGJlIHJvdW5kZWQgdXNpbmcgYE1hdGguY2VpbGAuXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIHllYXJzIGFkZGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCA1IHllYXJzIHRvIDEgU2VwdGVtYmVyIDIwMTQ6XG4gKiB2YXIgcmVzdWx0ID0gYWRkWWVhcnMobmV3IERhdGUoMjAxNCwgOCwgMSksIDUpXG4gKiAvLz0+IFN1biBTZXAgMDEgMjAxOSAwMDowMDowMFxuICovXG5cbmZ1bmN0aW9uIGFkZFllYXJzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIoZGlydHlBbW91bnQpO1xuICByZXR1cm4gYWRkTW9udGhzKGRpcnR5RGF0ZSwgYW1vdW50ICogMTIpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgeDogcmVjdC5sZWZ0LFxuICAgIHk6IHJlY3QudG9wXG4gIH07XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qc1xuLyo6OiBpbXBvcnQgdHlwZSB7IFdpbmRvdyB9IGZyb20gJy4uL3R5cGVzJzsgKi9cblxuLyo6OiBkZWNsYXJlIGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlOiBOb2RlIHwgV2luZG93KTogV2luZG93OyAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qc1xuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcblxuLyo6OiBkZWNsYXJlIGZ1bmN0aW9uIGlzRWxlbWVudChub2RlOiBtaXhlZCk6IGJvb2xlYW4gJWNoZWNrcyhub2RlIGluc3RhbmNlb2ZcbiAgRWxlbWVudCk7ICovXG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cbi8qOjogZGVjbGFyZSBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGU6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzKG5vZGUgaW5zdGFuY2VvZlxuICBIVE1MRWxlbWVudCk7ICovXG5cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuLyo6OiBkZWNsYXJlIGZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlOiBtaXhlZCk6IGJvb2xlYW4gJWNoZWNrcyhub2RlIGluc3RhbmNlb2ZcbiAgU2hhZG93Um9vdCk7ICovXG5cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzXG5cblxuXG5cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcbmZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXG5cblxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanNcblxuZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXG5cblxuXG5cblxuXG4gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5mdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQpO1xuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXG4vLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgfTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qc1xuXG5cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyAkRmxvd0ZpeE1lOiB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cbiAgICBlbGVtZW50Lmhvc3QgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWU6IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qc1xuXG5cblxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWU6IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcblxuXG5cblxuXG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlIFxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5cbmZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBnZXROb2RlTmFtZShzY3JvbGxQYXJlbnQpID09PSAnYm9keSc7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWU6IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanNcblxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG4gIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuXG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCkucG9zaXRpb24gIT09ICdzdGF0aWMnKSB7XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3Mud2lsbENoYW5nZSAmJiBjc3Mud2lsbENoYW5nZSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXG52YXIgZW51bXNfdG9wID0gJ3RvcCc7XG52YXIgYm90dG9tID0gJ2JvdHRvbSc7XG52YXIgcmlnaHQgPSAncmlnaHQnO1xudmFyIGxlZnQgPSAnbGVmdCc7XG52YXIgZW51bXNfYXV0byA9ICdhdXRvJztcbnZhciBiYXNlUGxhY2VtZW50cyA9IFtlbnVtc190b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xudmFyIGVudW1zX3N0YXJ0ID0gJ3N0YXJ0JztcbnZhciBlbnVtc19lbmQgPSAnZW5kJztcbnZhciBlbnVtc19jbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbnZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG52YXIgZW51bXNfcG9wcGVyID0gJ3BvcHBlcic7XG52YXIgZW51bXNfcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG52YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIGVudW1zX3N0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVudW1zX2VuZF0pO1xufSwgW10pO1xudmFyIGVudW1zX3BsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbZW51bXNfYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbnVtc19zdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbnVtc19lbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxudmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG52YXIgcmVhZCA9ICdyZWFkJztcbnZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxudmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG52YXIgbWFpbiA9ICdtYWluJztcbnZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG52YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xudmFyIHdyaXRlID0gJ3dyaXRlJztcbnZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xudmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXG4gLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlck1vZGlmaWVyc19vcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnNfb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzXG5mdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanNcbmZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZyksIGN1cnJlbnQpLCB7fSwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zKSwgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSksIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG52YXIgSU5GSU5JVEVfTE9PUF9FUlJPUiA9ICdQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLic7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMpLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zKSwgc3RhdGUub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbW9kaWZpZXJzIGlzIGludmFsaWQgZm9yIGFueSByZWFzb25cblxuICAgICAgICBpZiAoZmFsc2UpIHsgdmFyIF9nZXRDb21wdXRlZFN0eWxlLCBtYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnQsIGZsaXBNb2RpZmllciwgbW9kaWZpZXJzOyB9XG5cbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICBpZiAoZmFsc2UpIHt9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfX2RlYnVnX2xvb3BzX18gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChmYWxzZSkge31cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgaWYgKGZhbHNlKSB7fVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgICAgIF9yZWYzJG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG52YXIgY3JlYXRlUG9wcGVyX2NyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGV2ZW50TGlzdGVuZXJzID0gKHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcblxuZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXG5mdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1xuXG5cblxuXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgZW51bXNfdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIGVudW1zX3N0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IE1hdGguZmxvb3Iob2Zmc2V0c1ttYWluQXhpc10pIC0gTWF0aC5mbG9vcihyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW51bXNfZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IE1hdGguZmxvb3Iob2Zmc2V0c1ttYWluQXhpc10pICsgTWF0aC5jZWlsKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1xuXG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHNfcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtb2RpZmllcnNfcG9wcGVyT2Zmc2V0cyA9ICh7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHNfcG9wcGVyT2Zmc2V0cyxcbiAgZGF0YToge31cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXG5cblxuXG5cblxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHMoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiBNYXRoLnJvdW5kKHkgKiBkcHIpIC8gZHByIHx8IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlO1xuXG4gIHZhciBfcm91bmRPZmZzZXRzID0gcm91bmRPZmZzZXRzKG9mZnNldHMpLFxuICAgICAgeCA9IF9yb3VuZE9mZnNldHMueCxcbiAgICAgIHkgPSBfcm91bmRPZmZzZXRzLnk7XG5cbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSBlbnVtc190b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuICAgIH0gLy8gJEZsb3dGaXhNZTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuICAgIC8qOjogb2Zmc2V0UGFyZW50ID0gKG9mZnNldFBhcmVudDogRWxlbWVudCk7ICovXG5cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGVudW1zX3RvcCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB5IC09IG9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB4IC09IG9mZnNldFBhcmVudC5jbGllbnRXaWR0aCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMpLCB7fSwgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPCAyID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcyksIHt9LCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmMykge1xuICB2YXIgc3RhdGUgPSBfcmVmMy5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmU7XG5cbiAgaWYgKGZhbHNlKSB7IHZhciB0cmFuc2l0aW9uUHJvcGVydHk7IH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvblxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIpLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcyksIHt9LCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZVxuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3cpLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcyksIHt9LCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2VcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyKSwge30sIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9kaWZpZXJzX2NvbXB1dGVTdHlsZXMgPSAoe1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1xuXG4gLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVcblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhcHBseVN0eWxlc19lZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAgIC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtb2RpZmllcnNfYXBwbHlTdHlsZXMgPSAoe1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGFwcGx5U3R5bGVzX2VmZmVjdCxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzXG5cblxuZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgZW51bXNfdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMpLCB7fSwge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldF9vZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBlbnVtc19wbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9kaWZpZXJzX29mZnNldCA9ICh7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRfb2Zmc2V0XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1xudmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcbnZhciBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudF9oYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudF9oYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzXG5cblxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwOyAvLyBOQjogVGhpcyBpc24ndCBzdXBwb3J0ZWQgb24gaU9TIDw9IDEyLiBJZiB0aGUga2V5Ym9hcmQgaXMgb3BlbiwgdGhlIHBvcHBlclxuICAvLyBjYW4gYmUgb2JzY3VyZWQgdW5kZXJuZWF0aCBpdC5cbiAgLy8gQWxzbywgYGh0bWwuY2xpZW50SGVpZ2h0YCBhZGRzIHRoZSBib3R0b20gYmFyIGhlaWdodCBpbiBTYWZhcmkgaU9TLCBldmVuXG4gIC8vIGlmIGl0IGlzbid0IG9wZW4sIHNvIGlmIHRoaXMgaXNuJ3QgYXZhaWxhYmxlLCB0aGUgcG9wcGVyIHdpbGwgYmUgZGV0ZWN0ZWRcbiAgLy8gdG8gb3ZlcmZsb3cgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIHRvbyBlYXJseS5cblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDsgLy8gVXNlcyBMYXlvdXQgVmlld3BvcnQgKGxpa2UgQ2hyb21lOyBTYWZhcmkgZG9lcyBub3QgY3VycmVudGx5KVxuICAgIC8vIEluIENocm9tZSwgaXQgcmV0dXJucyBhIHZhbHVlIHZlcnkgY2xvc2UgdG8gMCAoKy8tKSBidXQgY29udGFpbnMgcm91bmRpbmdcbiAgICAvLyBlcnJvcnMgZHVlIHRvIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIHNvIHdlIG5lZWQgdG8gY2hlY2sgcHJlY2lzaW9uLlxuICAgIC8vIFNhZmFyaSByZXR1cm5zIGEgbnVtYmVyIDw9IDAsIHVzdWFsbHkgPCAtMSB3aGVuIHBpbmNoLXpvb21lZFxuICAgIC8vIEZlYXR1cmUgZGV0ZWN0aW9uIGZhaWxzIGluIG1vYmlsZSBlbXVsYXRpb24gbW9kZSBpbiBDaHJvbWUuXG4gICAgLy8gTWF0aC5hYnMod2luLmlubmVyV2lkdGggLyB2aXN1YWxWaWV3cG9ydC5zY2FsZSAtIHZpc3VhbFZpZXdwb3J0LndpZHRoKSA8XG4gICAgLy8gMC4wMDFcbiAgICAvLyBGYWxsYmFjayBoZXJlOiBcIk5vdCBTYWZhcmlcIiB1c2VyQWdlbnRcblxuICAgIGlmICghL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzXG5cblxuXG4gLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzXG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAoaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWU6IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanNcbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWN0KSwge30sIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnggPSByZWN0LmxlZnQ7XG4gIHJlY3QueSA9IHJlY3QudG9wO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpKSA6IGlzSFRNTEVsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KTtcbiAgICBhY2NSZWN0LnRvcCA9IE1hdGgubWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IE1hdGgubWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gTWF0aC5taW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBNYXRoLm1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1xuZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1xuXG5mdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSksIHBhZGRpbmdPYmplY3QpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1xuZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1xuXG5cblxuXG5cblxuXG5cbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gZW51bXNfY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gZW51bXNfcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBlbnVtc19wb3BwZXIgPyBlbnVtc19yZWZlcmVuY2UgOiBlbnVtc19wb3BwZXI7XG4gIHZhciByZWZlcmVuY2VFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2VFbGVtZW50KTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QpLCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBlbnVtc19wb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBlbnVtc19wb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW2VudW1zX3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1xuXG5cblxuXG5cbi8qOjogdHlwZSBPdmVyZmxvd3NNYXAgPSB7IFtDb21wdXRlZFBsYWNlbWVudF06IG51bWJlciB9OyAqL1xuXG4vKjs7IHR5cGUgT3ZlcmZsb3dzTWFwID0geyBba2V5IGluIENvbXB1dGVkUGxhY2VtZW50XTogbnVtYmVyIH07ICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IGVudW1zX3BsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7IC8vICRGbG93Rml4TWVcblxuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblxuICAgIGlmIChmYWxzZSkge31cbiAgfSAvLyAkRmxvd0ZpeE1lOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qc1xuXG5cblxuXG5cblxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGVudW1zX2F1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGVudW1zX2F1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IGVudW1zX3N0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW2VudW1zX3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IGVudW1zX3RvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9kaWZpZXJzX2ZsaXAgPSAoe1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanNcbmZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qc1xuZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMpLCB7fSwge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gZW51bXNfdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBlbnVtc19zdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBlbnVtc19zdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gdGV0aGVyT2Zmc2V0VmFsdWUgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWU7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdW21haW5BeGlzXSA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gTWF0aC5taW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IE1hdGgubWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBlbnVtc190b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKF9taW4sIF9vZmZzZXQsIF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtb2RpZmllcnNfcHJldmVudE92ZXJmbG93ID0gKHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qc1xuXG5cblxuXG5cblxuXG5cblxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWUgKyBcIiNwZXJzaXN0ZW50XCJdLnBhZGRpbmc7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gZW51bXNfdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gYXJyb3dfZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoZmFsc2UpIHt9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICBpZiAoZmFsc2UpIHt9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lICsgXCIjcGVyc2lzdGVudFwiXSA9IHtcbiAgICBwYWRkaW5nOiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpXG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtb2RpZmllcnNfYXJyb3cgPSAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogYXJyb3dfZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzXG5cblxuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbZW51bXNfdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlX2hpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciksIHt9LCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtb2RpZmllcnNfaGlkZSA9ICh7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVfaGlkZVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3BwZXJfZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgbW9kaWZpZXJzX3BvcHBlck9mZnNldHMsIG1vZGlmaWVyc19jb21wdXRlU3R5bGVzLCBtb2RpZmllcnNfYXBwbHlTdHlsZXMsIG1vZGlmaWVyc19vZmZzZXQsIG1vZGlmaWVyc19mbGlwLCBtb2RpZmllcnNfcHJldmVudE92ZXJmbG93LCBtb2RpZmllcnNfYXJyb3csIG1vZGlmaWVyc19oaWRlXTtcbnZhciBwb3BwZXJfY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IHBvcHBlcl9kZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQm9vbGVhbi5qc1xudmFyIGlzQm9vbGVhbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2Njc5XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc051bWJlci5qc1xudmFyIGlzTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUwMWVcIik7XG52YXIgaXNOdW1iZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNOdW1iZXIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qc1xudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyYTBcIik7XG52YXIgaXNTdHJpbmdfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNTdHJpbmcpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qc1xudmFyIGlzQXJyYXlMaWtlT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRjYmVcIik7XG52YXIgaXNBcnJheUxpa2VPYmplY3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNBcnJheUxpa2VPYmplY3QpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzXG52YXIgaXNGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5NTIwXCIpO1xudmFyIGlzRnVuY3Rpb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaXNGdW5jdGlvbik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVW5kZWZpbmVkLmpzXG52YXIgaXNVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGNmZVwiKTtcbnZhciBpc1VuZGVmaW5lZF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc1VuZGVmaW5lZCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRGF0ZS5qc1xudmFyIGlzRGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MjIwXCIpO1xudmFyIGlzRGF0ZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc0RhdGUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jbGFtcC5qc1xudmFyIGNsYW1wID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY2NzhcIik7XG52YXIgY2xhbXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY2xhbXApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanNcbnZhciBnZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWIwMlwiKTtcbnZhciBnZXRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZ2V0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvc2V0LmpzXG52YXIgc2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjBmNWNcIik7XG52YXIgc2V0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHNldCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcFZhbHVlcy5qc1xudmFyIG1hcFZhbHVlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZTg2XCIpO1xudmFyIG1hcFZhbHVlc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihtYXBWYWx1ZXMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BhaXJzLmpzXG52YXIgdG9QYWlycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNTQyXCIpO1xudmFyIHRvUGFpcnNfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odG9QYWlycyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlZmF1bHRzLmpzXG52YXIgZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTVhZVwiKTtcbnZhciBkZWZhdWx0c19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihkZWZhdWx0cyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlZmF1bHRzRGVlcC5qc1xudmFyIGRlZmF1bHRzRGVlcCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzZjg0XCIpO1xudmFyIGRlZmF1bHRzRGVlcF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihkZWZhdWx0c0RlZXApO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9waWNrLmpzXG52YXIgcGljayA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNTkzXCIpO1xudmFyIHBpY2tfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocGljayk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL29taXQuanNcbnZhciBvbWl0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjNlZWFcIik7XG52YXIgb21pdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihvbWl0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzLmpzXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM4NTJcIik7XG52YXIgaGFzX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGhhcyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcC5qc1xudmFyIGxvZGFzaF9tYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZGQ2MVwiKTtcbnZhciBtYXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX21hcCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hlYWQuanNcbnZhciBoZWFkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE1OWJcIik7XG52YXIgaGVhZF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihoZWFkKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFzdC5qc1xudmFyIGxhc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDQxNlwiKTtcbnZhciBsYXN0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxhc3QpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zb21lLmpzXG52YXIgc29tZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMDkyXCIpO1xudmFyIHNvbWVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oc29tZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL18uanNcbi8vIFR5cGUgdXRpbHNcblxuXG5cblxuXG5cbiAvLyBOdW1iZXIgdXRpbHNcblxuIC8vIE9iamVjdCB1dGlsc1xuXG5cblxuXG5cblxuXG5cblxuIC8vIENvbGxlY3Rpb24gdXRpbHNcblxuXG5cblxuIC8vIFR5cGUgY2hlY2tlcnNcblxuY29uc3QgZ2V0VHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgX2lzRGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gaXNEYXRlX2RlZmF1bHQoKSh2YWx1ZSkgJiYgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSk7XG59O1xuY29uc3QgaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIGdldFR5cGUodmFsdWUpID09PSAnT2JqZWN0Jztcbn07IC8vIE9iamVjdCB1dGlsc1xuXG5jb25zdCBfaGFzID0gaGFzX2RlZmF1bHQuYTtcbmNvbnN0IGhhc0FueSA9IGZ1bmN0aW9uIChvYmosIHByb3BzKSB7XG4gIHJldHVybiBzb21lX2RlZmF1bHQoKShwcm9wcywgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gaGFzX2RlZmF1bHQoKShvYmosIHApO1xuICB9KTtcbn07IC8vIENvbGxlY3Rpb24gdXRpbHNcblxuY29uc3QgX3NvbWUgPSBzb21lX2RlZmF1bHQuYTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL2hlbHBlcnMuanNcblxuXG5jb25zdCBwYWQgPSBmdW5jdGlvbiAodmFsLCBsZW4sIGNoYXIgPSAnMCcpIHtcbiAgdmFsID0gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKHZhbCkgOiAnJztcbiAgbGVuID0gbGVuIHx8IDI7XG5cbiAgd2hpbGUgKHZhbC5sZW5ndGggPCBsZW4pIHtcbiAgICB2YWwgPSBgJHtjaGFyfSR7dmFsfWA7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcbmNvbnN0IGV2YWxGbiA9IGZ1bmN0aW9uIChmbiwgYXJncykge1xuICByZXR1cm4gaXNGdW5jdGlvbl9kZWZhdWx0KCkoZm4pID8gZm4oYXJncykgOiBmbjtcbn07XG5jb25zdCBwYWdlSXNWYWxpZCA9IGZ1bmN0aW9uIChwYWdlKSB7XG4gIHJldHVybiAhIShwYWdlICYmIHBhZ2UubW9udGggJiYgcGFnZS55ZWFyKTtcbn07XG5jb25zdCBtZXJnZUV2ZW50cyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoW2tleSwgdmFsdWVdKSB7XG4gICAgICBpZiAoIXJlc3VsdFtrZXldKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0X2RlZmF1bHQoKShyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5XSA9IFtyZXN1bHRba2V5XSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBwYWdlSXNCZWZvcmVQYWdlID0gZnVuY3Rpb24gKHBhZ2UsIGNvbXBhcmVQYWdlKSB7XG4gIGlmICghcGFnZUlzVmFsaWQocGFnZSkgfHwgIXBhZ2VJc1ZhbGlkKGNvbXBhcmVQYWdlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAocGFnZS55ZWFyID09PSBjb21wYXJlUGFnZS55ZWFyKSByZXR1cm4gcGFnZS5tb250aCA8IGNvbXBhcmVQYWdlLm1vbnRoO1xuICByZXR1cm4gcGFnZS55ZWFyIDwgY29tcGFyZVBhZ2UueWVhcjtcbn07XG5jb25zdCBwYWdlSXNBZnRlclBhZ2UgPSBmdW5jdGlvbiAocGFnZSwgY29tcGFyZVBhZ2UpIHtcbiAgaWYgKCFwYWdlSXNWYWxpZChwYWdlKSB8fCAhcGFnZUlzVmFsaWQoY29tcGFyZVBhZ2UpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwYWdlLnllYXIgPT09IGNvbXBhcmVQYWdlLnllYXIpIHJldHVybiBwYWdlLm1vbnRoID4gY29tcGFyZVBhZ2UubW9udGg7XG4gIHJldHVybiBwYWdlLnllYXIgPiBjb21wYXJlUGFnZS55ZWFyO1xufTtcbmNvbnN0IHBhZ2VJc0JldHdlZW5QYWdlcyA9IGZ1bmN0aW9uIChwYWdlLCBmcm9tUGFnZSwgdG9QYWdlKSB7XG4gIHJldHVybiAocGFnZSB8fCBmYWxzZSkgJiYgIXBhZ2VJc0JlZm9yZVBhZ2UocGFnZSwgZnJvbVBhZ2UpICYmICFwYWdlSXNBZnRlclBhZ2UocGFnZSwgdG9QYWdlKTtcbn07XG5jb25zdCBwYWdlSXNFcXVhbFRvUGFnZSA9IGZ1bmN0aW9uIChhUGFnZSwgYlBhZ2UpIHtcbiAgaWYgKCFhUGFnZSAmJiBiUGFnZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYVBhZ2UgJiYgIWJQYWdlKSByZXR1cm4gZmFsc2U7XG4gIGlmICghYVBhZ2UgJiYgIWJQYWdlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGFQYWdlLm1vbnRoID09PSBiUGFnZS5tb250aCAmJiBhUGFnZS55ZWFyID09PSBiUGFnZS55ZWFyO1xufTtcbmNvbnN0IHBhZ2VGb3JEYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgaWYgKCFkYXRlKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBtb250aDogZGF0ZS5nZXRNb250aCgpICsgMSxcbiAgICB5ZWFyOiBkYXRlLmdldEZ1bGxZZWFyKClcbiAgfTtcbn07XG5jb25zdCBhZGRQYWdlcyA9IGZ1bmN0aW9uICh7XG4gIG1vbnRoLFxuICB5ZWFyXG59LCBjb3VudCkge1xuICBjb25zdCBpbmNyID0gY291bnQgPiAwID8gMSA6IC0xO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5hYnMoY291bnQpOyBpKyspIHtcbiAgICBtb250aCArPSBpbmNyO1xuXG4gICAgaWYgKG1vbnRoID4gMTIpIHtcbiAgICAgIG1vbnRoID0gMTtcbiAgICAgIHllYXIrKztcbiAgICB9IGVsc2UgaWYgKG1vbnRoIDwgMSkge1xuICAgICAgbW9udGggPSAxMjtcbiAgICAgIHllYXItLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1vbnRoLFxuICAgIHllYXJcbiAgfTtcbn07XG5jb25zdCBwYWdlRm9yVGhpc01vbnRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGFnZUZvckRhdGUobmV3IERhdGUoKSk7XG59O1xuY29uc3QgcGFnZUZvck5leHRNb250aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGFkZFBhZ2VzKHBhZ2VGb3JUaGlzTW9udGgoKSwgMSk7XG59O1xuY29uc3QgcGFnZUZvclByZXZNb250aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGFkZFBhZ2VzKHBhZ2VGb3JUaGlzTW9udGgoKSwgLTEpO1xufTtcbmNvbnN0IGdldE1heFBhZ2UgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICBpZiAoIXByZXYpIHJldHVybiBjdXJyO1xuICAgIGlmICghY3VycikgcmV0dXJuIHByZXY7XG4gICAgcmV0dXJuIHBhZ2VJc0FmdGVyUGFnZShjdXJyLCBwcmV2KSA/IGN1cnIgOiBwcmV2O1xuICB9KTtcbn07XG5mdW5jdGlvbiBkYXRlc0FyZUVxdWFsKGEsIGIpIHtcbiAgY29uc3QgYUlzRGF0ZSA9IF9pc0RhdGUoYSk7XG4gIGNvbnN0IGJJc0RhdGUgPSBfaXNEYXRlKGIpO1xuICBpZiAoIWFJc0RhdGUgJiYgIWJJc0RhdGUpIHJldHVybiB0cnVlO1xuICBpZiAoYUlzRGF0ZSAhPT0gYklzRGF0ZSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xufVxuY29uc3QgYXJyYXlIYXNJdGVtcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3RfZGVmYXVsdCgpKGFycmF5KSAmJiBhcnJheS5sZW5ndGg7XG59O1xuY29uc3QgZmluZEFuY2VzdG9yID0gZnVuY3Rpb24gKGVsLCBmbikge1xuICBpZiAoIWVsKSByZXR1cm4gbnVsbDtcbiAgaWYgKGZuICYmIGZuKGVsKSkgcmV0dXJuIGVsO1xuICByZXR1cm4gZmluZEFuY2VzdG9yKGVsLnBhcmVudEVsZW1lbnQsIGZuKTtcbn07XG5jb25zdCBlbGVtZW50SGFzQW5jZXN0b3IgPSBmdW5jdGlvbiAoZWwsIGFuY2VzdG9yKSB7XG4gIHJldHVybiAhIWZpbmRBbmNlc3RvcihlbCwgZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZSA9PT0gYW5jZXN0b3I7XG4gIH0pO1xufTtcbmNvbnN0IGVsZW1lbnRQb3NpdGlvbkluQW5jZXN0b3IgPSBmdW5jdGlvbiAoZWwsIGFuY2VzdG9yKSB7XG4gIGxldCB0b3AgPSAwO1xuICBsZXQgbGVmdCA9IDA7XG5cbiAgZG8ge1xuICAgIHRvcCArPSBlbC5vZmZzZXRUb3AgfHwgMDtcbiAgICBsZWZ0ICs9IGVsLm9mZnNldExlZnQgfHwgMDtcbiAgICBlbCA9IGVsLm9mZnNldFBhcmVudDtcbiAgfSB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2VzdG9yKTtcblxuICByZXR1cm4ge1xuICAgIHRvcCxcbiAgICBsZWZ0XG4gIH07XG59O1xuY29uc3QgbWl4aW5PcHRpb25hbFByb3BzID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBwcm9wcykge1xuICBjb25zdCBhc3NpZ25lZCA9IFtdO1xuICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAubmFtZSB8fCBwLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbWl4aW4gPSBwLm1peGluO1xuICAgIGNvbnN0IHZhbGlkYXRlID0gcC52YWxpZGF0ZTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBuYW1lKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWxpZGF0ZSA/IHZhbGlkYXRlKHNvdXJjZVtuYW1lXSkgOiBzb3VyY2VbbmFtZV07XG4gICAgICB0YXJnZXRbbmFtZV0gPSBtaXhpbiAmJiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLm1peGluLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfSA6IHZhbHVlO1xuICAgICAgYXNzaWduZWQucHVzaChuYW1lKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRhcmdldCxcbiAgICBhc3NpZ25lZDogYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBudWxsXG4gIH07XG59O1xuY29uc3Qgb24gPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgaWYgKGVsZW1lbnQgJiYgZXZlbnQgJiYgaGFuZGxlcikge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgZmFsc2UpO1xuICB9XG59O1xuY29uc3Qgb2ZmID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gIGlmIChlbGVtZW50ICYmIGV2ZW50KSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn07XG5jb25zdCBlbGVtZW50Q29udGFpbnMgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2hpbGQpIHtcbiAgcmV0dXJuICEhZWxlbWVudCAmJiAhIWNoaWxkICYmIChlbGVtZW50ID09PSBjaGlsZCB8fCBlbGVtZW50LmNvbnRhaW5zKGNoaWxkKSk7XG59O1xuY29uc3Qgb25TcGFjZU9yRW50ZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgaWYgKGV2ZW50LmtleSA9PT0gJyAnIHx8IGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgIGhhbmRsZXIoZXZlbnQpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn07XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbmNvbnN0IGNyZWF0ZUd1aWQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFM0KCkge1xuICAgIHJldHVybiAoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgcmV0dXJuIGAke1M0KCkgKyBTNCgpfS0ke1M0KCl9LSR7UzQoKX0tJHtTNCgpfS0ke1M0KCl9JHtTNCgpfSR7UzQoKX1gO1xufTtcbmZ1bmN0aW9uIGhlbHBlcnNfaGFzaChzdHIpIHtcbiAgbGV0IGhhc2hjb2RlID0gMDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgY2hyO1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGhhc2hjb2RlO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoY29kZSA9IChoYXNoY29kZSA8PCA1KSAtIGhhc2hjb2RlICsgY2hyO1xuICAgIGhhc2hjb2RlIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGhhc2hjb2RlO1xufVxuLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy90b3VjaC5qc1xuXG4gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHRhcHMgb3IgY2xpY2tzXG4vLyBDYW4ndCBqdXN0IHJlbHkgb24gJ2NsaWNrJyBldmVudCBiZWNhdXNlIG9mIG9kZGl0aWVzIGluIG1vYmlsZSBTYWZhcmlcblxuY29uc3QgYWRkVGFwT3JDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgaGFuZGxlcikge1xuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciB8fCAhaXNGdW5jdGlvbl9kZWZhdWx0KCkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBTdGF0ZSB2YXJpYWJsZXNcblxuXG4gIGxldCB0YXAgPSBmYWxzZTtcbiAgbGV0IGRpc2FibGVDbGljayA9IGZhbHNlO1xuXG4gIGNvbnN0IHRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRhcCA9IHRydWU7XG4gIH07XG5cbiAgY29uc3QgdG91Y2htb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0YXAgPSBmYWxzZTtcbiAgfTtcblxuICBjb25zdCB0b3VjaGVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0YXApIHtcbiAgICAgIC8vIFJlc2V0IHN0YXRlXG4gICAgICB0YXAgPSBmYWxzZTsgLy8gRGlzYWJsZSBjbGljayBzbyB3ZSBkb24ndCBjYWxsIGhhbmRsZXIgdHdpY2VcblxuICAgICAgZGlzYWJsZUNsaWNrID0gdHJ1ZTtcbiAgICAgIGhhbmRsZXIoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gTWFrZSBzdXJlIHRhcCBldmVudCBoYXNuJ3QgZGlzYWJsZWQgY2xpY2tcblxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgIWRpc2FibGVDbGljaykge1xuICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgfSAvLyBSZXNldCBzdGF0ZVxuXG5cbiAgICBkaXNhYmxlQ2xpY2sgPSBmYWxzZTtcbiAgfTsgLy8gQWRkIGV2ZW50IGhhbmRsZXJzXG5cblxuICBvbihlbGVtZW50LCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQpO1xuICBvbihlbGVtZW50LCAndG91Y2htb3ZlJywgdG91Y2htb3ZlKTtcbiAgb24oZWxlbWVudCwgJ2NsaWNrJywgdG91Y2hlbmQpO1xuICBvbihlbGVtZW50LCAndG91Y2hlbmQnLCB0b3VjaGVuZCk7IC8vIFJldHVybiBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgZXZlbnQgaGFuZGxlcnNcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG9mZihlbGVtZW50LCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnQpO1xuICAgIG9mZihlbGVtZW50LCAndG91Y2htb3ZlJywgdG91Y2htb3ZlKTtcbiAgICBvZmYoZWxlbWVudCwgJ2NsaWNrJywgdG91Y2hlbmQpO1xuICAgIG9mZihlbGVtZW50LCAndG91Y2hlbmQnLCB0b3VjaGVuZCk7XG4gIH07XG59O1xuY29uc3QgYWRkSG9yaXpvbnRhbFN3aXBlSGFuZGxlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBoYW5kbGVyLCB7XG4gIG1heFN3aXBlVGltZSxcbiAgbWluSG9yaXpvbnRhbFN3aXBlRGlzdGFuY2UsXG4gIG1heFZlcnRpY2FsU3dpcGVEaXN0YW5jZVxufSkge1xuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciB8fCAhaXNGdW5jdGlvbl9kZWZhdWx0KCkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBTdGF0ZSB2YXJpYWJsZXNcblxuXG4gIGxldCBzdGFydFggPSAwO1xuICBsZXQgc3RhcnRZID0gMDtcbiAgbGV0IHN0YXJ0VGltZSA9IG51bGw7XG4gIGxldCBpc1N3aXBpbmcgPSBmYWxzZTsgLy8gVG91Y2ggc3RhcnQgaGFuZGxlclxuXG4gIGZ1bmN0aW9uIHRvdWNoU3RhcnQoZSkge1xuICAgIGNvbnN0IHQgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHN0YXJ0WCA9IHQuc2NyZWVuWDtcbiAgICBzdGFydFkgPSB0LnNjcmVlblk7XG4gICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaXNTd2lwaW5nID0gdHJ1ZTtcbiAgfSAvLyBUb3VjaCBlbmQgaGFuZGxlclxuXG5cbiAgZnVuY3Rpb24gdG91Y2hFbmQoZSkge1xuICAgIGlmICghaXNTd2lwaW5nKSByZXR1cm47XG4gICAgaXNTd2lwaW5nID0gZmFsc2U7XG4gICAgY29uc3QgdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgY29uc3QgZGVsdGFYID0gdC5zY3JlZW5YIC0gc3RhcnRYO1xuICAgIGNvbnN0IGRlbHRhWSA9IHQuc2NyZWVuWSAtIHN0YXJ0WTtcbiAgICBjb25zdCBkZWx0YVRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcblxuICAgIGlmIChkZWx0YVRpbWUgPCBtYXhTd2lwZVRpbWUpIHtcbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YVgpID49IG1pbkhvcml6b250YWxTd2lwZURpc3RhbmNlICYmIE1hdGguYWJzKGRlbHRhWSkgPD0gbWF4VmVydGljYWxTd2lwZURpc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IHtcbiAgICAgICAgICB0b0xlZnQ6IGZhbHNlLFxuICAgICAgICAgIHRvUmlnaHQ6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAvLyBTd2lwZSB0byB0aGUgbGVmdFxuICAgICAgICAgIGFyZy50b0xlZnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFN3aXBlIHRvIHRoZSByaWdodFxuICAgICAgICAgIGFyZy50b1JpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZXIoYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQWRkIGV2ZW50IGhhbmRsZXJzXG5cblxuICBvbihlbGVtZW50LCAndG91Y2hzdGFydCcsIHRvdWNoU3RhcnQpOyAvLyBvbihlbGVtZW50LCAndG91Y2htb3ZlJywgdG91Y2htb3ZlKTtcblxuICBvbihlbGVtZW50LCAndG91Y2hlbmQnLCB0b3VjaEVuZCk7IC8vIFJldHVybiBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgZXZlbnQgaGFuZGxlcnNcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG9mZihlbGVtZW50LCAndG91Y2hzdGFydCcsIHRvdWNoU3RhcnQpOyAvLyBvZmYoZWxlbWVudCwgJ3RvdWNobW92ZScsIHRvdWNobW92ZSk7XG5cbiAgICBvZmYoZWxlbWVudCwgJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xuICB9O1xufTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9Qb3BvdmVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBQb3BvdmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1BvcG92ZXInLFxuXG4gIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgIGNsYXNzOiBbJ3ZjLXBvcG92ZXItY29udGVudC13cmFwcGVyJywge1xuICAgICAgICAnaXMtaW50ZXJhY3RpdmUnOiB0aGlzLmlzSW50ZXJhY3RpdmVcbiAgICAgIH1dLFxuICAgICAgcmVmOiAncG9wb3ZlcidcbiAgICB9LCBbaCgndHJhbnNpdGlvbicsIHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG5hbWU6IHRoaXMudHJhbnNpdGlvbixcbiAgICAgICAgYXBwZWFyOiB0cnVlXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgYmVmb3JlRW50ZXI6IHRoaXMuYmVmb3JlRW50ZXIsXG4gICAgICAgIGFmdGVyRW50ZXI6IHRoaXMuYWZ0ZXJFbnRlcixcbiAgICAgICAgYmVmb3JlTGVhdmU6IHRoaXMuYmVmb3JlTGVhdmUsXG4gICAgICAgIGFmdGVyTGVhdmU6IHRoaXMuYWZ0ZXJMZWF2ZVxuICAgICAgfVxuICAgIH0sIFt0aGlzLmlzVmlzaWJsZSAmJiBoKCdkaXYnLCB7XG4gICAgICBhdHRyczoge1xuICAgICAgICB0YWJpbmRleDogLTFcbiAgICAgIH0sXG4gICAgICBjbGFzczogWyd2Yy1wb3BvdmVyLWNvbnRlbnQnLCBgZGlyZWN0aW9uLSR7dGhpcy5kaXJlY3Rpb259YCwgdGhpcy5jb250ZW50Q2xhc3NdXG4gICAgfSwgW3RoaXMuY29udGVudCwgaCgnc3BhbicsIHtcbiAgICAgIGNsYXNzOiBbJ3ZjLXBvcG92ZXItY2FyZXQnLCBgZGlyZWN0aW9uLSR7dGhpcy5kaXJlY3Rpb259YCwgYGFsaWduLSR7dGhpcy5hbGlnbm1lbnR9YF1cbiAgICB9KV0pXSldKTtcbiAgfSxcblxuICBwcm9wczoge1xuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3NsaWRlLWZhZGUnXG4gICAgfSxcbiAgICBjb250ZW50Q2xhc3M6IFN0cmluZ1xuICB9LFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZjogbnVsbCxcbiAgICAgIG9wdHM6IG51bGwsXG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgIGlzSW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgICAgIGlzRm9jdXNlZDogZmFsc2UsXG4gICAgICBzaG93RGVsYXk6IDEwLFxuICAgICAgaGlkZURlbGF5OiAxMTAsXG4gICAgICBhdXRvSGlkZTogZmFsc2UsXG4gICAgICBwb3BwZXJFbDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBjb250ZW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb25fZGVmYXVsdCgpKHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQpICYmIHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQoe1xuICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgICBhbGlnbm1lbnQ6IHRoaXMuYWxpZ25tZW50LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgIHVwZGF0ZUxheW91dDogdGhpcy51cGRhdGUsXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmhpZGUob3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH0pIHx8IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgfSxcblxuICAgIHBvcHBlck9wdGlvbnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMucGxhY2VtZW50LFxuICAgICAgICBzdHJhdGVneTogdGhpcy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScsXG4gICAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgICBuYW1lOiAnb25VcGRhdGUnLFxuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcbiAgICAgICAgICBmbjogdGhpcy5vblBvcHBlclVwZGF0ZVxuICAgICAgICB9LCAuLi4odGhpcy5tb2RpZmllcnMgfHwgW10pXSxcbiAgICAgICAgb25GaXJzdFVwZGF0ZTogdGhpcy5vblBvcHBlclVwZGF0ZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgaXNWaXNpYmxlKCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMucmVmICYmIHRoaXMuY29udGVudCk7XG4gICAgfSxcblxuICAgIGRpcmVjdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsYWNlbWVudCAmJiB0aGlzLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdIHx8ICdib3R0b20nO1xuICAgIH0sXG5cbiAgICBhbGlnbm1lbnQoKSB7XG4gICAgICBjb25zdCBpc0xlZnRSaWdodCA9IHRoaXMuZGlyZWN0aW9uID09PSAnbGVmdCcgfHwgdGhpcy5kaXJlY3Rpb24gPT09ICdyaWdodCc7XG4gICAgICBsZXQgYWxpZ25tZW50ID0gdGhpcy5wbGFjZW1lbnQuc3BsaXQoJy0nKTtcbiAgICAgIGFsaWdubWVudCA9IGFsaWdubWVudC5sZW5ndGggPiAxID8gYWxpZ25tZW50WzFdIDogJyc7XG5cbiAgICAgIGlmIChbJ3N0YXJ0JywgJ3RvcCcsICdsZWZ0J10uaW5jbHVkZXMoYWxpZ25tZW50KSkge1xuICAgICAgICByZXR1cm4gaXNMZWZ0UmlnaHQgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgaWYgKFsnZW5kJywgJ2JvdHRvbScsICdyaWdodCddLmluY2x1ZGVzKGFsaWdubWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVmdFJpZ2h0ID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNMZWZ0UmlnaHQgPyAnbWlkZGxlJyA6ICdjZW50ZXInO1xuICAgIH0sXG5cbiAgICBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwb3BvdmVyc1t0aGlzLmlkXTtcbiAgICB9XG5cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcHRzKHZhbCwgb2xkVmFsKSB7XG4gICAgICBpZiAob2xkVmFsICYmIG9sZFZhbC5jYWxsYmFjaykge1xuICAgICAgICBvbGRWYWwuY2FsbGJhY2soeyAuLi5vbGRWYWwsXG4gICAgICAgICAgY29tcGxldGVkOiAhdmFsLFxuICAgICAgICAgIHJlYXNvbjogdmFsID8gJ092ZXJyaWRkZW4gYnkgYWN0aW9uJyA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnBvcG92ZXJFbCA9IHRoaXMuJHJlZnMucG9wb3ZlcjtcbiAgICB0aGlzLmFkZEV2ZW50cygpO1xuICB9LFxuXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudHMoKTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgYWRkRXZlbnRzKCkge1xuICAgICAgb24odGhpcy5wb3BvdmVyRWwsICdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICBvbih0aGlzLnBvcG92ZXJFbCwgJ21vdXNlb3ZlcicsIHRoaXMub25Nb3VzZU92ZXIpO1xuICAgICAgb24odGhpcy5wb3BvdmVyRWwsICdtb3VzZWxlYXZlJywgdGhpcy5vbk1vdXNlTGVhdmUpO1xuICAgICAgb24odGhpcy5wb3BvdmVyRWwsICdmb2N1c2luJywgdGhpcy5vbkZvY3VzSW4pO1xuICAgICAgb24odGhpcy5wb3BvdmVyRWwsICdmb2N1c291dCcsIHRoaXMub25Gb2N1c091dCk7XG4gICAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLm9uRG9jdW1lbnRLZXlkb3duKTtcbiAgICAgIHRoaXMucmVtb3ZlRG9jSGFuZGxlciA9IGFkZFRhcE9yQ2xpY2tIYW5kbGVyKGRvY3VtZW50LCB0aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICBvbihkb2N1bWVudCwgJ3Nob3ctcG9wb3ZlcicsIHRoaXMub25Eb2N1bWVudFNob3dQb3BvdmVyKTtcbiAgICAgIG9uKGRvY3VtZW50LCAnaGlkZS1wb3BvdmVyJywgdGhpcy5vbkRvY3VtZW50SGlkZVBvcG92ZXIpO1xuICAgICAgb24oZG9jdW1lbnQsICd0b2dnbGUtcG9wb3ZlcicsIHRoaXMub25Eb2N1bWVudFRvZ2dsZVBvcG92ZXIpO1xuICAgICAgb24oZG9jdW1lbnQsICd1cGRhdGUtcG9wb3ZlcicsIHRoaXMub25Eb2N1bWVudFVwZGF0ZVBvcG92ZXIpO1xuICAgIH0sXG5cbiAgICByZW1vdmVFdmVudHMoKSB7XG4gICAgICBvZmYodGhpcy5wb3BvdmVyRWwsICdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICBvZmYodGhpcy5wb3BvdmVyRWwsICdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2VPdmVyKTtcbiAgICAgIG9mZih0aGlzLnBvcG92ZXJFbCwgJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSk7XG4gICAgICBvZmYodGhpcy5wb3BvdmVyRWwsICdmb2N1c2luJywgdGhpcy5vbkZvY3VzSW4pO1xuICAgICAgb2ZmKHRoaXMucG9wb3ZlckVsLCAnZm9jdXNvdXQnLCB0aGlzLm9uRm9jdXNPdXQpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMub25Eb2N1bWVudEtleWRvd24pO1xuICAgICAgaWYgKHRoaXMucmVtb3ZlRG9jSGFuZGxlcikgdGhpcy5yZW1vdmVEb2NIYW5kbGVyKCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICdzaG93LXBvcG92ZXInLCB0aGlzLm9uRG9jdW1lbnRTaG93UG9wb3Zlcik7XG4gICAgICBvZmYoZG9jdW1lbnQsICdoaWRlLXBvcG92ZXInLCB0aGlzLm9uRG9jdW1lbnRIaWRlUG9wb3Zlcik7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b2dnbGUtcG9wb3ZlcicsIHRoaXMub25Eb2N1bWVudFRvZ2dsZVBvcG92ZXIpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndXBkYXRlLXBvcG92ZXInLCB0aGlzLm9uRG9jdW1lbnRVcGRhdGVQb3BvdmVyKTtcbiAgICB9LFxuXG4gICAgb25DbGljayhlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBvbk1vdXNlT3ZlcigpIHtcbiAgICAgIHRoaXMuaXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpdmUpIHRoaXMuc2hvdygpO1xuICAgIH0sXG5cbiAgICBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICB0aGlzLmlzSG92ZXJlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5hdXRvSGlkZSAmJiAhdGhpcy5pc0ZvY3VzZWQgJiYgKCF0aGlzLnJlZiB8fCB0aGlzLnJlZiAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uRm9jdXNJbigpIHtcbiAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpdmUpIHRoaXMuc2hvdygpO1xuICAgIH0sXG5cbiAgICBvbkZvY3VzT3V0KGUpIHtcbiAgICAgIGlmICghZS5yZWxhdGVkVGFyZ2V0IHx8ICFlbGVtZW50Q29udGFpbnModGhpcy5wb3BvdmVyRWwsIGUucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzSG92ZXJlZCAmJiB0aGlzLmF1dG9IaWRlKSB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Eb2N1bWVudENsaWNrKGUpIHtcbiAgICAgIGlmICghdGhpcy4kcmVmcy5wb3BvdmVyIHx8ICF0aGlzLnJlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIERvbid0IGhpZGUgaWYgdGFyZ2V0IGVsZW1lbnQgaXMgY29udGFpbmVkIHdpdGhpbiBwb3BvdmVyIHJlZiBvciBjb250ZW50XG5cblxuICAgICAgaWYgKGVsZW1lbnRDb250YWlucyh0aGlzLnBvcG92ZXJFbCwgZS50YXJnZXQpIHx8IGVsZW1lbnRDb250YWlucyh0aGlzLnJlZiwgZS50YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSGlkZSB0aGUgcG9wb3ZlclxuXG5cbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0sXG5cbiAgICBvbkRvY3VtZW50S2V5ZG93bihlKSB7XG4gICAgICBpZiAoZS5rZXkgPT09ICdFc2MnIHx8IGUua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Eb2N1bWVudFNob3dQb3BvdmVyKHtcbiAgICAgIGRldGFpbFxuICAgIH0pIHtcbiAgICAgIGlmICghZGV0YWlsLmlkIHx8IGRldGFpbC5pZCAhPT0gdGhpcy5pZCkgcmV0dXJuO1xuICAgICAgdGhpcy5zaG93KGRldGFpbCk7XG4gICAgfSxcblxuICAgIG9uRG9jdW1lbnRIaWRlUG9wb3Zlcih7XG4gICAgICBkZXRhaWxcbiAgICB9KSB7XG4gICAgICBpZiAoIWRldGFpbC5pZCB8fCBkZXRhaWwuaWQgIT09IHRoaXMuaWQpIHJldHVybjtcbiAgICAgIHRoaXMuaGlkZShkZXRhaWwpO1xuICAgIH0sXG5cbiAgICBvbkRvY3VtZW50VG9nZ2xlUG9wb3Zlcih7XG4gICAgICBkZXRhaWxcbiAgICB9KSB7XG4gICAgICBpZiAoIWRldGFpbC5pZCB8fCBkZXRhaWwuaWQgIT09IHRoaXMuaWQpIHJldHVybjtcbiAgICAgIHRoaXMudG9nZ2xlKGRldGFpbCk7XG4gICAgfSxcblxuICAgIG9uRG9jdW1lbnRVcGRhdGVQb3BvdmVyKHtcbiAgICAgIGRldGFpbFxuICAgIH0pIHtcbiAgICAgIHRoaXMudXBkYXRlKGRldGFpbCk7XG4gICAgfSxcblxuICAgIHNob3cob3B0cyA9IHt9KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgb3B0cy5hY3Rpb24gPSAnc2hvdyc7XG4gICAgICBjb25zdCByZWYgPSBvcHRzLnJlZiB8fCB0aGlzLnJlZjtcbiAgICAgIGNvbnN0IGRlbGF5ID0gb3B0cy5kZWxheSB8fCB0aGlzLnNob3dEZWxheTsgLy8gVmFsaWRhdGUgb3B0aW9uc1xuXG4gICAgICBpZiAoIXJlZikge1xuICAgICAgICBpZiAob3B0cy5jYWxsYmFjaykge1xuICAgICAgICAgIG9wdHMuY2FsbGJhY2soe1xuICAgICAgICAgICAgY29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlYXNvbjogJ0ludmFsaWQgcmVmZXJlbmNlIGVsZW1lbnQgcHJvdmlkZWQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgdGhpcy5vcHRzID0gb3B0cztcblxuICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oX3RoaXMyLCBvcHRzKTtcblxuICAgICAgICBfdGhpczIuc2V0dXBQb3BwZXIoKTtcblxuICAgICAgICBfdGhpczIub3B0cyA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoaWRlKG9wdHMgPSB7fSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIG9wdHMuYWN0aW9uID0gJ2hpZGUnO1xuICAgICAgY29uc3QgcmVmID0gb3B0cy5yZWYgfHwgdGhpcy5yZWY7XG4gICAgICBjb25zdCBkZWxheSA9IG9wdHMuZGVsYXkgfHwgdGhpcy5oaWRlRGVsYXk7XG5cbiAgICAgIGlmICghdGhpcy5yZWYgfHwgcmVmICE9PSB0aGlzLnJlZikge1xuICAgICAgICBpZiAob3B0cy5jYWxsYmFjaykge1xuICAgICAgICAgIG9wdHMuY2FsbGJhY2soeyAuLi5vcHRzLFxuICAgICAgICAgICAgY29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlYXNvbjogdGhpcy5yZWYgPyAnSW52YWxpZCByZWZlcmVuY2UgZWxlbWVudCBwcm92aWRlZCcgOiAnUG9wb3ZlciBhbHJlYWR5IGhpZGRlbidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5yZWYgPSBudWxsO1xuICAgICAgICBfdGhpczMub3B0cyA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG5cbiAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9nZ2xlKG9wdHMgPSB7fSkge1xuICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICYmIG9wdHMucmVmID09PSB0aGlzLnJlZikge1xuICAgICAgICB0aGlzLmhpZGUob3B0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3cob3B0cyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldHVwUG9wcGVyKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfdGhpczQucmVmIHx8ICFfdGhpczQuJHJlZnMucG9wb3ZlcikgcmV0dXJuO1xuXG4gICAgICAgIGlmIChfdGhpczQucG9wcGVyICYmIF90aGlzNC5wb3BwZXIucmVmZXJlbmNlICE9PSBfdGhpczQucmVmKSB7XG4gICAgICAgICAgX3RoaXM0LmRlc3Ryb3lQb3BwZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3RoaXM0LnBvcHBlcikge1xuICAgICAgICAgIF90aGlzNC5wb3BwZXIgPSBwb3BwZXJfY3JlYXRlUG9wcGVyKF90aGlzNC5yZWYsIF90aGlzNC5wb3BvdmVyRWwsIF90aGlzNC5wb3BwZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczQucG9wcGVyLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25Qb3BwZXJVcGRhdGUoYXJncykge1xuICAgICAgaWYgKGFyZ3MucGxhY2VtZW50KSB7XG4gICAgICAgIHRoaXMucGxhY2VtZW50ID0gYXJncy5wbGFjZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3Muc3RhdGUpIHtcbiAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSBhcmdzLnN0YXRlLnBsYWNlbWVudDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlKHtcbiAgICAgIGRhdGFcbiAgICB9KSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5zZXR1cFBvcHBlcigpO1xuICAgIH0sXG5cbiAgICBiZWZvcmVFbnRlcihlKSB7XG4gICAgICB0aGlzLiRlbWl0KCdiZWZvcmVTaG93JywgZSk7XG4gICAgfSxcblxuICAgIGFmdGVyRW50ZXIoZSkge1xuICAgICAgdGhpcy4kZW1pdCgnYWZ0ZXJTaG93JywgZSk7XG4gICAgfSxcblxuICAgIGJlZm9yZUxlYXZlKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2JlZm9yZUhpZGUnLCBlKTtcbiAgICB9LFxuXG4gICAgYWZ0ZXJMZWF2ZShlKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lQb3BwZXIoKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2FmdGVySGlkZScsIGUpO1xuICAgIH0sXG5cbiAgICBkZXN0cm95UG9wcGVyKCkge1xuICAgICAgaWYgKHRoaXMucG9wcGVyKSB7XG4gICAgICAgIHRoaXMucG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wb3BwZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvUG9wb3Zlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19Qb3BvdmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFBvcG92ZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Qb3BvdmVyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTZjOGEyYTNjJmxhbmc9cG9zdGNzcyZzY29wZWQ9dHJ1ZSZcbnZhciBQb3BvdmVydnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF82YzhhMmEzY19sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRkNzFcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1xuLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlIChleGNlcHQgZm9yIG1vZHVsZXMpLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChyZW5kZXIpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSAnZGF0YS12LScgKyBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IHNoYWRvd01vZGVcbiAgICAgID8gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIChvcHRpb25zLmZ1bmN0aW9uYWwgPyB0aGlzLnBhcmVudCA6IHRoaXMpLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3RcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgdmFyIG9yaWdpbmFsUmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIHZhciBleGlzdGluZyA9IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Qb3BvdmVyLnZ1ZVxudmFyIHJlbmRlciwgc3RhdGljUmVuZGVyRm5zXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1BvcG92ZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCI2YzhhMmEzY1wiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBQb3BvdmVyID0gKGNvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcIjg3NzM5NzllLXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1BvcG92ZXJSb3cudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTQ5NzVkNjllJnNjb3BlZD10cnVlJlxudmFyIFBvcG92ZXJSb3d2dWVfdHlwZV90ZW1wbGF0ZV9pZF80OTc1ZDY5ZV9zY29wZWRfdHJ1ZV9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZjLWRheS1wb3BvdmVyLXJvd1wifSxbKF92bS5pbmRpY2F0b3IpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZjLWRheS1wb3BvdmVyLXJvdy1pbmRpY2F0b3JcIn0sW19jKCdzcGFuJyx7Y2xhc3M6X3ZtLmluZGljYXRvci5jbGFzcyxzdHlsZTooX3ZtLmluZGljYXRvci5zdHlsZSl9KV0pOl92bS5fZSgpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZjLWRheS1wb3BvdmVyLXJvdy1jb250ZW50XCJ9LFtfdm0uX3QoXCJkZWZhdWx0XCIsW192bS5fdihfdm0uX3MoX3ZtLmF0dHJpYnV0ZS5wb3BvdmVyID8gX3ZtLmF0dHJpYnV0ZS5wb3BvdmVyLmxhYmVsIDogJ05vIGNvbnRlbnQgcHJvdmlkZWQnKSldKV0sMildKX1cbnZhciBQb3BvdmVyUm93dnVlX3R5cGVfdGVtcGxhdGVfaWRfNDk3NWQ2OWVfc2NvcGVkX3RydWVfc3RhdGljUmVuZGVyRm5zID0gW11cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1BvcG92ZXJSb3cudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTQ5NzVkNjllJnNjb3BlZD10cnVlJlxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJ2dWVcIixcImNvbW1vbmpzMlwiOlwidnVlXCIsXCJyb290XCI6XCJWdWVcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOGJiZlwiKTtcbnZhciBleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3V0aWxzL2RlZmF1bHRzL3RvdWNoLmpzb25cbnZhciB0b3VjaCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyM2E1XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3V0aWxzL2RlZmF1bHRzL21hc2tzLmpzb25cbnZhciBkZWZhdWx0c19tYXNrcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ZWZlXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3V0aWxzL2RlZmF1bHRzL3NjcmVlbnMuanNvblxudmFyIGRlZmF1bHRzX3NjcmVlbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODVhOVwiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvZGVmYXVsdHMvbG9jYWxlcy5qc1xuXG5cbmNvbnN0IGxvY2FsZXNfbG9jYWxlcyA9IHtcbiAgLy8gQXJhYmljXG4gIGFyOiB7XG4gICAgZG93OiA3LFxuICAgIEw6ICdEL1xcdTIwMEZNL1xcdTIwMEZZWVlZJ1xuICB9LFxuICAvLyBCdWxnYXJpYW5cbiAgYmc6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0QuTU0uWVlZWSdcbiAgfSxcbiAgLy8gQ2F0YWxhblxuICBjYToge1xuICAgIGRvdzogMixcbiAgICBMOiAnREQvTU0vWVlZWSdcbiAgfSxcbiAgLy8gQ2hpbmVzZSAoQ2hpbmEpXG4gICd6aC1DTic6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ1lZWVkvTU0vREQnXG4gIH0sXG4gIC8vIENoaW5lc2UgKFRhaXdhbilcbiAgJ3poLVRXJzoge1xuICAgIGRvdzogMSxcbiAgICBMOiAnWVlZWS9NTS9ERCdcbiAgfSxcbiAgLy8gQ3JvYXRpYW5cbiAgaHI6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELk1NLllZWVknXG4gIH0sXG4gIC8vIEN6ZWNoXG4gIGNzOiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdERC5NTS5ZWVlZJ1xuICB9LFxuICAvLyBEYW5pc2hcbiAgZGE6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELk1NLllZWVknXG4gIH0sXG4gIC8vIER1dGNoXG4gIG5sOiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdERC1NTS1ZWVlZJ1xuICB9LFxuICAvLyBFbmdsaXNoIChVUylcbiAgJ2VuLVVTJzoge1xuICAgIGRvdzogMSxcbiAgICBMOiAnTU0vREQvWVlZWSdcbiAgfSxcbiAgLy8gRW5nbGlzaCAoQXVzdHJhbGlhKVxuICAnZW4tQVUnOiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdERC9NTS9ZWVlZJ1xuICB9LFxuICAvLyBFbmdsaXNoIChDYW5hZGEpXG4gICdlbi1DQSc6IHtcbiAgICBkb3c6IDEsXG4gICAgTDogJ1lZWVktTU0tREQnXG4gIH0sXG4gIC8vIEVuZ2xpc2ggKEdyZWF0IEJyaXRhaW4pXG4gICdlbi1HQic6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0REL01NL1lZWVknXG4gIH0sXG4gIC8vIEVuZ2xpc2ggKElyZWxhbmQpXG4gICdlbi1JRSc6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELU1NLVlZWVknXG4gIH0sXG4gIC8vIEVuZ2xpc2ggKE5ldyBaZWFsYW5kKVxuICAnZW4tTlonOiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdERC9NTS9ZWVlZJ1xuICB9LFxuICAvLyBFbmdsaXNoIChTb3V0aCBBZnJpY2EpXG4gICdlbi1aQSc6IHtcbiAgICBkb3c6IDEsXG4gICAgTDogJ1lZWVkvTU0vREQnXG4gIH0sXG4gIC8vIEVzcGVyYW50b1xuICBlbzoge1xuICAgIGRvdzogMixcbiAgICBMOiAnWVlZWS1NTS1ERCdcbiAgfSxcbiAgLy8gRXN0b25pYW5cbiAgZXQ6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELk1NLllZWVknXG4gIH0sXG4gIC8vIEZpbm5pc2hcbiAgZmk6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELk1NLllZWVknXG4gIH0sXG4gIC8vIEZyZW5jaFxuICBmcjoge1xuICAgIGRvdzogMixcbiAgICBMOiAnREQvTU0vWVlZWSdcbiAgfSxcbiAgLy8gRnJlbmNoIChDYW5hZGEpXG4gICdmci1DQSc6IHtcbiAgICBkb3c6IDEsXG4gICAgTDogJ1lZWVktTU0tREQnXG4gIH0sXG4gIC8vIEZyZW5jaCAoU3dpdHplcmxhbmQpXG4gICdmci1DSCc6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELk1NLllZWVknXG4gIH0sXG4gIC8vIEdlcm1hblxuICBkZToge1xuICAgIGRvdzogMixcbiAgICBMOiAnREQuTU0uWVlZWSdcbiAgfSxcbiAgLy8gSGVicmV3XG4gIGhlOiB7XG4gICAgZG93OiAxLFxuICAgIEw6ICdERC5NTS5ZWVlZJ1xuICB9LFxuICAvLyBJbmRvbmVzaWFuXG4gIGlkOiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdERC9NTS9ZWVlZJ1xuICB9LFxuICAvLyBJdGFsaWFuXG4gIGl0OiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdERC9NTS9ZWVlZJ1xuICB9LFxuICAvLyBKYXBhbmVzZVxuICBqYToge1xuICAgIGRvdzogMSxcbiAgICBMOiAnWVlZWeW5tE3mnIhE5pelJ1xuICB9LFxuICAvLyBLb3JlYW5cbiAga286IHtcbiAgICBkb3c6IDEsXG4gICAgTDogJ1lZWVkuTU0uREQnXG4gIH0sXG4gIC8vIExhdHZpYW5cbiAgbHY6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELk1NLllZWVknXG4gIH0sXG4gIC8vIExpdGh1YW5pYW5cbiAgbHQ6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELk1NLllZWVknXG4gIH0sXG4gIC8vIE1hY2Vkb25pYW5cbiAgbWs6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0QuTU0uWVlZWSdcbiAgfSxcbiAgLy8gTm9yd2VnaWFuXG4gIG5iOiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdELiBNTU1NIFlZWVknXG4gIH0sXG4gIG5uOiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdELiBNTU1NIFlZWVknXG4gIH0sXG4gIC8vIFBvbGlzaFxuICBwbDoge1xuICAgIGRvdzogMixcbiAgICBMOiAnREQuTU0uWVlZWSdcbiAgfSxcbiAgLy8gUG9ydHVndWVzZVxuICBwdDoge1xuICAgIGRvdzogMixcbiAgICBMOiAnREQvTU0vWVlZWSdcbiAgfSxcbiAgLy8gUm9tYW5pYW5cbiAgcm86IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELk1NLllZWVknXG4gIH0sXG4gIC8vIFJ1c3NpYW5cbiAgcnU6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0RELk1NLllZWVknXG4gIH0sXG4gIC8vIFNsb3Zha1xuICBzazoge1xuICAgIGRvdzogMixcbiAgICBMOiAnREQuTU0uWVlZWSdcbiAgfSxcbiAgLy8gU3BhbmlzaCAoU3BhaW4pXG4gICdlcy1FUyc6IHtcbiAgICBkb3c6IDIsXG4gICAgTDogJ0REL01NL1lZWVknXG4gIH0sXG4gIC8vIFNwYW5pc2ggKE1leGljbylcbiAgJ2VzLU1YJzoge1xuICAgIGRvdzogMixcbiAgICBMOiAnREQvTU0vWVlZWSdcbiAgfSxcbiAgLy8gU3dlZGlzaFxuICBzdjoge1xuICAgIGRvdzogMixcbiAgICBMOiAnWVlZWS1NTS1ERCdcbiAgfSxcbiAgLy8gVGhhaVxuICB0aDoge1xuICAgIGRvdzogMSxcbiAgICBMOiAnREQvTU0vWVlZWSdcbiAgfSxcbiAgLy8gVHVya2lzaFxuICB0cjoge1xuICAgIGRvdzogMixcbiAgICBMOiAnREQuTU0uWVlZWSdcbiAgfSxcbiAgLy8gVWtyYWluaWFuXG4gIHVrOiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdERC5NTS5ZWVlZJ1xuICB9LFxuICAvLyBWaWV0bmFtXG4gIHZpOiB7XG4gICAgZG93OiAyLFxuICAgIEw6ICdERC9NTS9ZWVlZJ1xuICB9XG59O1xubG9jYWxlc19sb2NhbGVzLmVuID0gbG9jYWxlc19sb2NhbGVzWydlbi1VUyddO1xubG9jYWxlc19sb2NhbGVzLmVzID0gbG9jYWxlc19sb2NhbGVzWydlcy1FUyddO1xubG9jYWxlc19sb2NhbGVzLm5vID0gbG9jYWxlc19sb2NhbGVzLm5iO1xubG9jYWxlc19sb2NhbGVzLnpoID0gbG9jYWxlc19sb2NhbGVzWyd6aC1DTiddOyAvLyBSZW1hcCBmcm9tIGFiYnIuIHRvIGludHVpdGl2ZSBwcm9wZXJ0eSBuYW1lc1xuXG50b1BhaXJzX2RlZmF1bHQoKShsb2NhbGVzX2xvY2FsZXMpLmZvckVhY2goZnVuY3Rpb24gKFtpZCwge1xuICBkb3csXG4gIExcbn1dKSB7XG4gIGxvY2FsZXNfbG9jYWxlc1tpZF0gPSB7XG4gICAgaWQsXG4gICAgZmlyc3REYXlPZldlZWs6IGRvdyxcbiAgICBtYXNrczoge1xuICAgICAgTFxuICAgIH1cbiAgfTtcbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVmYXVsdHNfbG9jYWxlcyA9IChsb2NhbGVzX2xvY2FsZXMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvZGVmYXVsdHMvaW5kZXguanNcbi8vIFZ1ZSB3b24ndCBnZXQgaW5jbHVkZWQgaW4gYnVuZGxlIGFzIGl0IGlzIGV4dGVybmFsaXplZFxuLy8gaHR0cHM6Ly9jbGkudnVlanMub3JnL2d1aWRlL2J1aWxkLXRhcmdldHMuaHRtbCNsaWJyYXJ5XG5cblxuXG5cblxuXG5jb25zdCBwbHVnaW5EZWZhdWx0cyA9IHtcbiAgY29tcG9uZW50UHJlZml4OiAndicsXG4gIG5hdlZpc2liaWxpdHk6ICdjbGljaycsXG4gIHRpdGxlUG9zaXRpb246ICdjZW50ZXInLFxuICB0cmFuc2l0aW9uOiAnc2xpZGUtaCcsXG4gIHRvdWNoOiB0b3VjaCxcbiAgbWFza3M6IGRlZmF1bHRzX21hc2tzLFxuICBzY3JlZW5zOiBkZWZhdWx0c19zY3JlZW5zLFxuICBsb2NhbGVzOiBkZWZhdWx0c19sb2NhbGVzLFxuICBkYXRlUGlja2VyOiB7XG4gICAgdXBkYXRlT25JbnB1dDogdHJ1ZSxcbiAgICBpbnB1dERlYm91bmNlOiAxMDAwLFxuICAgIHBvcG92ZXI6IHtcbiAgICAgIHZpc2liaWxpdHk6ICdob3Zlci1mb2N1cycsXG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20tc3RhcnQnLFxuICAgICAga2VlcFZpc2libGVPbklucHV0OiBmYWxzZSxcbiAgICAgIGlzSW50ZXJhY3RpdmU6IHRydWVcbiAgICB9XG4gIH1cbn07XG5sZXQgZGVmYXVsdHNfID0gbnVsbDtcbmNvbnN0IHNldHVwRGVmYXVsdHMgPSBmdW5jdGlvbiAob3B0cykge1xuICBpZiAoIWRlZmF1bHRzXykge1xuICAgIGRlZmF1bHRzXyA9IG5ldyBleHRlcm5hbF9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9yb290X1Z1ZV9kZWZhdWx0LmEoe1xuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWZhdWx0czogZGVmYXVsdHNEZWVwX2RlZmF1bHQoKShvcHRzLCBwbHVnaW5EZWZhdWx0cylcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGxvY2FsZXMoKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgIHJldHVybiBtYXBWYWx1ZXNfZGVmYXVsdCgpKHRoaXMuZGVmYXVsdHMubG9jYWxlcywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHYubWFza3MgPSBkZWZhdWx0c0RlZXBfZGVmYXVsdCgpKHYubWFza3MsIF90aGlzLmRlZmF1bHRzLm1hc2tzKTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0c18uZGVmYXVsdHM7XG59O1xuY29uc3QgZGVmYXVsdHNNaXhpbiA9IHtcbiAgYmVmb3JlQ3JlYXRlKCkge1xuICAgIHNldHVwRGVmYXVsdHMoKTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgICRkZWZhdWx0cygpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0c18uZGVmYXVsdHM7XG4gICAgfSxcblxuICAgICRsb2NhbGVzKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRzXy5sb2NhbGVzO1xuICAgIH1cblxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgcHJvcE9yRGVmYXVsdChwcm9wLCBkZWZhdWx0UGF0aCwgc3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhc3NlZFByb3AocHJvcCwgZ2V0X2RlZmF1bHQoKSh0aGlzLiRkZWZhdWx0cywgZGVmYXVsdFBhdGgpLCBzdHJhdGVneSk7XG4gICAgfSxcblxuICAgIHBhc3NlZFByb3AocHJvcCwgZmFsbGJhY2ssIHN0cmF0ZWd5KSB7XG4gICAgICBpZiAoX2hhcyh0aGlzLiRvcHRpb25zLnByb3BzRGF0YSwgcHJvcCkpIHtcbiAgICAgICAgY29uc3QgcHJvcFZhbHVlID0gdGhpc1twcm9wXTtcblxuICAgICAgICBpZiAoaXNPYmplY3QocHJvcFZhbHVlKSAmJiBzdHJhdGVneSA9PT0gJ21lcmdlJykge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0c0RlZXBfZGVmYXVsdCgpKHByb3BWYWx1ZSwgZmFsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cblxuICB9XG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvbWl4aW5zL2NoaWxkLmpzXG5cbmNvbnN0IGNoaWxkTWl4aW4gPSB7XG4gIGluamVjdDogWydzaGFyZWRTdGF0ZSddLFxuICBtaXhpbnM6IFtkZWZhdWx0c01peGluXSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBtYXNrcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXJlZFN0YXRlLm1hc2tzO1xuICAgIH0sXG5cbiAgICB0aGVtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXJlZFN0YXRlLnRoZW1lO1xuICAgIH0sXG5cbiAgICBsb2NhbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFyZWRTdGF0ZS5sb2NhbGU7XG4gICAgfSxcblxuICAgIGRheVBvcG92ZXJJZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXJlZFN0YXRlLmRheVBvcG92ZXJJZDtcbiAgICB9XG5cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGZvcm1hdChkYXRlLCBtYXNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbGUuZm9ybWF0KGRhdGUsIG1hc2spO1xuICAgIH1cblxuICB9XG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvdGhlbWUuanNcblxuXG5jb25zdCB0YXJnZXRQcm9wcyA9IFsnYmFzZScsICdzdGFydCcsICdlbmQnLCAnc3RhcnRFbmQnXTtcbmNvbnN0IGRpc3BsYXlQcm9wcyA9IFsnY2xhc3MnLCAnc3R5bGUnLCAnY29sb3InLCAnZmlsbE1vZGUnXTtcbmNvbnN0IGRlZkNvbmZpZyA9IHtcbiAgY29sb3I6ICdibHVlJyxcbiAgaXNEYXJrOiBmYWxzZSxcbiAgaGlnaGxpZ2h0OiB7XG4gICAgYmFzZToge1xuICAgICAgZmlsbE1vZGU6ICdsaWdodCdcbiAgICB9LFxuICAgIHN0YXJ0OiB7XG4gICAgICBmaWxsTW9kZTogJ3NvbGlkJ1xuICAgIH0sXG4gICAgZW5kOiB7XG4gICAgICBmaWxsTW9kZTogJ3NvbGlkJ1xuICAgIH1cbiAgfSxcbiAgZG90OiB7XG4gICAgYmFzZToge1xuICAgICAgZmlsbE1vZGU6ICdzb2xpZCdcbiAgICB9LFxuICAgIHN0YXJ0OiB7XG4gICAgICBmaWxsTW9kZTogJ3NvbGlkJ1xuICAgIH0sXG4gICAgZW5kOiB7XG4gICAgICBmaWxsTW9kZTogJ3NvbGlkJ1xuICAgIH1cbiAgfSxcbiAgYmFyOiB7XG4gICAgYmFzZToge1xuICAgICAgZmlsbE1vZGU6ICdzb2xpZCdcbiAgICB9LFxuICAgIHN0YXJ0OiB7XG4gICAgICBmaWxsTW9kZTogJ3NvbGlkJ1xuICAgIH0sXG4gICAgZW5kOiB7XG4gICAgICBmaWxsTW9kZTogJ3NvbGlkJ1xuICAgIH1cbiAgfSxcbiAgY29udGVudDoge1xuICAgIGJhc2U6IHt9LFxuICAgIHN0YXJ0OiB7fSxcbiAgICBlbmQ6IHt9XG4gIH1cbn07XG5jbGFzcyB0aGVtZV9UaGVtZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGVmQ29uZmlnLCBjb25maWcpO1xuICB9IC8vIE5vcm1hbGl6ZXMgYXR0cmlidXRlIGNvbmZpZyB0byB0aGUgc3RydWN0dXJlIGRlZmluZWQgYnkgdGhlIHByb3BlcnRpZXNcblxuXG4gIG5vcm1hbGl6ZUF0dHIoe1xuICAgIGNvbmZpZyxcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBsZXQgcm9vdENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICBsZXQgcm9vdCA9IHt9OyAvLyBHZXQgdGhlIG5vcm1hbGl6ZWQgcm9vdCBjb25maWdcblxuICAgIGNvbnN0IG5vcm1BdHRyID0gdGhpc1t0eXBlXTtcblxuICAgIGlmIChjb25maWcgPT09IHRydWUgfHwgaXNTdHJpbmdfZGVmYXVsdCgpKGNvbmZpZykpIHtcbiAgICAgIC8vIEFzc2lnbiBkZWZhdWx0IGNvbG9yIGZvciBib29sZWFucyBvciBzdHJpbmdzXG4gICAgICByb290Q29sb3IgPSBpc1N0cmluZ19kZWZhdWx0KCkoY29uZmlnKSA/IGNvbmZpZyA6IHJvb3RDb2xvcjsgLy8gU2V0IHRoZSBkZWZhdWx0IHJvb3RcblxuICAgICAgcm9vdCA9IHsgLi4ubm9ybUF0dHJcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChjb25maWcpKSB7XG4gICAgICBpZiAoaGFzQW55KGNvbmZpZywgdGFyZ2V0UHJvcHMpKSB7XG4gICAgICAgIC8vIE1peGluIHRhcmdldCBjb25maWdzXG4gICAgICAgIHJvb3QgPSB7IC4uLmNvbmZpZ1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWl4aW4gZGlzcGxheSBjb25maWdzXG4gICAgICAgIHJvb3QgPSB7XG4gICAgICAgICAgYmFzZTogeyAuLi5jb25maWdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXJ0OiB7IC4uLmNvbmZpZ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7IC4uLmNvbmZpZ1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBGaWxsIGluIG1pc3NpbmcgdGFyZ2V0c1xuXG5cbiAgICBkZWZhdWx0c19kZWZhdWx0KCkocm9vdCwge1xuICAgICAgc3RhcnQ6IHJvb3Quc3RhcnRFbmQsXG4gICAgICBlbmQ6IHJvb3Quc3RhcnRFbmRcbiAgICB9LCBub3JtQXR0cik7IC8vIE5vcm1hbGl6ZSBlYWNoIHRhcmdldFxuXG4gICAgdG9QYWlyc19kZWZhdWx0KCkocm9vdCkuZm9yRWFjaChmdW5jdGlvbiAoW3RhcmdldFR5cGUsIHRhcmdldENvbmZpZ10pIHtcbiAgICAgIGxldCB0YXJnZXRDb2xvciA9IHJvb3RDb2xvcjtcblxuICAgICAgaWYgKHRhcmdldENvbmZpZyA9PT0gdHJ1ZSB8fCBpc1N0cmluZ19kZWZhdWx0KCkodGFyZ2V0Q29uZmlnKSkge1xuICAgICAgICB0YXJnZXRDb2xvciA9IGlzU3RyaW5nX2RlZmF1bHQoKSh0YXJnZXRDb25maWcpID8gdGFyZ2V0Q29uZmlnIDogdGFyZ2V0Q29sb3I7XG4gICAgICAgIHJvb3RbdGFyZ2V0VHlwZV0gPSB7XG4gICAgICAgICAgY29sb3I6IHRhcmdldENvbG9yXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRhcmdldENvbmZpZykpIHtcbiAgICAgICAgaWYgKGhhc0FueSh0YXJnZXRDb25maWcsIGRpc3BsYXlQcm9wcykpIHtcbiAgICAgICAgICByb290W3RhcmdldFR5cGVdID0geyAuLi50YXJnZXRDb25maWdcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb3RbdGFyZ2V0VHlwZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBTZXQgdGhlIHRoZW1lIGNvbG9yIGlmIGl0IGlzIG1pc3NpbmdcblxuXG4gICAgICBpZiAoIV9oYXMocm9vdCwgYCR7dGFyZ2V0VHlwZX0uY29sb3JgKSkge1xuICAgICAgICBzZXRfZGVmYXVsdCgpKHJvb3QsIGAke3RhcmdldFR5cGV9LmNvbG9yYCwgdGFyZ2V0Q29sb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgbm9ybWFsaXplSGlnaGxpZ2h0KGNvbmZpZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjb25zdCBoaWdobGlnaHQgPSB0aGlzLm5vcm1hbGl6ZUF0dHIoe1xuICAgICAgY29uZmlnLFxuICAgICAgdHlwZTogJ2hpZ2hsaWdodCdcbiAgICB9KTtcbiAgICB0b1BhaXJzX2RlZmF1bHQoKShoaWdobGlnaHQpLmZvckVhY2goZnVuY3Rpb24gKFtfLCB0YXJnZXRDb25maWddKSB7XG4gICAgICBjb25zdCBjID0gZGVmYXVsdHNfZGVmYXVsdCgpKHRhcmdldENvbmZpZywge1xuICAgICAgICBpc0Rhcms6IF90aGlzLmlzRGFyayxcbiAgICAgICAgY29sb3I6IF90aGlzLmNvbG9yXG4gICAgICB9KTtcbiAgICAgIHRhcmdldENvbmZpZy5zdHlsZSA9IHsgLi4uX3RoaXMuZ2V0SGlnaGxpZ2h0QmdTdHlsZShjKSxcbiAgICAgICAgLi4udGFyZ2V0Q29uZmlnLnN0eWxlXG4gICAgICB9O1xuICAgICAgdGFyZ2V0Q29uZmlnLmNvbnRlbnRTdHlsZSA9IHsgLi4uX3RoaXMuZ2V0SGlnaGxpZ2h0Q29udGVudFN0eWxlKGMpLFxuICAgICAgICAuLi50YXJnZXRDb25maWcuY29udGVudFN0eWxlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBoaWdobGlnaHQ7XG4gIH1cblxuICBnZXRIaWdobGlnaHRCZ1N0eWxlKHtcbiAgICBmaWxsTW9kZSxcbiAgICBjb2xvcixcbiAgICBpc0RhcmtcbiAgfSkge1xuICAgIHN3aXRjaCAoZmlsbE1vZGUpIHtcbiAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEYXJrID8gJ3ZhcigtLWdyYXktOTAwKScgOiAndmFyKC0td2hpdGUpJyxcbiAgICAgICAgICBib3JkZXI6ICcycHggc29saWQnLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBpc0RhcmsgPyBgdmFyKC0tJHtjb2xvcn0tMjAwKWAgOiBgdmFyKC0tJHtjb2xvcn0tNzAwKWAsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAndmFyKC0tcm91bmRlZC1mdWxsKSdcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSAnbGlnaHQnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEYXJrID8gYHZhcigtLSR7Y29sb3J9LTgwMClgIDogYHZhcigtLSR7Y29sb3J9LTIwMClgLFxuICAgICAgICAgIG9wYWNpdHk6IGlzRGFyayA/IDAuNzUgOiAxLFxuICAgICAgICAgIGJvcmRlclJhZGl1czogJ3ZhcigtLXJvdW5kZWQtZnVsbCknXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGlzRGFyayA/IGB2YXIoLS0ke2NvbG9yfS01MDApYCA6IGB2YXIoLS0ke2NvbG9yfS02MDApYCxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6ICd2YXIoLS1yb3VuZGVkLWZ1bGwpJ1xuICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBnZXRIaWdobGlnaHRDb250ZW50U3R5bGUoe1xuICAgIGZpbGxNb2RlLFxuICAgIGNvbG9yLFxuICAgIGlzRGFya1xuICB9KSB7XG4gICAgc3dpdGNoIChmaWxsTW9kZSkge1xuICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm9udFdlaWdodDogJ3ZhcigtLWZvbnQtYm9sZCknLFxuICAgICAgICAgIGNvbG9yOiBpc0RhcmsgPyBgdmFyKC0tJHtjb2xvcn0tMTAwKWAgOiBgdmFyKC0tJHtjb2xvcn0tOTAwKWBcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSAnbGlnaHQnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvbnRXZWlnaHQ6ICd2YXIoLS1mb250LWJvbGQpJyxcbiAgICAgICAgICBjb2xvcjogaXNEYXJrID8gYHZhcigtLSR7Y29sb3J9LTEwMClgIDogYHZhcigtLSR7Y29sb3J9LTkwMClgXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb250V2VpZ2h0OiAndmFyKC0tZm9udC1ib2xkKScsXG4gICAgICAgICAgY29sb3I6ICd2YXIoLS13aGl0ZSknXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICBiZ0FjY2VudEhpZ2goe1xuICAgIGNvbG9yLFxuICAgIGlzRGFya1xuICB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEYXJrID8gYHZhcigtLSR7Y29sb3J9LTUwMClgIDogYHZhcigtLSR7Y29sb3J9LTYwMClgXG4gICAgfTtcbiAgfVxuXG4gIGNvbnRlbnRBY2NlbnQoe1xuICAgIGNvbG9yLFxuICAgIGlzRGFya1xuICB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnRXZWlnaHQ6ICd2YXIoLS1mb250LWJvbGQpJyxcbiAgICAgIGNvbG9yOiBpc0RhcmsgPyBgdmFyKC0tJHtjb2xvcn0tMTAwKWAgOiBgdmFyKC0tJHtjb2xvcn0tOTAwKWBcbiAgICB9O1xuICB9XG5cbiAgbm9ybWFsaXplRG90KGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZU5vbkhpZ2hsaWdodCgnZG90JywgY29uZmlnLCB0aGlzLmJnQWNjZW50SGlnaCk7XG4gIH1cblxuICBub3JtYWxpemVCYXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplTm9uSGlnaGxpZ2h0KCdiYXInLCBjb25maWcsIHRoaXMuYmdBY2NlbnRIaWdoKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZUNvbnRlbnQoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplTm9uSGlnaGxpZ2h0KCdjb250ZW50JywgY29uZmlnLCB0aGlzLmNvbnRlbnRBY2NlbnQpO1xuICB9XG5cbiAgbm9ybWFsaXplTm9uSGlnaGxpZ2h0KHR5cGUsIGNvbmZpZywgc3R5bGVGbikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgY29uc3QgYXR0ciA9IHRoaXMubm9ybWFsaXplQXR0cih7XG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnXG4gICAgfSk7XG4gICAgdG9QYWlyc19kZWZhdWx0KCkoYXR0cikuZm9yRWFjaChmdW5jdGlvbiAoW18sIHRhcmdldENvbmZpZ10pIHtcbiAgICAgIGRlZmF1bHRzX2RlZmF1bHQoKSh0YXJnZXRDb25maWcsIHtcbiAgICAgICAgaXNEYXJrOiBfdGhpczIuaXNEYXJrLFxuICAgICAgICBjb2xvcjogX3RoaXMyLmNvbG9yXG4gICAgICB9KTtcbiAgICAgIHRhcmdldENvbmZpZy5zdHlsZSA9IHsgLi4uc3R5bGVGbih0YXJnZXRDb25maWcpLFxuICAgICAgICAuLi50YXJnZXRDb25maWcuc3R5bGVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGF0dHI7XG4gIH1cblxufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanNcbnZhciBlc19zdHJpbmdfcmVwbGFjZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MzE5XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9sb2NhbGUuanNcblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlLCBuby1tdWx0aS1hc3NpZ24gKi9cblxuXG5cbmNvbnN0IHRva2VuID0gL2R7MSwyfXxXezEsNH18TXsxLDR9fFlZKD86WVkpP3xTezEsM318RG98WHsxLDN9fChbSGhNc0RtXSlcXDE/fFthQV18XCJbXlwiXSpcInwnW14nXSonL2c7XG5jb25zdCB0d29EaWdpdHMgPSAvXFxkXFxkPy87XG5jb25zdCB0aHJlZURpZ2l0cyA9IC9cXGR7M30vO1xuY29uc3QgZm91ckRpZ2l0cyA9IC9cXGR7NH0vO1xuY29uc3Qgd29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkYvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcbmNvbnN0IGxpdGVyYWwgPSAvXFxbKFteXSo/KVxcXS9nbTtcblxuY29uc3Qgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5jb25zdCBtb250aFVwZGF0ZSA9IGZ1bmN0aW9uIChhcnJOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZCwgdiwgbCkge1xuICAgIGNvbnN0IGluZGV4ID0gbFthcnJOYW1lXS5pbmRleE9mKHYuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2LnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpKTtcblxuICAgIGlmICh+aW5kZXgpIHtcbiAgICAgIGQubW9udGggPSBpbmRleDtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBkYXlzSW5XZWVrID0gNztcbmNvbnN0IGRheXNJbk1vbnRocyA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbmNvbnN0IGZvcm1hdEZsYWdzID0ge1xuICBEKGQpIHtcbiAgICByZXR1cm4gZC5kYXk7XG4gIH0sXG5cbiAgREQoZCkge1xuICAgIHJldHVybiBwYWQoZC5kYXkpO1xuICB9LFxuXG4gIERvKGQsIGwpIHtcbiAgICByZXR1cm4gbC5Eb0ZuKGQuZGF5KTtcbiAgfSxcblxuICBkKGQpIHtcbiAgICByZXR1cm4gZC53ZWVrZGF5IC0gMTtcbiAgfSxcblxuICBkZChkKSB7XG4gICAgcmV0dXJuIHBhZChkLndlZWtkYXkgLSAxKTtcbiAgfSxcblxuICBXKGQsIGwpIHtcbiAgICByZXR1cm4gbC5kYXlOYW1lc05hcnJvd1tkLndlZWtkYXkgLSAxXTtcbiAgfSxcblxuICBXVyhkLCBsKSB7XG4gICAgcmV0dXJuIGwuZGF5TmFtZXNTaG9ydGVyW2Qud2Vla2RheSAtIDFdO1xuICB9LFxuXG4gIFdXVyhkLCBsKSB7XG4gICAgcmV0dXJuIGwuZGF5TmFtZXNTaG9ydFtkLndlZWtkYXkgLSAxXTtcbiAgfSxcblxuICBXV1dXKGQsIGwpIHtcbiAgICByZXR1cm4gbC5kYXlOYW1lc1tkLndlZWtkYXkgLSAxXTtcbiAgfSxcblxuICBNKGQpIHtcbiAgICByZXR1cm4gZC5tb250aDtcbiAgfSxcblxuICBNTShkKSB7XG4gICAgcmV0dXJuIHBhZChkLm1vbnRoKTtcbiAgfSxcblxuICBNTU0oZCwgbCkge1xuICAgIHJldHVybiBsLm1vbnRoTmFtZXNTaG9ydFtkLm1vbnRoIC0gMV07XG4gIH0sXG5cbiAgTU1NTShkLCBsKSB7XG4gICAgcmV0dXJuIGwubW9udGhOYW1lc1tkLm1vbnRoIC0gMV07XG4gIH0sXG5cbiAgWVkoZCkge1xuICAgIHJldHVybiBTdHJpbmcoZC55ZWFyKS5zdWJzdHIoMik7XG4gIH0sXG5cbiAgWVlZWShkKSB7XG4gICAgcmV0dXJuIHBhZChkLnllYXIsIDQpO1xuICB9LFxuXG4gIGgoZCkge1xuICAgIHJldHVybiBkLmhvdXJzICUgMTIgfHwgMTI7XG4gIH0sXG5cbiAgaGgoZCkge1xuICAgIHJldHVybiBwYWQoZC5ob3VycyAlIDEyIHx8IDEyKTtcbiAgfSxcblxuICBIKGQpIHtcbiAgICByZXR1cm4gZC5ob3VycztcbiAgfSxcblxuICBISChkKSB7XG4gICAgcmV0dXJuIHBhZChkLmhvdXJzKTtcbiAgfSxcblxuICBtKGQpIHtcbiAgICByZXR1cm4gZC5taW51dGVzO1xuICB9LFxuXG4gIG1tKGQpIHtcbiAgICByZXR1cm4gcGFkKGQubWludXRlcyk7XG4gIH0sXG5cbiAgcyhkKSB7XG4gICAgcmV0dXJuIGQuc2Vjb25kcztcbiAgfSxcblxuICBzcyhkKSB7XG4gICAgcmV0dXJuIHBhZChkLnNlY29uZHMpO1xuICB9LFxuXG4gIFMoZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGQubWlsbGlzZWNvbmRzIC8gMTAwKTtcbiAgfSxcblxuICBTUyhkKSB7XG4gICAgcmV0dXJuIHBhZChNYXRoLnJvdW5kKGQubWlsbGlzZWNvbmRzIC8gMTApLCAyKTtcbiAgfSxcblxuICBTU1MoZCkge1xuICAgIHJldHVybiBwYWQoZC5taWxsaXNlY29uZHMsIDMpO1xuICB9LFxuXG4gIGEoZCwgbCkge1xuICAgIHJldHVybiBkLmhvdXJzIDwgMTIgPyBsLmFtUG1bMF0gOiBsLmFtUG1bMV07XG4gIH0sXG5cbiAgQShkLCBsKSB7XG4gICAgcmV0dXJuIGQuaG91cnMgPCAxMiA/IGwuYW1QbVswXS50b1VwcGVyQ2FzZSgpIDogbC5hbVBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gIH0sXG5cbiAgWChkKSB7XG4gICAgY29uc3QgbyA9IGQudGltZXpvbmVPZmZzZXQ7XG4gICAgcmV0dXJuIGAke28gPiAwID8gJy0nIDogJysnfSR7cGFkKE1hdGguZmxvb3IoTWF0aC5hYnMobykgLyA2MCksIDIpfWA7XG4gIH0sXG5cbiAgWFgoZCkge1xuICAgIGNvbnN0IG8gPSBkLnRpbWV6b25lT2Zmc2V0O1xuICAgIHJldHVybiBgJHtvID4gMCA/ICctJyA6ICcrJ30ke3BhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApICogMTAwICsgTWF0aC5hYnMobykgJSA2MCwgNCl9YDtcbiAgfSxcblxuICBYWFgoZCkge1xuICAgIGNvbnN0IG8gPSBkLnRpbWV6b25lT2Zmc2V0O1xuICAgIHJldHVybiBgJHtvID4gMCA/ICctJyA6ICcrJ30ke3BhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApLCAyKX06JHtwYWQoTWF0aC5hYnMobykgJSA2MCwgMil9YDtcbiAgfVxuXG59O1xuY29uc3QgcGFyc2VGbGFncyA9IHtcbiAgRDogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICBkLmRheSA9IHY7XG4gIH1dLFxuICBEbzogW25ldyBSZWdFeHAodHdvRGlnaXRzLnNvdXJjZSArIHdvcmQuc291cmNlKSwgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICBkLmRheSA9IHBhcnNlSW50KHYsIDEwKTtcbiAgfV0sXG4gIGQ6IFt0d29EaWdpdHMsIG5vb3BdLFxuICBXOiBbd29yZCwgbm9vcF0sXG4gIE06IFt0d29EaWdpdHMsIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgZC5tb250aCA9IHYgLSAxO1xuICB9XSxcbiAgTU1NOiBbd29yZCwgbW9udGhVcGRhdGUoJ21vbnRoTmFtZXNTaG9ydCcpXSxcbiAgTU1NTTogW3dvcmQsIG1vbnRoVXBkYXRlKCdtb250aE5hbWVzJyldLFxuICBZWTogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICBjb25zdCBkYSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgY2VudCA9ICtkYS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyKDAsIDIpO1xuICAgIGQueWVhciA9IGAke3YgPiA2OCA/IGNlbnQgLSAxIDogY2VudH0ke3Z9YDtcbiAgfV0sXG4gIFlZWVk6IFtmb3VyRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgIGQueWVhciA9IHY7XG4gIH1dLFxuICBTOiBbL1xcZC8sIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgZC5taWxsaXNlY29uZCA9IHYgKiAxMDA7XG4gIH1dLFxuICBTUzogWy9cXGR7Mn0vLCBmdW5jdGlvbiAoZCwgdikge1xuICAgIGQubWlsbGlzZWNvbmQgPSB2ICogMTA7XG4gIH1dLFxuICBTU1M6IFt0aHJlZURpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICBkLm1pbGxpc2Vjb25kID0gdjtcbiAgfV0sXG4gIGg6IFt0d29EaWdpdHMsIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgZC5ob3VyID0gdjtcbiAgfV0sXG4gIG06IFt0d29EaWdpdHMsIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgZC5taW51dGUgPSB2O1xuICB9XSxcbiAgczogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICBkLnNlY29uZCA9IHY7XG4gIH1dLFxuICBhOiBbd29yZCwgZnVuY3Rpb24gKGQsIHYsIGwpIHtcbiAgICBjb25zdCB2YWwgPSB2LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAodmFsID09PSBsLmFtUG1bMF0pIHtcbiAgICAgIGQuaXNQbSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsID09PSBsLmFtUG1bMV0pIHtcbiAgICAgIGQuaXNQbSA9IHRydWU7XG4gICAgfVxuICB9XSxcbiAgWDogWy9bXlxcc10qP1srLV1cXGRcXGQ6P1xcZFxcZHxbXlxcc10qP1o/LywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICBpZiAodiA9PT0gJ1onKSB2ID0gJyswMDowMCc7XG4gICAgY29uc3QgcGFydHMgPSBgJHt2fWAubWF0Y2goLyhbKy1dfFxcZFxcZCkvZ2kpO1xuXG4gICAgaWYgKHBhcnRzKSB7XG4gICAgICBjb25zdCBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHBhcnNlSW50KHBhcnRzWzJdLCAxMCk7XG4gICAgICBkLnRpbWV6b25lT2Zmc2V0ID0gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG4gIH1dXG59O1xucGFyc2VGbGFncy5ERCA9IHBhcnNlRmxhZ3MuRDtcbnBhcnNlRmxhZ3MuZGQgPSBwYXJzZUZsYWdzLmQ7XG5wYXJzZUZsYWdzLldXV1cgPSBwYXJzZUZsYWdzLldXVyA9IHBhcnNlRmxhZ3MuV1cgPSBwYXJzZUZsYWdzLlc7XG5wYXJzZUZsYWdzLk1NID0gcGFyc2VGbGFncy5NO1xucGFyc2VGbGFncy5tbSA9IHBhcnNlRmxhZ3MubTtcbnBhcnNlRmxhZ3MuaGggPSBwYXJzZUZsYWdzLkggPSBwYXJzZUZsYWdzLkhIID0gcGFyc2VGbGFncy5oO1xucGFyc2VGbGFncy5zcyA9IHBhcnNlRmxhZ3MucztcbnBhcnNlRmxhZ3MuQSA9IHBhcnNlRmxhZ3MuYTtcbnBhcnNlRmxhZ3MuWFhYID0gcGFyc2VGbGFncy5YWCA9IHBhcnNlRmxhZ3MuWDtcbmZ1bmN0aW9uIHJlc29sdmVDb25maWcoY29uZmlnLCBsb2NhbGVzKSB7XG4gIC8vIEdldCB0aGUgZGV0ZWN0ZWQgbG9jYWxlIHN0cmluZ1xuICBjb25zdCBkZXRMb2NhbGUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZTsgLy8gUmVzb2x2ZSB0aGUgbG9jYWxlIGlkXG5cbiAgbGV0IGlkO1xuXG4gIGlmIChpc1N0cmluZ19kZWZhdWx0KCkoY29uZmlnKSkge1xuICAgIGlkID0gY29uZmlnO1xuICB9IGVsc2UgaWYgKF9oYXMoY29uZmlnLCAnaWQnKSkge1xuICAgIGlkID0gY29uZmlnLmlkO1xuICB9XG5cbiAgaWQgPSAoaWQgfHwgZGV0TG9jYWxlKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBsb2NhbGVLZXlzID0gT2JqZWN0LmtleXMobG9jYWxlcyk7XG5cbiAgY29uc3QgdmFsaWRLZXkgPSBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBsb2NhbGVLZXlzLmZpbmQoZnVuY3Rpb24gKGxrKSB7XG4gICAgICByZXR1cm4gbGsudG9Mb3dlckNhc2UoKSA9PT0gaztcbiAgICB9KTtcbiAgfTtcblxuICBpZCA9IHZhbGlkS2V5KGlkKSB8fCB2YWxpZEtleShpZC5zdWJzdHJpbmcoMCwgMikpIHx8IGRldExvY2FsZTsgLy8gQWRkIGZhbGxiYWNrIGFuZCBzcHJlYWQgZGVmYXVsdCBsb2NhbGUgdG8gcHJldmVudCByZXBldGl0aXZlIHVwZGF0ZSBsb29wc1xuXG4gIGNvbnN0IGRlZkxvY2FsZSA9IHsgLi4ubG9jYWxlc1snZW4tSUUnXSxcbiAgICAuLi5sb2NhbGVzW2lkXSxcbiAgICBpZFxuICB9OyAvLyBBc3NpZ24gb3IgbWVyZ2UgZGVmYXVsdHMgd2l0aCBwcm92aWRlZCBjb25maWdcblxuICBjb25maWcgPSBpc09iamVjdChjb25maWcpID8gZGVmYXVsdHNEZWVwX2RlZmF1bHQoKShjb25maWcsIGRlZkxvY2FsZSkgOiBkZWZMb2NhbGU7IC8vIFJldHVybiByZXNvbHZlZCBjb25maWdcblxuICByZXR1cm4gY29uZmlnO1xufVxuY2xhc3MgbG9jYWxlX0xvY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgbG9jYWxlcyA9IGRlZmF1bHRzX2xvY2FsZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGZpcnN0RGF5T2ZXZWVrLFxuICAgICAgbWFza3NcbiAgICB9ID0gcmVzb2x2ZUNvbmZpZyhjb25maWcsIGxvY2FsZXMpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmZpcnN0RGF5T2ZXZWVrID0gY2xhbXBfZGVmYXVsdCgpKGZpcnN0RGF5T2ZXZWVrLCAxLCBkYXlzSW5XZWVrKTtcbiAgICB0aGlzLm1hc2tzID0gbWFza3M7XG4gICAgdGhpcy5kYXlOYW1lcyA9IHRoaXMuZ2V0RGF5TmFtZXMoJ2xvbmcnKTtcbiAgICB0aGlzLmRheU5hbWVzU2hvcnQgPSB0aGlzLmdldERheU5hbWVzKCdzaG9ydCcpO1xuICAgIHRoaXMuZGF5TmFtZXNTaG9ydGVyID0gdGhpcy5kYXlOYW1lc1Nob3J0Lm1hcChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuc3Vic3RyaW5nKDAsIDIpO1xuICAgIH0pO1xuICAgIHRoaXMuZGF5TmFtZXNOYXJyb3cgPSB0aGlzLmdldERheU5hbWVzKCduYXJyb3cnKTtcbiAgICB0aGlzLm1vbnRoTmFtZXMgPSB0aGlzLmdldE1vbnRoTmFtZXMoJ2xvbmcnKTtcbiAgICB0aGlzLm1vbnRoTmFtZXNTaG9ydCA9IHRoaXMuZ2V0TW9udGhOYW1lcygnc2hvcnQnKTtcbiAgICB0aGlzLmFtUG0gPSBbJ2FtJywgJ3BtJ107XG4gICAgdGhpcy5tb250aERhdGEgPSB7fTsgLy8gQmluZCBtZXRob2RzXG5cbiAgICB0aGlzLmdldE1vbnRoQ29tcHMgPSB0aGlzLmdldE1vbnRoQ29tcHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZm9ybWF0ID0gdGhpcy5mb3JtYXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRvUGFnZSA9IHRoaXMudG9QYWdlLmJpbmQodGhpcyk7XG4gIH1cblxuICBmb3JtYXQoZGF0ZSwgbWFzaywgdGltZXpvbmUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgbWFzayA9IGFycmF5SGFzSXRlbXMobWFzaykgJiYgbWFza1swXSB8fCBpc1N0cmluZ19kZWZhdWx0KCkobWFzaykgJiYgbWFzayB8fCAnWVlZWS1NTS1ERCc7XG4gICAgZGF0ZSA9IHRoaXMuZ2V0RGF0ZVBhcnRzKHRoaXMubm9ybWFsaXplRGF0ZShkYXRlKSwgdGltZXpvbmUpO1xuICAgIG1hc2sgPSB0aGlzLm1hc2tzW21hc2tdIHx8IG1hc2s7XG4gICAgY29uc3QgbGl0ZXJhbHMgPSBbXTsgLy8gTWFrZSBsaXRlcmFscyBpbmFjdGl2ZSBieSByZXBsYWNpbmcgdGhlbSB3aXRoID8/XG5cbiAgICBtYXNrID0gbWFzay5yZXBsYWNlKGxpdGVyYWwsIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgIGxpdGVyYWxzLnB1c2goJDEpO1xuICAgICAgcmV0dXJuICc/Pyc7XG4gICAgfSk7IC8vIEFwcGx5IGZvcm1hdHRpbmcgcnVsZXNcblxuICAgIG1hc2sgPSBtYXNrLnJlcGxhY2UodG9rZW4sIGZ1bmN0aW9uICgkMCkge1xuICAgICAgcmV0dXJuICQwIGluIGZvcm1hdEZsYWdzID8gZm9ybWF0RmxhZ3NbJDBdKGRhdGUsIF90aGlzKSA6ICQwLnNsaWNlKDEsICQwLmxlbmd0aCAtIDEpO1xuICAgIH0pOyAvLyBJbmxpbmUgbGl0ZXJhbCB2YWx1ZXMgYmFjayBpbnRvIHRoZSBmb3JtYXR0ZWQgdmFsdWVcblxuICAgIHJldHVybiBtYXNrLnJlcGxhY2UoL1xcP1xcPy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbGl0ZXJhbHMuc2hpZnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHBhcnNlKGRhdGVTdHIsIG1hc2ssIHRpbWV6b25lKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBjb25zdCBtYXNrcyA9IGFycmF5SGFzSXRlbXMobWFzaykgJiYgbWFzayB8fCBbaXNTdHJpbmdfZGVmYXVsdCgpKG1hc2spICYmIG1hc2sgfHwgJ1lZWVktTU0tREQnXTtcbiAgICByZXR1cm4gbWFza3MubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICBpZiAodHlwZW9mIG0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXNrIGluIGZlY2hhLnBhcnNlJyk7XG4gICAgICB9XG5cbiAgICAgIG0gPSBfdGhpczIubWFza3NbbV0gfHwgbTsgLy8gQXZvaWQgcmVndWxhciBleHByZXNzaW9uIGRlbmlhbCBvZiBzZXJ2aWNlLCBmYWlsIGVhcmx5IGZvciByZWFsbHkgbG9uZyBzdHJpbmdzXG4gICAgICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1JlZ3VsYXJfZXhwcmVzc2lvbl9EZW5pYWxfb2ZfU2VydmljZV8tX1JlRG9TXG5cbiAgICAgIGlmIChkYXRlU3RyLmxlbmd0aCA+IDEwMDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICBjb25zdCBkYXRlSW5mbyA9IHt9O1xuICAgICAgbS5yZXBsYWNlKHRva2VuLCBmdW5jdGlvbiAoJDApIHtcbiAgICAgICAgaWYgKHBhcnNlRmxhZ3NbJDBdKSB7XG4gICAgICAgICAgY29uc3QgaW5mbyA9IHBhcnNlRmxhZ3NbJDBdO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZGF0ZVN0ci5zZWFyY2goaW5mb1swXSk7XG5cbiAgICAgICAgICBpZiAoIX5pbmRleCkge1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlU3RyLnJlcGxhY2UoaW5mb1swXSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICBpbmZvWzFdKGRhdGVJbmZvLCByZXN1bHQsIF90aGlzMik7XG4gICAgICAgICAgICAgIGRhdGVTdHIgPSBkYXRlU3RyLnN1YnN0cihpbmRleCArIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxhZ3NbJDBdID8gJycgOiAkMC5zbGljZSgxLCAkMC5sZW5ndGggLSAxKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIGlmIChkYXRlSW5mby5pc1BtID09PSB0cnVlICYmIGRhdGVJbmZvLmhvdXIgIT0gbnVsbCAmJiArZGF0ZUluZm8uaG91ciAhPT0gMTIpIHtcbiAgICAgICAgZGF0ZUluZm8uaG91ciA9ICtkYXRlSW5mby5ob3VyICsgMTI7XG4gICAgICB9IGVsc2UgaWYgKGRhdGVJbmZvLmlzUG0gPT09IGZhbHNlICYmICtkYXRlSW5mby5ob3VyID09PSAxMikge1xuICAgICAgICBkYXRlSW5mby5ob3VyID0gMDtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGU7XG5cbiAgICAgIGlmIChkYXRlSW5mby50aW1lem9uZU9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIGRhdGVJbmZvLm1pbnV0ZSA9ICsoZGF0ZUluZm8ubWludXRlIHx8IDApIC0gK2RhdGVJbmZvLnRpbWV6b25lT2Zmc2V0O1xuICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoZGF0ZUluZm8ueWVhciB8fCB0b2RheS5nZXRGdWxsWWVhcigpLCBkYXRlSW5mby5tb250aCB8fCAwLCBkYXRlSW5mby5kYXkgfHwgMSwgZGF0ZUluZm8uaG91ciB8fCAwLCBkYXRlSW5mby5taW51dGUgfHwgMCwgZGF0ZUluZm8uc2Vjb25kIHx8IDAsIGRhdGVJbmZvLm1pbGxpc2Vjb25kIHx8IDApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUgPSBfdGhpczIuZ2V0RGF0ZUZyb21QYXJ0cyh7XG4gICAgICAgICAgeWVhcjogZGF0ZUluZm8ueWVhciB8fCB0b2RheS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgIG1vbnRoOiAoZGF0ZUluZm8ubW9udGggfHwgMCkgKyAxLFxuICAgICAgICAgIGRheTogZGF0ZUluZm8uZGF5IHx8IDEsXG4gICAgICAgICAgaG91cnM6IGRhdGVJbmZvLmhvdXIgfHwgMCxcbiAgICAgICAgICBtaW51dGVzOiBkYXRlSW5mby5taW51dGUgfHwgMCxcbiAgICAgICAgICBzZWNvbmRzOiBkYXRlSW5mby5zZWNvbmQgfHwgMCxcbiAgICAgICAgICBtaWxsaXNlY29uZHM6IGRhdGVJbmZvLm1pbGxpc2Vjb25kIHx8IDBcbiAgICAgICAgfSwgdGltZXpvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9KS5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KSB8fCBuZXcgRGF0ZShkYXRlU3RyKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZURhdGUoZCwgY29uZmlnID0ge30pIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBsZXQgdHlwZSA9IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGF1dG8gPSB0eXBlID09PSAnYXV0bycgfHwgIXR5cGU7XG5cbiAgICBpZiAoaXNOdW1iZXJfZGVmYXVsdCgpKGQpKSB7XG4gICAgICB0eXBlID0gJ251bWJlcic7XG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSgrZCk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZ19kZWZhdWx0KCkoZCkpIHtcbiAgICAgIHR5cGUgPSAnc3RyaW5nJztcbiAgICAgIGNvbnN0IG1hc2sgPSBjb25maWcubWFzayB8fCAnaXNvJztcbiAgICAgIHJlc3VsdCA9IGQgPyB0aGlzLnBhcnNlKGQsIG1hc2ssIGNvbmZpZy50aW1lem9uZSkgOiBudWxsO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZCkpIHtcbiAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICAgIHJlc3VsdCA9IHRoaXMuZ2V0RGF0ZUZyb21QYXJ0cyhkLCBjb25maWcudGltZXpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gJ2RhdGUnO1xuICAgICAgcmVzdWx0ID0gX2lzRGF0ZShkKSA/IG5ldyBEYXRlKGQuZ2V0VGltZSgpKSA6IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGF1dG8pIGNvbmZpZy50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gcmVzdWx0ICYmICFpc05hTihyZXN1bHQuZ2V0VGltZSgpKSA/IHJlc3VsdCA6IG51bGw7XG4gIH1cblxuICBkZW5vcm1hbGl6ZURhdGUoZGF0ZSwge1xuICAgIHR5cGUsXG4gICAgbWFzayxcbiAgICB0aW1lem9uZVxuICB9ID0ge30pIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBkYXRlID8gZGF0ZS5nZXRUaW1lKCkgOiBOYU47XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBkYXRlID8gdGhpcy5mb3JtYXQoZGF0ZSwgbWFzayB8fCAnaXNvJywgdGltZXpvbmUpIDogJyc7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBkYXRlID8gbmV3IERhdGUoZGF0ZSkgOiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGFkanVzdFRpbWVGb3JEYXRlKGRhdGUsIHtcbiAgICB0aW1lQWRqdXN0LFxuICAgIHRpbWV6b25lXG4gIH0pIHtcbiAgICBpZiAodGltZUFkanVzdCkge1xuICAgICAgY29uc3QgZGF0ZVBhcnRzID0gdGhpcy5nZXREYXRlUGFydHMoZGF0ZSwgdGltZXpvbmUpO1xuXG4gICAgICBpZiAodGltZUFkanVzdCA9PT0gJ25vdycpIHtcbiAgICAgICAgY29uc3QgdGltZVBhcnRzID0gdGhpcy5nZXREYXRlUGFydHMobmV3IERhdGUoKSwgdGltZXpvbmUpO1xuICAgICAgICBkYXRlUGFydHMuaG91cnMgPSB0aW1lUGFydHMuaG91cnM7XG4gICAgICAgIGRhdGVQYXJ0cy5taW51dGVzID0gdGltZVBhcnRzLm1pbnV0ZXM7XG4gICAgICAgIGRhdGVQYXJ0cy5zZWNvbmRzID0gdGltZVBhcnRzLnNlY29uZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0aW1lUGFydHMgPSB0aW1lQWRqdXN0LnNwbGl0KCc6Jyk7XG4gICAgICAgIGRhdGVQYXJ0cy5ob3VycyA9ICt0aW1lUGFydHNbMF07XG4gICAgICAgIGRhdGVQYXJ0cy5taW51dGVzID0gK3RpbWVQYXJ0c1sxXTtcbiAgICAgICAgZGF0ZVBhcnRzLnNlY29uZHMgPSArdGltZVBhcnRzWzJdO1xuICAgICAgfVxuXG4gICAgICBkYXRlID0gdGhpcy5nZXREYXRlRnJvbVBhcnRzKGRhdGVQYXJ0cywgdGltZXpvbmUpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgZ2V0RGF0ZVBhcnRzKGRhdGUsIHRpbWV6b25lKSB7XG4gICAgaWYgKCFkYXRlKSByZXR1cm4gbnVsbDtcbiAgICBsZXQgdHpEYXRlID0gZGF0ZTtcblxuICAgIGlmICh0aW1lem9uZSkge1xuICAgICAgY29uc3Qgbm9ybURhdGUgPSBuZXcgRGF0ZShkYXRlLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHtcbiAgICAgICAgdGltZVpvbmU6IHRpbWV6b25lXG4gICAgICB9KSk7XG4gICAgICBjb25zdCBkaWZmID0gbm9ybURhdGUuZ2V0VGltZSgpIC0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICB0ekRhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIGRpZmYpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY29uZHMgPSB0ekRhdGUuZ2V0U2Vjb25kcygpO1xuICAgIGNvbnN0IG1pbnV0ZXMgPSB0ekRhdGUuZ2V0TWludXRlcygpO1xuICAgIGNvbnN0IGhvdXJzID0gdHpEYXRlLmdldEhvdXJzKCk7XG4gICAgY29uc3QgbW9udGggPSB0ekRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgY29uc3QgeWVhciA9IHR6RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IGNvbXBzID0gdGhpcy5nZXRNb250aENvbXBzKG1vbnRoLCB5ZWFyKTtcbiAgICBjb25zdCBkYXkgPSB0ekRhdGUuZ2V0RGF0ZSgpO1xuICAgIGNvbnN0IGRheUZyb21FbmQgPSBjb21wcy5kYXlzIC0gZGF5ICsgMTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gdHpEYXRlLmdldERheSgpICsgMTtcbiAgICBjb25zdCB3ZWVrZGF5T3JkaW5hbCA9IE1hdGguZmxvb3IoKGRheSAtIDEpIC8gNyArIDEpO1xuICAgIGNvbnN0IHdlZWtkYXlPcmRpbmFsRnJvbUVuZCA9IE1hdGguZmxvb3IoKGNvbXBzLmRheXMgLSBkYXkpIC8gNyArIDEpO1xuICAgIGNvbnN0IHdlZWsgPSBNYXRoLmNlaWwoKGRheSArIE1hdGguYWJzKGNvbXBzLmZpcnN0V2Vla2RheSAtIGNvbXBzLmZpcnN0RGF5T2ZXZWVrKSkgLyA3KTtcbiAgICBjb25zdCB3ZWVrRnJvbUVuZCA9IGNvbXBzLndlZWtzIC0gd2VlayArIDE7XG4gICAgY29uc3QgcGFydHMgPSB7XG4gICAgICBzZWNvbmRzLFxuICAgICAgbWludXRlcyxcbiAgICAgIGhvdXJzLFxuICAgICAgZGF5LFxuICAgICAgZGF5RnJvbUVuZCxcbiAgICAgIHdlZWtkYXksXG4gICAgICB3ZWVrZGF5T3JkaW5hbCxcbiAgICAgIHdlZWtkYXlPcmRpbmFsRnJvbUVuZCxcbiAgICAgIHdlZWssXG4gICAgICB3ZWVrRnJvbUVuZCxcbiAgICAgIG1vbnRoLFxuICAgICAgeWVhcixcbiAgICAgIGRhdGUsXG4gICAgICBpc1ZhbGlkOiB0cnVlXG4gICAgfTtcbiAgICBwYXJ0cy50aW1lem9uZU9mZnNldCA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQocGFydHMsIHRpbWV6b25lKSAvIDYwMDAwO1xuICAgIHJldHVybiBwYXJ0cztcbiAgfVxuXG4gIGdldERhdGVGcm9tUGFydHMocGFydHMsIHRpbWV6b25lKSB7XG4gICAgaWYgKCFwYXJ0cykgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgeWVhcjogeSxcbiAgICAgIG1vbnRoOiBtLFxuICAgICAgZGF5OiBkLFxuICAgICAgaG91cnM6IGhycyxcbiAgICAgIG1pbnV0ZXM6IG1pbixcbiAgICAgIHNlY29uZHM6IHNlYyxcbiAgICAgIG1pbGxpc2Vjb25kczogbXNcbiAgICB9ID0gcGFydHM7XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCB8fCBtID09PSB1bmRlZmluZWQgfHwgZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB1dGNEYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeSB8fCAwLCBtIC0gMSwgZCB8fCAwLCBocnMgfHwgMCwgbWluIHx8IDAsIHNlYyB8fCAwLCBtcyB8fCAwKSk7XG4gICAgY29uc3QgdHpPZmZzZXRNcyA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQocGFydHMsIHRpbWV6b25lKTtcbiAgICByZXR1cm4gbmV3IERhdGUodXRjRGF0ZS5nZXRUaW1lKCkgKyB0ek9mZnNldE1zKTtcbiAgfVxuXG4gIGdldFRpbWV6b25lT2Zmc2V0KHBhcnRzLCB0aW1lem9uZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHllYXI6IHksXG4gICAgICBtb250aDogbSxcbiAgICAgIGRheTogZCxcbiAgICAgIG1pbnV0ZXM6IG1pbixcbiAgICAgIHNlY29uZHM6IHNlYyxcbiAgICAgIG1pbGxpc2Vjb25kczogbXNcbiAgICB9ID0gcGFydHM7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgaG91cjogJ251bWVyaWMnLFxuICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgIGhvdXJDeWNsZTogJ2gyNCcsXG4gICAgICB0aW1lWm9uZTogdGltZXpvbmUgfHwgdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgY29uc3QgdXRjTm9vbiA9IG5ldyBEYXRlKERhdGUuVVRDKHkgfHwgMCwgbSAtIDEsIGQgfHwgMCwgMTIsIG1pbiB8fCAwLCBzZWMgfHwgMCwgbXMgfHwgMCkpO1xuICAgIGNvbnN0IHR6SG91cnMgPSArZm9ybWF0dGVyLmZvcm1hdCh1dGNOb29uKTtcbiAgICBjb25zdCB0ek9mZnNldCA9IDEyIC0gdHpIb3VycztcbiAgICBjb25zdCBtc0luSG91ciA9IDM2MDAwMDA7XG4gICAgcmV0dXJuIHR6T2Zmc2V0ICogbXNJbkhvdXI7XG4gIH1cblxuICB0b1BhZ2UoYXJnLCBmcm9tUGFnZSkge1xuICAgIGlmIChpc051bWJlcl9kZWZhdWx0KCkoYXJnKSkge1xuICAgICAgcmV0dXJuIGFkZFBhZ2VzKGZyb21QYWdlLCBhcmcpO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZ19kZWZhdWx0KCkoYXJnKSkge1xuICAgICAgcmV0dXJuIHBhZ2VGb3JEYXRlKHRoaXMubm9ybWFsaXplRGF0ZShhcmcpKTtcbiAgICB9XG5cbiAgICBpZiAoX2lzRGF0ZShhcmcpKSB7XG4gICAgICByZXR1cm4gcGFnZUZvckRhdGUoYXJnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QoYXJnKSkge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldE1vbnRoRGF0ZXMoeWVhciA9IDIwMDApIHtcbiAgICBjb25zdCBkYXRlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICBkYXRlcy5wdXNoKG5ldyBEYXRlKHllYXIsIGksIDE1KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGVzO1xuICB9XG5cbiAgZ2V0TW9udGhOYW1lcyhsZW5ndGgpIHtcbiAgICBjb25zdCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmlkLCB7XG4gICAgICBtb250aDogbGVuZ3RoLFxuICAgICAgdGltZXpvbWU6ICdVVEMnXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9udGhEYXRlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGR0Zi5mb3JtYXQoZCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRXZWVrZGF5RGF0ZXMoe1xuICAgIHllYXIgPSAyMDAwLFxuICAgIHV0YyA9IGZhbHNlLFxuICAgIGZpcnN0RGF5T2ZXZWVrID0gdGhpcy5maXJzdERheU9mV2Vla1xuICB9ID0ge30pIHtcbiAgICBjb25zdCBkYXRlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBqIDwgZGF5c0luV2VlazsgaSsrKSB7XG4gICAgICBjb25zdCBkID0gdXRjID8gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgMCwgaSkpIDogbmV3IERhdGUoeWVhciwgMCwgaSk7XG4gICAgICBjb25zdCBkYXkgPSB1dGMgPyBkLmdldFVUQ0RheSgpIDogZC5nZXREYXkoKTtcblxuICAgICAgaWYgKGRheSA9PT0gZmlyc3REYXlPZldlZWsgLSAxIHx8IGogPiAwKSB7XG4gICAgICAgIGRhdGVzLnB1c2goZCk7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZXM7XG4gIH1cblxuICBnZXREYXlOYW1lcyhsZW5ndGgpIHtcbiAgICBjb25zdCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmlkLCB7XG4gICAgICB3ZWVrZGF5OiBsZW5ndGgsXG4gICAgICB0aW1lWm9uZTogJ1VUQydcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5nZXRXZWVrZGF5RGF0ZXMoe1xuICAgICAgZmlyc3REYXlPZldlZWs6IDEsXG4gICAgICB1dGM6IHRydWVcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkdGYuZm9ybWF0KGQpO1xuICAgIH0pO1xuICB9IC8vIERheXMvbW9udGgveWVhciBjb21wb25lbnRzIGZvciBhIGdpdmVuIG1vbnRoIGFuZCB5ZWFyXG5cblxuICBnZXRNb250aENvbXBzKG1vbnRoLCB5ZWFyKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7bW9udGh9LSR7eWVhcn1gO1xuICAgIGxldCBjb21wcyA9IHRoaXMubW9udGhEYXRhW2tleV07XG5cbiAgICBpZiAoIWNvbXBzKSB7XG4gICAgICBjb25zdCBpbkxlYXBZZWFyID0geWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgICAgY29uc3QgZmlyc3RXZWVrZGF5ID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCAxKS5nZXREYXkoKSArIDE7XG4gICAgICBjb25zdCBkYXlzID0gbW9udGggPT09IDIgJiYgaW5MZWFwWWVhciA/IDI5IDogZGF5c0luTW9udGhzW21vbnRoIC0gMV07XG4gICAgICBjb25zdCB3ZWVrcyA9IE1hdGguY2VpbCgoZGF5cyArIE1hdGguYWJzKGZpcnN0V2Vla2RheSAtIHRoaXMuZmlyc3REYXlPZldlZWspKSAvIGRheXNJbldlZWspO1xuICAgICAgY29tcHMgPSB7XG4gICAgICAgIGZpcnN0RGF5T2ZXZWVrOiB0aGlzLmZpcnN0RGF5T2ZXZWVrLFxuICAgICAgICBpbkxlYXBZZWFyLFxuICAgICAgICBmaXJzdFdlZWtkYXksXG4gICAgICAgIGRheXMsXG4gICAgICAgIHdlZWtzLFxuICAgICAgICBtb250aCxcbiAgICAgICAgeWVhclxuICAgICAgfTtcbiAgICAgIHRoaXMubW9udGhEYXRhW2tleV0gPSBjb21wcztcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHM7XG4gIH0gLy8gRGF5cy9tb250aC95ZWFyIGNvbXBvbmVudHMgZm9yIHRvZGF5J3MgbW9udGhcblxuXG4gIGdldFRoaXNNb250aENvbXBzKCkge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIHJldHVybiB0aGlzLmdldE1vbnRoQ29tcHMoZGF0ZS5nZXRNb250aCgpICsgMSwgZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgfSAvLyBEYXkvbW9udGgveWVhciBjb21wb25lbnRzIGZvciBwcmV2aW91cyBtb250aFxuXG5cbiAgZ2V0UHJldk1vbnRoQ29tcHMobW9udGgsIHllYXIpIHtcbiAgICBpZiAobW9udGggPT09IDEpIHJldHVybiB0aGlzLmdldE1vbnRoQ29tcHMoMTIsIHllYXIgLSAxKTtcbiAgICByZXR1cm4gdGhpcy5nZXRNb250aENvbXBzKG1vbnRoIC0gMSwgeWVhcik7XG4gIH0gLy8gRGF5L21vbnRoL3llYXIgY29tcG9uZW50cyBmb3IgbmV4dCBtb250aFxuXG5cbiAgZ2V0TmV4dE1vbnRoQ29tcHMobW9udGgsIHllYXIpIHtcbiAgICBpZiAobW9udGggPT09IDEyKSByZXR1cm4gdGhpcy5nZXRNb250aENvbXBzKDEsIHllYXIgKyAxKTtcbiAgICByZXR1cm4gdGhpcy5nZXRNb250aENvbXBzKG1vbnRoICsgMSwgeWVhcik7XG4gIH1cblxuICBnZXREYXlJZChkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KGRhdGUsICdZWVlZLU1NLUREJyk7XG4gIH0gLy8gQnVpbGRzIGRheSBjb21wb25lbnRzIGZvciBhIGdpdmVuIHBhZ2VcblxuXG4gIGdldENhbGVuZGFyRGF5cyh7XG4gICAgbW9udGhDb21wcyxcbiAgICBwcmV2TW9udGhDb21wcyxcbiAgICBuZXh0TW9udGhDb21wc1xuICB9LCB0aW1lem9uZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgY29uc3QgZGF5cyA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpcnN0RGF5T2ZXZWVrLFxuICAgICAgZmlyc3RXZWVrZGF5XG4gICAgfSA9IG1vbnRoQ29tcHM7XG4gICAgY29uc3QgcHJldk1vbnRoRGF5c1RvU2hvdyA9IGZpcnN0V2Vla2RheSArIChmaXJzdFdlZWtkYXkgPCBmaXJzdERheU9mV2VlayA/IGRheXNJbldlZWsgOiAwKSAtIGZpcnN0RGF5T2ZXZWVrO1xuICAgIGxldCBwcmV2TW9udGggPSB0cnVlO1xuICAgIGxldCB0aGlzTW9udGggPSBmYWxzZTtcbiAgICBsZXQgbmV4dE1vbnRoID0gZmFsc2U7IC8vIEZvcm1hdHRlciBmb3IgYXJpYSBsYWJlbHNcblxuICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMuaWQsIHtcbiAgICAgIHdlZWtkYXk6ICdsb25nJyxcbiAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgIG1vbnRoOiAnbG9uZycsXG4gICAgICBkYXk6ICdudW1lcmljJ1xuICAgIH0pOyAvLyBJbml0IGNvdW50ZXJzIHdpdGggcHJldmlvdXMgbW9udGgncyBkYXRhXG5cbiAgICBsZXQgZGF5ID0gcHJldk1vbnRoQ29tcHMuZGF5cyAtIHByZXZNb250aERheXNUb1Nob3cgKyAxO1xuICAgIGxldCBkYXlGcm9tRW5kID0gcHJldk1vbnRoQ29tcHMuZGF5cyAtIGRheSArIDE7XG4gICAgbGV0IHdlZWtkYXlPcmRpbmFsID0gTWF0aC5mbG9vcigoZGF5IC0gMSkgLyBkYXlzSW5XZWVrICsgMSk7XG4gICAgbGV0IHdlZWtkYXlPcmRpbmFsRnJvbUVuZCA9IDE7XG4gICAgbGV0IHdlZWsgPSBwcmV2TW9udGhDb21wcy53ZWVrcztcbiAgICBsZXQgd2Vla0Zyb21FbmQgPSAxO1xuICAgIGxldCBtb250aCA9IHByZXZNb250aENvbXBzLm1vbnRoO1xuICAgIGxldCB5ZWFyID0gcHJldk1vbnRoQ29tcHMueWVhcjsgLy8gU3RvcmUgdG9kYXlzIGNvbXBzXG5cbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgdG9kYXlEYXkgPSB0b2RheS5nZXREYXRlKCk7XG4gICAgY29uc3QgdG9kYXlNb250aCA9IHRvZGF5LmdldE1vbnRoKCkgKyAxO1xuICAgIGNvbnN0IHRvZGF5WWVhciA9IHRvZGF5LmdldEZ1bGxZZWFyKCk7XG5cbiAgICBjb25zdCBkZnQgPSBmdW5jdGlvbiAoeSwgbSwgZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMubm9ybWFsaXplRGF0ZSh7XG4gICAgICAgICAgeWVhcjogeSxcbiAgICAgICAgICBtb250aDogbSxcbiAgICAgICAgICBkYXk6IGQsXG4gICAgICAgICAgaG91cnMsXG4gICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICBzZWNvbmRzLFxuICAgICAgICAgIG1pbGxpc2Vjb25kc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgdGltZXpvbmVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH07IC8vIEN5Y2xlIHRocm91Z2ggNiB3ZWVrcyAobWF4IGluIG1vbnRoKVxuXG5cbiAgICBmb3IgKGxldCB3ID0gMTsgdyA8PSA2OyB3KyspIHtcbiAgICAgIC8vIEN5Y2xlIHRocm91Z2ggZGF5cyBpbiB3ZWVrXG4gICAgICBmb3IgKGxldCBpID0gMSwgd2Vla2RheSA9IGZpcnN0RGF5T2ZXZWVrOyBpIDw9IGRheXNJbldlZWs7IGkrKywgd2Vla2RheSArPSB3ZWVrZGF5ID09PSBkYXlzSW5XZWVrID8gMSAtIGRheXNJbldlZWsgOiAxKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8ga25vdyB3aGVuIHRvIHN0YXJ0IGNvdW50aW5nIGFjdHVhbCBtb250aCBkYXlzXG4gICAgICAgIGlmIChwcmV2TW9udGggJiYgd2Vla2RheSA9PT0gZmlyc3RXZWVrZGF5KSB7XG4gICAgICAgICAgLy8gUmVzZXQgY291bnRlcnMgZm9yIGN1cnJlbnQgbW9udGhcbiAgICAgICAgICBkYXkgPSAxO1xuICAgICAgICAgIGRheUZyb21FbmQgPSBtb250aENvbXBzLmRheXM7XG4gICAgICAgICAgd2Vla2RheU9yZGluYWwgPSBNYXRoLmZsb29yKChkYXkgLSAxKSAvIGRheXNJbldlZWsgKyAxKTtcbiAgICAgICAgICB3ZWVrZGF5T3JkaW5hbEZyb21FbmQgPSBNYXRoLmZsb29yKChtb250aENvbXBzLmRheXMgLSBkYXkpIC8gZGF5c0luV2VlayArIDEpO1xuICAgICAgICAgIHdlZWsgPSAxO1xuICAgICAgICAgIHdlZWtGcm9tRW5kID0gbW9udGhDb21wcy53ZWVrcztcbiAgICAgICAgICBtb250aCA9IG1vbnRoQ29tcHMubW9udGg7XG4gICAgICAgICAgeWVhciA9IG1vbnRoQ29tcHMueWVhcjsgLy8gLi4uYW5kIGZsYWcgd2UncmUgdHJhY2tpbmcgYWN0dWFsIG1vbnRoIGRheXNcblxuICAgICAgICAgIHByZXZNb250aCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXNNb250aCA9IHRydWU7XG4gICAgICAgIH0gLy8gQXBwZW5kIGRheSBpbmZvIGZvciB0aGUgY3VycmVudCB3ZWVrXG4gICAgICAgIC8vIE5vdGU6IHRoaXMgbWlnaHQgb3IgbWlnaHQgbm90IGJlIGFuIGFjdHVhbCBtb250aCBkYXlcbiAgICAgICAgLy8gIFdlIGRvbid0IGtub3cgaG93IHRoZSBVSSB3YW50cyB0byBkaXNwbGF5IHZhcmlvdXMgZGF5cyxcbiAgICAgICAgLy8gIHNvIHdlJ2xsIHN1cHBseSBhbGwgdGhlIGRhdGEgd2UgY2FuXG5cblxuICAgICAgICBjb25zdCBkYXRlRnJvbVRpbWUgPSBkZnQoeWVhciwgbW9udGgsIGRheSk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBkYXRlRnJvbVRpbWUoMTIsIDAsIDAsIDApO1xuICAgICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgICBzdGFydDogZGF0ZUZyb21UaW1lKDAsIDAsIDApLFxuICAgICAgICAgIGVuZDogZGF0ZUZyb21UaW1lKDIzLCA1OSwgNTksIDk5OSlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLmdldERheUlkKGRhdGUpO1xuICAgICAgICBjb25zdCB3ZWVrZGF5UG9zaXRpb24gPSBpO1xuICAgICAgICBjb25zdCB3ZWVrZGF5UG9zaXRpb25Gcm9tRW5kID0gZGF5c0luV2VlayAtIGk7XG4gICAgICAgIGNvbnN0IGlzVG9kYXkgPSBkYXkgPT09IHRvZGF5RGF5ICYmIG1vbnRoID09PSB0b2RheU1vbnRoICYmIHllYXIgPT09IHRvZGF5WWVhcjtcbiAgICAgICAgY29uc3QgaXNGaXJzdERheSA9IHRoaXNNb250aCAmJiBkYXkgPT09IDE7XG4gICAgICAgIGNvbnN0IGlzTGFzdERheSA9IHRoaXNNb250aCAmJiBkYXkgPT09IG1vbnRoQ29tcHMuZGF5cztcbiAgICAgICAgY29uc3Qgb25Ub3AgPSB3ID09PSAxO1xuICAgICAgICBjb25zdCBvbkJvdHRvbSA9IHcgPT09IDY7XG4gICAgICAgIGNvbnN0IG9uTGVmdCA9IGkgPT09IDE7XG4gICAgICAgIGNvbnN0IG9uUmlnaHQgPSBpID09PSBkYXlzSW5XZWVrO1xuICAgICAgICBkYXlzLnB1c2goe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGxhYmVsOiBkYXkudG9TdHJpbmcoKSxcbiAgICAgICAgICBhcmlhTGFiZWw6IGZvcm1hdHRlci5mb3JtYXQobmV3IERhdGUoeWVhciwgbW9udGgsIGRheSkpLFxuICAgICAgICAgIGRheSxcbiAgICAgICAgICBkYXlGcm9tRW5kLFxuICAgICAgICAgIHdlZWtkYXksXG4gICAgICAgICAgd2Vla2RheVBvc2l0aW9uLFxuICAgICAgICAgIHdlZWtkYXlQb3NpdGlvbkZyb21FbmQsXG4gICAgICAgICAgd2Vla2RheU9yZGluYWwsXG4gICAgICAgICAgd2Vla2RheU9yZGluYWxGcm9tRW5kLFxuICAgICAgICAgIHdlZWssXG4gICAgICAgICAgd2Vla0Zyb21FbmQsXG4gICAgICAgICAgbW9udGgsXG4gICAgICAgICAgeWVhcixcbiAgICAgICAgICBkYXRlRnJvbVRpbWUsXG4gICAgICAgICAgZGF0ZSxcbiAgICAgICAgICByYW5nZSxcbiAgICAgICAgICBpc1RvZGF5LFxuICAgICAgICAgIGlzRmlyc3REYXksXG4gICAgICAgICAgaXNMYXN0RGF5LFxuICAgICAgICAgIGluTW9udGg6IHRoaXNNb250aCxcbiAgICAgICAgICBpblByZXZNb250aDogcHJldk1vbnRoLFxuICAgICAgICAgIGluTmV4dE1vbnRoOiBuZXh0TW9udGgsXG4gICAgICAgICAgb25Ub3AsXG4gICAgICAgICAgb25Cb3R0b20sXG4gICAgICAgICAgb25MZWZ0LFxuICAgICAgICAgIG9uUmlnaHQsXG4gICAgICAgICAgY2xhc3NlczogW2BpZC0ke2lkfWAsIGBkYXktJHtkYXl9YCwgYGRheS1mcm9tLWVuZC0ke2RheUZyb21FbmR9YCwgYHdlZWtkYXktJHt3ZWVrZGF5fWAsIGB3ZWVrZGF5LXBvc2l0aW9uLSR7d2Vla2RheVBvc2l0aW9ufWAsIGB3ZWVrZGF5LW9yZGluYWwtJHt3ZWVrZGF5T3JkaW5hbH1gLCBgd2Vla2RheS1vcmRpbmFsLWZyb20tZW5kLSR7d2Vla2RheU9yZGluYWxGcm9tRW5kfWAsIGB3ZWVrLSR7d2Vla31gLCBgd2Vlay1mcm9tLWVuZC0ke3dlZWtGcm9tRW5kfWAsIHtcbiAgICAgICAgICAgICdpcy10b2RheSc6IGlzVG9kYXksXG4gICAgICAgICAgICAnaXMtZmlyc3QtZGF5JzogaXNGaXJzdERheSxcbiAgICAgICAgICAgICdpcy1sYXN0LWRheSc6IGlzTGFzdERheSxcbiAgICAgICAgICAgICdpbi1tb250aCc6IHRoaXNNb250aCxcbiAgICAgICAgICAgICdpbi1wcmV2LW1vbnRoJzogcHJldk1vbnRoLFxuICAgICAgICAgICAgJ2luLW5leHQtbW9udGgnOiBuZXh0TW9udGgsXG4gICAgICAgICAgICAnb24tdG9wJzogb25Ub3AsXG4gICAgICAgICAgICAnb24tYm90dG9tJzogb25Cb3R0b20sXG4gICAgICAgICAgICAnb24tbGVmdCc6IG9uTGVmdCxcbiAgICAgICAgICAgICdvbi1yaWdodCc6IG9uUmlnaHRcbiAgICAgICAgICB9XVxuICAgICAgICB9KTsgLy8gU2VlIGlmIHdlJ3ZlIGhpdCB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoXG5cbiAgICAgICAgaWYgKHRoaXNNb250aCAmJiBpc0xhc3REYXkpIHtcbiAgICAgICAgICB0aGlzTW9udGggPSBmYWxzZTtcbiAgICAgICAgICBuZXh0TW9udGggPSB0cnVlOyAvLyBSZXNldCBjb3VudGVycyB0byBuZXh0IG1vbnRoJ3MgZGF0YVxuXG4gICAgICAgICAgZGF5ID0gMTtcbiAgICAgICAgICBkYXlGcm9tRW5kID0gbmV4dE1vbnRoQ29tcHMuZGF5cztcbiAgICAgICAgICB3ZWVrZGF5T3JkaW5hbCA9IDE7XG4gICAgICAgICAgd2Vla2RheU9yZGluYWxGcm9tRW5kID0gTWF0aC5mbG9vcigobmV4dE1vbnRoQ29tcHMuZGF5cyAtIGRheSkgLyBkYXlzSW5XZWVrICsgMSk7XG4gICAgICAgICAgd2VlayA9IDE7XG4gICAgICAgICAgd2Vla0Zyb21FbmQgPSBuZXh0TW9udGhDb21wcy53ZWVrcztcbiAgICAgICAgICBtb250aCA9IG5leHRNb250aENvbXBzLm1vbnRoO1xuICAgICAgICAgIHllYXIgPSBuZXh0TW9udGhDb21wcy55ZWFyOyAvLyBTdGlsbCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBtb250aCAoaGFzbid0IGVuZGVkIHlldClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXkrKztcbiAgICAgICAgICBkYXlGcm9tRW5kLS07XG4gICAgICAgICAgd2Vla2RheU9yZGluYWwgPSBNYXRoLmZsb29yKChkYXkgLSAxKSAvIGRheXNJbldlZWsgKyAxKTtcbiAgICAgICAgICB3ZWVrZGF5T3JkaW5hbEZyb21FbmQgPSBNYXRoLmZsb29yKChtb250aENvbXBzLmRheXMgLSBkYXkpIC8gZGF5c0luV2VlayArIDEpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFwcGVuZCB3ZWVrIGRheXNcblxuXG4gICAgICB3ZWVrKys7XG4gICAgICB3ZWVrRnJvbUVuZC0tO1xuICAgIH1cblxuICAgIHJldHVybiBkYXlzO1xuICB9XG5cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL2J1aWxkTWVkaWFRdWVyeS5qc1xuIC8vIFRoaXMgZnVuY3Rpb24gZ3JhdHVpdG91c2x5IGJvcnJvd2VkIGZyb20gVGFpbHdpbmRDU1Ncbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGNzcy90YWlsd2luZGNzcy9ibG9iL21hc3Rlci9zcmMvdXRpbC9idWlsZE1lZGlhUXVlcnkuanNcblxuZnVuY3Rpb24gYnVpbGRNZWRpYVF1ZXJ5KHNjcmVlbnMpIHtcbiAgLy8gRGVmYXVsdCBtaW4gd2lkdGhcbiAgaWYgKGlzU3RyaW5nX2RlZmF1bHQoKShzY3JlZW5zKSkge1xuICAgIHNjcmVlbnMgPSB7XG4gICAgICBtaW46IHNjcmVlbnNcbiAgICB9O1xuICB9IC8vIFdyYXAgaW4gYXJyYXlcblxuXG4gIGlmICghaXNBcnJheUxpa2VPYmplY3RfZGVmYXVsdCgpKHNjcmVlbnMpKSB7XG4gICAgc2NyZWVucyA9IFtzY3JlZW5zXTtcbiAgfVxuXG4gIHJldHVybiBzY3JlZW5zLm1hcChmdW5jdGlvbiAoc2NyZWVuKSB7XG4gICAgaWYgKF9oYXMoc2NyZWVuLCAncmF3JykpIHtcbiAgICAgIHJldHVybiBzY3JlZW4ucmF3O1xuICAgIH1cblxuICAgIHJldHVybiBtYXBfZGVmYXVsdCgpKHNjcmVlbiwgZnVuY3Rpb24gKHZhbHVlLCBmZWF0dXJlKSB7XG4gICAgICBmZWF0dXJlID0gZ2V0X2RlZmF1bHQoKSh7XG4gICAgICAgIG1pbjogJ21pbi13aWR0aCcsXG4gICAgICAgIG1heDogJ21heC13aWR0aCdcbiAgICAgIH0sIGZlYXR1cmUsIGZlYXR1cmUpO1xuICAgICAgcmV0dXJuIGAoJHtmZWF0dXJlfTogJHt2YWx1ZX0pYDtcbiAgICB9KS5qb2luKCcgYW5kICcpO1xuICB9KS5qb2luKCcsICcpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvc2NyZWVucy5qc1xuLy8gVnVlIHdvbid0IGdldCBpbmNsdWRlZCBpbiBidW5kbGUgYXMgaXQgaXMgZXh0ZXJuYWxpemVkXG4vLyBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvYnVpbGQtdGFyZ2V0cy5odG1sI2xpYnJhcnlcblxuXG5cblxubGV0IGlzU2V0dGluZ1VwID0gZmFsc2U7XG5sZXQgc2hvdWxkUmVmcmVzaFF1ZXJpZXMgPSBmYWxzZTtcbmxldCBzY3JlZW5zQ29tcCA9IG51bGw7XG5mdW5jdGlvbiBzZXR1cFNjcmVlbnMoc2NyZWVucyA9IGRlZmF1bHRzX3NjcmVlbnMsIGZvcmNlU2V0dXApIHtcbiAgaWYgKHNjcmVlbnNDb21wICYmICFmb3JjZVNldHVwIHx8IGlzU2V0dGluZ1VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaXNTZXR0aW5nVXAgPSB0cnVlO1xuICBzaG91bGRSZWZyZXNoUXVlcmllcyA9IHRydWU7IC8vIFVzZSBhIHByaXZhdGUgVnVlIGNvbXBvbmVudCB0byBzdG9yZSByZWFjdGl2ZSBzY3JlZW4gbWF0Y2hlc1xuXG4gIHNjcmVlbnNDb21wID0gbmV3IGV4dGVybmFsX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX3Jvb3RfVnVlX2RlZmF1bHQuYSh7XG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IFtdLFxuICAgICAgICBxdWVyaWVzOiBbXVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgcmVmcmVzaFF1ZXJpZXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5xdWVyaWVzID0gbWFwVmFsdWVzX2RlZmF1bHQoKShzY3JlZW5zLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoYnVpbGRNZWRpYVF1ZXJ5KHYpKTtcbiAgICAgICAgICBxdWVyeS5hZGRMaXN0ZW5lcihfdGhpcy5yZWZyZXNoTWF0Y2hlcyk7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZWZyZXNoTWF0Y2hlcygpO1xuICAgICAgfSxcblxuICAgICAgcmVmcmVzaE1hdGNoZXMoKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IHRvUGFpcnNfZGVmYXVsdCgpKHRoaXMucXVlcmllcykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHBbMV0ubWF0Y2hlcztcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHBbMF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfVxuICB9KTtcbiAgaXNTZXR0aW5nVXAgPSBmYWxzZTtcbn0gLy8gR2xvYmFsIG1peGluIHRoYXQgcHJvdmlkZXMgcmVzcG9uc2l2ZSAnJHNjcmVlbnMnIHV0aWxpdHkgbWV0aG9kXG4vLyB0aGF0IHJlZnJlc2hlcyBhbnkgdGltZSB0aGUgc2NyZWVuIG1hdGNoZXMgdXBkYXRlXG5cbmV4dGVybmFsX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX3Jvb3RfVnVlX2RlZmF1bHQuYS5taXhpbih7XG4gIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICBpZiAoIWlzU2V0dGluZ1VwKSB7XG4gICAgICBzZXR1cFNjcmVlbnMoKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICBpZiAoc2hvdWxkUmVmcmVzaFF1ZXJpZXMgJiYgc2NyZWVuc0NvbXApIHtcbiAgICAgIHNjcmVlbnNDb21wLnJlZnJlc2hRdWVyaWVzKCk7XG4gICAgICBzaG91bGRSZWZyZXNoUXVlcmllcyA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgICRzY3JlZW5zKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWcsIGRlZikge1xuICAgICAgICByZXR1cm4gc2NyZWVuc0NvbXAubWF0Y2hlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcbiAgICAgICAgICByZXR1cm4gX2hhcyhjb25maWcsIGN1cnIpID8gY29uZmlnW2N1cnJdIDogcHJldjtcbiAgICAgICAgfSwgaXNVbmRlZmluZWRfZGVmYXVsdCgpKGRlZikgPyBjb25maWcuZGVmYXVsdCA6IGRlZik7XG4gICAgICB9O1xuICAgIH1cblxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL2RhdGVJbmZvLmpzXG5cblxuXG5cbmNvbnN0IG1pbGxpc2Vjb25kc1BlckRheSA9IDI0ICogNjAgKiA2MCAqIDEwMDA7XG5jbGFzcyBkYXRlSW5mb19EYXRlSW5mbyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywge1xuICAgIG9yZGVyID0gMCxcbiAgICBsb2NhbGVcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5pc0RhdGVJbmZvID0gdHJ1ZTtcbiAgICB0aGlzLmlzUmFuZ2UgPSBpc09iamVjdChjb25maWcpO1xuICAgIHRoaXMuaXNEYXRlID0gIXRoaXMuaXNSYW5nZTtcbiAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGUgaW5zdGFuY2VvZiBsb2NhbGVfTG9jYWxlID8gbG9jYWxlIDogbmV3IGxvY2FsZV9Mb2NhbGUobG9jYWxlKTtcbiAgICB0aGlzLmZpcnN0RGF5T2ZXZWVrID0gdGhpcy5sb2NhbGUuZmlyc3REYXlPZldlZWs7IC8vIFByb2Nlc3MgZGF0ZVxuXG4gICAgaWYgKHRoaXMuaXNEYXRlKSB7XG4gICAgICB0aGlzLnR5cGUgPSAnZGF0ZSc7IC8vIEluaXRpYWxpemUgZGF0ZSBmcm9tIGNvbmZpZ1xuXG4gICAgICB0aGlzLmRhdGUgPSB0aGlzLmxvY2FsZS5ub3JtYWxpemVEYXRlKGNvbmZpZyk7XG4gICAgICB0aGlzLmRhdGVUaW1lID0gdGhpcy5kYXRlICYmIHRoaXMuZGF0ZS5nZXRUaW1lKCk7XG4gICAgfSAvLyBQcm9jZXNzIGRhdGUgcmFuZ2VcblxuXG4gICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgdGhpcy50eXBlID0gJ3JhbmdlJzsgLy8gSW5pdGlhbGl6ZSBzdGFydCBhbmQgZW5kIGRhdGVzIGZyb20gY29uZmlnIChudWxsIG1lYW5zIGluZmluaXR5KVxuXG4gICAgICBsZXQgc3RhcnQgPSB0aGlzLmxvY2FsZS5ub3JtYWxpemVEYXRlKGNvbmZpZy5zdGFydCk7XG4gICAgICBsZXQgZW5kID0gdGhpcy5sb2NhbGUubm9ybWFsaXplRGF0ZShjb25maWcuZW5kKTsgLy8gUmVjb25maWd1cmUgc3RhcnQgYW5kIGVuZCBkYXRlcyBpZiBuZWVkZWRcblxuICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgICAgICBjb25zdCB0ZW1wID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICBlbmQgPSB0ZW1wO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAmJiBjb25maWcuc3BhbiA+PSAxKSB7XG4gICAgICAgIGVuZCA9IGFkZERheXMoc3RhcnQsIGNvbmZpZy5zcGFuIC0gMSk7XG4gICAgICB9IC8vIFJlc2V0IGludmFsaWQgZGF0ZXMgdG8gbnVsbCBhbmQgc3RyaXAgdGltZXMgZm9yIHZhbGlkIGRhdGVzXG5cblxuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIGlmICghX2lzRGF0ZShzdGFydCkpIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBpZiAoIV9pc0RhdGUoZW5kKSkgZW5kID0gbnVsbDtcbiAgICAgIH0gLy8gQXNzaWduIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcblxuXG4gICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0ID8gc3RhcnQuZ2V0VGltZSgpIDogTmFOO1xuICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICB0aGlzLmVuZFRpbWUgPSBlbmQgPyBlbmQuZ2V0VGltZSgpIDogTmFOOyAvLyBBc3NpZ24gc3BhbnNcblxuICAgICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgICB0aGlzLmRheVNwYW4gPSB0aGlzLmRpZmZJbkRheXMoc3RhcnQsIGVuZCk7XG4gICAgICAgIHRoaXMud2Vla1NwYW4gPSB0aGlzLmRpZmZJbldlZWtzKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLm1vbnRoU3BhbiA9IHRoaXMuZGlmZkluTW9udGhzKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnllYXJTcGFuID0gdGhpcy5kaWZmSW5ZZWFycyhzdGFydCwgZW5kKTtcbiAgICAgIH0gLy8gQXNzaWduICdhbmQnIGNvbmRpdGlvblxuXG5cbiAgICAgIGNvbnN0IGFuZE9wdCA9IG1peGluT3B0aW9uYWxQcm9wcyhjb25maWcsIHt9LCBkYXRlSW5mb19EYXRlSW5mby5wYXR0ZXJuUHJvcHMpO1xuXG4gICAgICBpZiAoYW5kT3B0LmFzc2lnbmVkKSB7XG4gICAgICAgIHRoaXMub24gPSB7XG4gICAgICAgICAgYW5kOiBhbmRPcHQudGFyZ2V0XG4gICAgICAgIH07XG4gICAgICB9IC8vIEFzc2lnbiAnb3InIGNvbmRpdGlvbnNcblxuXG4gICAgICBpZiAoY29uZmlnLm9uKSB7XG4gICAgICAgIGNvbnN0IG9yID0gKGlzQXJyYXlMaWtlT2JqZWN0X2RlZmF1bHQoKShjb25maWcub24pID8gY29uZmlnLm9uIDogW2NvbmZpZy5vbl0pLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uX2RlZmF1bHQoKShvKSkgcmV0dXJuIG87XG4gICAgICAgICAgY29uc3Qgb3B0ID0gbWl4aW5PcHRpb25hbFByb3BzKG8sIHt9LCBkYXRlSW5mb19EYXRlSW5mby5wYXR0ZXJuUHJvcHMpO1xuICAgICAgICAgIHJldHVybiBvcHQuYXNzaWduZWQgPyBvcHQudGFyZ2V0IDogbnVsbDtcbiAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3IubGVuZ3RoKSB0aGlzLm9uID0geyAuLi50aGlzLm9uLFxuICAgICAgICAgIG9yXG4gICAgICAgIH07XG4gICAgICB9IC8vIEFzc2lnbiBmbGFnIGlmIGRhdGUgaXMgY29tcGxleFxuXG5cbiAgICAgIHRoaXMuaXNDb21wbGV4ID0gISF0aGlzLm9uO1xuICAgIH1cbiAgfVxuXG4gIGdldCBvcHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcmRlcjogdGhpcy5vcmRlcixcbiAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICB9O1xuICB9XG5cbiAgdG9EYXRlSW5mbyhkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuaXNEYXRlSW5mbyA/IGRhdGUgOiBuZXcgZGF0ZUluZm9fRGF0ZUluZm8oZGF0ZSwgdGhpcy5vcHRzKTtcbiAgfVxuXG4gIHN0YXJ0T2ZXZWVrKGRhdGUpIHtcbiAgICBjb25zdCBkYXkgPSBkYXRlLmdldERheSgpICsgMTtcbiAgICBjb25zdCBkYXlzVG9BZGQgPSBkYXkgPj0gdGhpcy5maXJzdERheU9mV2VlayA/IHRoaXMuZmlyc3REYXlPZldlZWsgLSBkYXkgOiAtKDcgLSAodGhpcy5maXJzdERheU9mV2VlayAtIGRheSkpO1xuICAgIHJldHVybiBhZGREYXlzKGRhdGUsIGRheXNUb0FkZCk7XG4gIH1cblxuICBkaWZmSW5EYXlzKGQxLCBkMikge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKChkMiAtIGQxKSAvIG1pbGxpc2Vjb25kc1BlckRheSk7XG4gIH1cblxuICBkaWZmSW5XZWVrcyhkMSwgZDIpIHtcbiAgICByZXR1cm4gdGhpcy5kaWZmSW5EYXlzKHRoaXMuc3RhcnRPZldlZWsoZDEpLCB0aGlzLnN0YXJ0T2ZXZWVrKGQyKSk7XG4gIH1cblxuICBkaWZmSW5ZZWFycyhkMSwgZDIpIHtcbiAgICByZXR1cm4gZDIuZ2V0VVRDRnVsbFllYXIoKSAtIGQxLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIH1cblxuICBkaWZmSW5Nb250aHMoZDEsIGQyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlmZkluWWVhcnMoZDEsIGQyKSAqIDEyICsgKGQyLmdldE1vbnRoKCkgLSBkMS5nZXRNb250aCgpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcGF0dGVybnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhaWx5SW50ZXJ2YWw6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGRheSwgaW50ZXJ2YWwsIGRpKSB7XG4gICAgICAgICAgcmV0dXJuIGRpLmRpZmZJbkRheXMoZGkuc3RhcnQgfHwgbmV3IERhdGUoKSwgZGF5LmRhdGUpICUgaW50ZXJ2YWwgPT09IDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3ZWVrbHlJbnRlcnZhbDoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoZGF5LCBpbnRlcnZhbCwgZGkpIHtcbiAgICAgICAgICByZXR1cm4gZGkuZGlmZkluV2Vla3MoZGkuc3RhcnQgfHwgbmV3IERhdGUoKSwgZGF5LmRhdGUpICUgaW50ZXJ2YWwgPT09IDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtb250aGx5SW50ZXJ2YWw6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGRheSwgaW50ZXJ2YWwsIGRpKSB7XG4gICAgICAgICAgcmV0dXJuIGRpLmRpZmZJbk1vbnRocyhkaS5zdGFydCB8fCBuZXcgRGF0ZSgpLCBkYXkuZGF0ZSkgJSBpbnRlcnZhbCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHllYXJseUludGVydmFsOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRheSwgaW50ZXJ2YWwsIGRpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGkuZGlmZkluWWVhcnMoZGkuc3RhcnQgfHwgbmV3IERhdGUoKSwgZGF5LmRhdGUpICUgaW50ZXJ2YWwgPT09IDA7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRheXM6IHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChkYXlzKSB7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0X2RlZmF1bHQoKShkYXlzKSA/IGRheXMgOiBbcGFyc2VJbnQoZGF5cywgMTApXTtcbiAgICAgICAgfSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGRheSwgZGF5cykge1xuICAgICAgICAgIHJldHVybiBkYXlzLmluY2x1ZGVzKGRheS5kYXkpIHx8IGRheXMuaW5jbHVkZXMoLWRheS5kYXlGcm9tRW5kKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAod2Vla2RheXMpIHtcbiAgICAgICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3RfZGVmYXVsdCgpKHdlZWtkYXlzKSA/IHdlZWtkYXlzIDogW3BhcnNlSW50KHdlZWtkYXlzLCAxMCldO1xuICAgICAgICB9LFxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoZGF5LCB3ZWVrZGF5cykge1xuICAgICAgICAgIHJldHVybiB3ZWVrZGF5cy5pbmNsdWRlcyhkYXkud2Vla2RheSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcmRpbmFsV2Vla2RheXM6IHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChvcmRpbmFsV2Vla2RheXMpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob3JkaW5hbFdlZWtkYXlzKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHdlZWtkYXlzID0gb3JkaW5hbFdlZWtkYXlzW2NrXTtcbiAgICAgICAgICAgIGlmICghd2Vla2RheXMpIHJldHVybiBvYmo7XG4gICAgICAgICAgICBvYmpbY2tdID0gaXNBcnJheUxpa2VPYmplY3RfZGVmYXVsdCgpKHdlZWtkYXlzKSA/IHdlZWtkYXlzIDogW3BhcnNlSW50KHdlZWtkYXlzLCAxMCldO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChkYXksIG9yZGluYWxXZWVrZGF5cykge1xuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvcmRpbmFsV2Vla2RheXMpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGssIDEwKTtcbiAgICAgICAgICB9KS5maW5kKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JkaW5hbFdlZWtkYXlzW2tdLmluY2x1ZGVzKGRheS53ZWVrZGF5KSAmJiAoayA9PT0gZGF5LndlZWtkYXlPcmRpbmFsIHx8IGsgPT09IC1kYXkud2Vla2RheU9yZGluYWxGcm9tRW5kKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdlZWtlbmRzOiB7XG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgIHJldHVybiBkYXkud2Vla2RheSA9PT0gMSB8fCBkYXkud2Vla2RheSA9PT0gNztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdvcmt3ZWVrOiB7XG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgIHJldHVybiBkYXkud2Vla2RheSA+PSAyICYmIGRheS53ZWVrZGF5IDw9IDY7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3ZWVrczoge1xuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHdlZWtzKSB7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0X2RlZmF1bHQoKSh3ZWVrcykgPyB3ZWVrcyA6IFtwYXJzZUludCh3ZWVrcywgMTApXTtcbiAgICAgICAgfSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGRheSwgd2Vla3MpIHtcbiAgICAgICAgICByZXR1cm4gd2Vla3MuaW5jbHVkZXMoZGF5LndlZWspIHx8IHdlZWtzLmluY2x1ZGVzKC1kYXkud2Vla0Zyb21FbmQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW9udGhzOiB7XG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAobW9udGhzKSB7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0X2RlZmF1bHQoKShtb250aHMpID8gbW9udGhzIDogW3BhcnNlSW50KG1vbnRocywgMTApXTtcbiAgICAgICAgfSxcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKGRheSwgbW9udGhzKSB7XG4gICAgICAgICAgcmV0dXJuIG1vbnRocy5pbmNsdWRlcyhkYXkubW9udGgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeWVhcnM6IHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh5ZWFycykge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdF9kZWZhdWx0KCkoeWVhcnMpID8geWVhcnMgOiBbcGFyc2VJbnQoeWVhcnMsIDEwKV07XG4gICAgICAgIH0sXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChkYXksIHllYXJzKSB7XG4gICAgICAgICAgcmV0dXJuIHllYXJzLmluY2x1ZGVzKGRheS55ZWFyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0IHBhdHRlcm5Qcm9wcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0ZUluZm9fRGF0ZUluZm8ucGF0dGVybnMpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogayxcbiAgICAgICAgdmFsaWRhdGU6IGRhdGVJbmZvX0RhdGVJbmZvLnBhdHRlcm5zW2tdLnZhbGlkYXRlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIHRlc3RDb25maWcoY29uZmlnLCBkYXksIGRhdGVJbmZvKSB7XG4gICAgaWYgKGlzRnVuY3Rpb25fZGVmYXVsdCgpKGNvbmZpZykpIHJldHVybiBjb25maWcoZGF5KTtcblxuICAgIGlmIChpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uZmlnKS5ldmVyeShmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gZGF0ZUluZm9fRGF0ZUluZm8ucGF0dGVybnNba10udGVzdChkYXksIGNvbmZpZ1trXSwgZGF0ZUluZm8pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpdGVyYXRlRGF0ZXNJblJhbmdlKHtcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgfSwgZm4pIHtcbiAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIWlzRnVuY3Rpb25fZGVmYXVsdCgpKGZuKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICBpOiAwLFxuICAgICAgZGF0ZTogc3RhcnQsXG4gICAgICBkYXk6IHRoaXMubG9jYWxlLmdldERhdGVQYXJ0cyhzdGFydCksXG4gICAgICBmaW5pc2hlZDogZmFsc2VcbiAgICB9O1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICg7ICFzdGF0ZS5maW5pc2hlZCAmJiBzdGF0ZS5kYXRlIDw9IGVuZDsgc3RhdGUuaSsrKSB7XG4gICAgICByZXN1bHQgPSBmbihzdGF0ZSk7XG4gICAgICBzdGF0ZS5kYXRlID0gYWRkRGF5cyhzdGF0ZS5kYXRlLCAxKTtcbiAgICAgIHN0YXRlLmRheSA9IHRoaXMubG9jYWxlLmdldERhdGVQYXJ0cyhzdGF0ZS5kYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc2hhbGxvd0ludGVyc2VjdGluZ1JhbmdlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VTaGFsbG93SW50ZXJzZWN0aW5nUmFuZ2UodGhpcywgb3RoZXIpO1xuICB9IC8vIFJldHVybnMgYSBkYXRlIHJhbmdlIHRoYXQgaW50ZXJzZWN0cyB0d28gRGF0ZUluZm8gb2JqZWN0c1xuICAvLyBOT1RFOiBUaGlzIGlzIGEgc2hhbGxvdyBjYWxjdWxhdGlvbiAoZG9lcyBub3QgdGFrZSBwYXR0ZXJucyBpbnRvIGFjY291bnQpLFxuICAvLyAgIHNvIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IHJlYWxseSBiZSBjYWxsZWQgZm9yIHNwZWNpYWwgY29uZGl0aW9uc1xuICAvLyAgIHdoZXJlIGFic29sdXRlIGFjY3VyYWN5IGlzIG5vdCBuZWNlc3NhcmlseSBuZWVkZWRcblxuXG4gIHJhbmdlU2hhbGxvd0ludGVyc2VjdGluZ1JhbmdlKGRhdGUxLCBkYXRlMikge1xuICAgIGRhdGUxID0gdGhpcy50b0RhdGVJbmZvKGRhdGUxKTtcbiAgICBkYXRlMiA9IHRoaXMudG9EYXRlSW5mbyhkYXRlMik7XG5cbiAgICBpZiAoIXRoaXMuZGF0ZVNoYWxsb3dJbnRlcnNlY3RzRGF0ZShkYXRlMSwgZGF0ZTIpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB0aGlzUmFuZ2UgPSBkYXRlMS50b1JhbmdlKCk7XG4gICAgY29uc3Qgb3RoZXJSYW5nZSA9IGRhdGUyLnRvUmFuZ2UoKTsgLy8gU3RhcnQgd2l0aCBpbmZpbml0ZSBzdGFydCBhbmQgZW5kIGRhdGVzXG5cbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIGxldCBlbmQgPSBudWxsOyAvLyBUaGlzIHN0YXJ0IGRhdGUgZXhpc3RzXG5cbiAgICBpZiAodGhpc1JhbmdlLnN0YXJ0KSB7XG4gICAgICAvLyBVc2UgdGhpcyBkZWZpbml0ZSBzdGFydCBkYXRlIGlmIG90aGVyIHN0YXJ0IGRhdGUgaXMgaW5maW5pdGVcbiAgICAgIGlmICghb3RoZXJSYW5nZS5zdGFydCkge1xuICAgICAgICBzdGFydCA9IHRoaXNSYW5nZS5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHRoZSBsYXRlc3Qgc3RhcnQgZGF0ZVxuICAgICAgICBzdGFydCA9IHRoaXNSYW5nZS5zdGFydCA+IG90aGVyUmFuZ2Uuc3RhcnQgPyB0aGlzUmFuZ2Uuc3RhcnQgOiBvdGhlclJhbmdlLnN0YXJ0O1xuICAgICAgfSAvLyBPdGhlciBzdGFydCBkYXRlIGV4aXN0c1xuXG4gICAgfSBlbHNlIGlmIChvdGhlclJhbmdlLnN0YXJ0KSB7XG4gICAgICAvLyBVc2Ugb3RoZXIgZGVmaW5pdGUgc3RhcnQgZGF0ZSBhcyB0aGlzIG9uZSBpcyBpbmZpbml0ZVxuICAgICAgc3RhcnQgPSBvdGhlclJhbmdlLnN0YXJ0O1xuICAgIH0gLy8gVGhpcyBlbmQgZGF0ZSBleGlzdHNcblxuXG4gICAgaWYgKHRoaXNSYW5nZS5lbmQpIHtcbiAgICAgIC8vIFVzZSB0aGlzIGRlZmluaXRlIGVuZCBkYXRlIGlmIG90aGVyIGVuZCBkYXRlIGlzIGluZmluaXRlXG4gICAgICBpZiAoIW90aGVyUmFuZ2UuZW5kKSB7XG4gICAgICAgIGVuZCA9IHRoaXNSYW5nZS5lbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB0aGUgZWFybGllc3QgZW5kIGRhdGVcbiAgICAgICAgZW5kID0gdGhpc1JhbmdlLmVuZCA8IG90aGVyUmFuZ2UuZW5kID8gdGhpc1JhbmdlLmVuZCA6IG90aGVyUmFuZ2UuZW5kO1xuICAgICAgfSAvLyBPdGhlciBlbmQgZGF0ZSBleGlzdHNcblxuICAgIH0gZWxzZSBpZiAob3RoZXJSYW5nZS5lbmQpIHtcbiAgICAgIC8vIFVzZSBvdGhlciBkZWZpbml0ZSBlbmQgZGF0ZSBhcyB0aGlzIG9uZSBpcyBpbmZpbml0ZVxuICAgICAgZW5kID0gb3RoZXJSYW5nZS5lbmQ7XG4gICAgfSAvLyBSZXR1cm4gY2FsY3VsYXRlZCByYW5nZVxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmRcbiAgICB9O1xuICB9IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERldGVybWluZXMgaWYgdGhpcyBkYXRlIHBhcnRpYWxseSBpbnRlcnNlY3RzIGFub3RoZXIgZGF0ZVxuICAvLyBOT1RFOiBUaGlzIGlzIGEgZGVlcCB0ZXN0IChwYXR0ZXJucyB0ZXN0ZWQpXG5cblxuICBpbnRlcnNlY3RzRGF0ZShvdGhlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjb25zdCBkYXRlID0gdGhpcy50b0RhdGVJbmZvKG90aGVyKTtcbiAgICBpZiAoIXRoaXMuc2hhbGxvd0ludGVyc2VjdHNEYXRlKGRhdGUpKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoIXRoaXMub24pIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5yYW5nZVNoYWxsb3dJbnRlcnNlY3RpbmdSYW5nZSh0aGlzLCBkYXRlKTtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgdGhpcy5pdGVyYXRlRGF0ZXNJblJhbmdlKHJhbmdlLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmIChfdGhpcy5tYXRjaGVzRGF5KHN0YXRlLmRheSkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IGRhdGUubWF0Y2hlc0RheShzdGF0ZS5kYXkpO1xuICAgICAgICBzdGF0ZS5maW5pc2hlZCA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERldGVybWluZXMgaWYgdGhpcyBkYXRlIHBhcnRpYWxseSBpbnRlcnNlY3RzIGFub3RoZXIgZGF0ZVxuICAvLyBOT1RFOiBUaGlzIGlzIGEgc2hhbGxvdyB0ZXN0IChubyBwYXR0ZXJucyB0ZXN0ZWQpXG5cblxuICBzaGFsbG93SW50ZXJzZWN0c0RhdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlU2hhbGxvd0ludGVyc2VjdHNEYXRlKHRoaXMsIHRoaXMudG9EYXRlSW5mbyhvdGhlcikpO1xuICB9IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERldGVybWluZXMgaWYgZmlyc3QgZGF0ZSBwYXJ0aWFsbHkgaW50ZXJzZWN0cyBzZWNvbmQgZGF0ZVxuICAvLyBOT1RFOiBUaGlzIGlzIGEgc2hhbGxvdyB0ZXN0IChubyBwYXR0ZXJucyB0ZXN0ZWQpXG5cblxuICBkYXRlU2hhbGxvd0ludGVyc2VjdHNEYXRlKGRhdGUxLCBkYXRlMikge1xuICAgIGlmIChkYXRlMS5pc0RhdGUpIHtcbiAgICAgIHJldHVybiBkYXRlMi5pc0RhdGUgPyBkYXRlMS5kYXRlVGltZSA9PT0gZGF0ZTIuZGF0ZVRpbWUgOiB0aGlzLmRhdGVTaGFsbG93SW5jbHVkZXNEYXRlKGRhdGUyLCBkYXRlMSk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGUyLmlzRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNoYWxsb3dJbmNsdWRlc0RhdGUoZGF0ZTEsIGRhdGUyKTtcbiAgICB9IC8vIEJvdGggcmFuZ2VzXG5cblxuICAgIGlmIChkYXRlMS5zdGFydCAmJiBkYXRlMi5lbmQgJiYgZGF0ZTEuc3RhcnQgPiBkYXRlMi5lbmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZTEuZW5kICYmIGRhdGUyLnN0YXJ0ICYmIGRhdGUxLmVuZCA8IGRhdGUyLnN0YXJ0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRGV0ZXJtaW5lcyBpZiB0aGlzIGRhdGUgY29tcGxldGVseSBpbmNsdWRlcyBhbm90aGVyIGRhdGVcbiAgLy8gTk9URTogVGhpcyBpcyBhIGRlZXAgdGVzdCAocGF0dGVybnMgdGVzdGVkKVxuXG5cbiAgaW5jbHVkZXNEYXRlKG90aGVyKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBjb25zdCBkYXRlID0gdGhpcy50b0RhdGVJbmZvKG90aGVyKTtcblxuICAgIGlmICghdGhpcy5zaGFsbG93SW5jbHVkZXNEYXRlKGRhdGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCByYW5nZSA9IHRoaXMucmFuZ2VTaGFsbG93SW50ZXJzZWN0aW5nUmFuZ2UodGhpcywgZGF0ZSk7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgdGhpcy5pdGVyYXRlRGF0ZXNJblJhbmdlKHJhbmdlLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmIChfdGhpczIubWF0Y2hlc0RheShzdGF0ZS5kYXkpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBkYXRlLm1hdGNoZXNEYXkoc3RhdGUuZGF5KTtcbiAgICAgICAgc3RhdGUuZmluaXNoZWQgPSAhcmVzdWx0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRGV0ZXJtaW5lcyBpZiB0aGlzIGRhdGUgY29tcGxldGVseSBpbmNsdWRlcyBhbm90aGVyIGRhdGVcbiAgLy8gTk9URTogVGhpcyBpcyBhIHNoYWxsb3cgdGVzdCAobm8gcGF0dGVybnMgdGVzdGVkKVxuXG5cbiAgc2hhbGxvd0luY2x1ZGVzRGF0ZShvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGVTaGFsbG93SW5jbHVkZXNEYXRlKHRoaXMsIG90aGVyLmlzRGF0ZSA/IG90aGVyIDogbmV3IGRhdGVJbmZvX0RhdGVJbmZvKG90aGVyLCB0aGlzLm9wdHMpKTtcbiAgfSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBEZXRlcm1pbmVzIGlmIGZpcnN0IGRhdGUgY29tcGxldGVseSBpbmNsdWRlcyBzZWNvbmQgZGF0ZVxuICAvLyBOT1RFOiBUaGlzIGlzIGEgc2hhbGxvdyB0ZXN0IChubyBwYXR0ZXJucyB0ZXN0ZWQpXG5cblxuICBkYXRlU2hhbGxvd0luY2x1ZGVzRGF0ZShkYXRlMSwgZGF0ZTIpIHtcbiAgICAvLyBGaXJzdCBkYXRlIGlzIHNpbXBsZSBkYXRlXG4gICAgaWYgKGRhdGUxLmlzRGF0ZSkge1xuICAgICAgaWYgKGRhdGUyLmlzRGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZTEuZGF0ZVRpbWUgPT09IGRhdGUyLmRhdGVUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGUyLnN0YXJ0VGltZSB8fCAhZGF0ZTIuZW5kVGltZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRlMS5kYXRlVGltZSA9PT0gZGF0ZTIuc3RhcnRUaW1lICYmIGRhdGUxLmRhdGVUaW1lID09PSBkYXRlMi5lbmRUaW1lO1xuICAgIH0gLy8gU2Vjb25kIGRhdGUgaXMgc2ltcGxlIGRhdGUgYW5kIGZpcnN0IGlzIGRhdGUgcmFuZ2VcblxuXG4gICAgaWYgKGRhdGUyLmlzRGF0ZSkge1xuICAgICAgaWYgKGRhdGUxLnN0YXJ0ICYmIGRhdGUyLmRhdGUgPCBkYXRlMS5zdGFydCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRlMS5lbmQgJiYgZGF0ZTIuZGF0ZSA+IGRhdGUxLmVuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gQm90aCBkYXRlcyBhcmUgZGF0ZSByYW5nZXNcblxuXG4gICAgaWYgKGRhdGUxLnN0YXJ0ICYmICghZGF0ZTIuc3RhcnQgfHwgZGF0ZTIuc3RhcnQgPCBkYXRlMS5zdGFydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZTEuZW5kICYmICghZGF0ZTIuZW5kIHx8IGRhdGUyLmVuZCA+IGRhdGUxLmVuZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGludGVyc2VjdHNEYXkoZGF5KSB7XG4gICAgLy8gRGF0ZSBpcyBvdXRzaWRlIGdlbmVyYWwgcmFuZ2UgLSByZXR1cm4gbnVsbFxuICAgIGlmICghdGhpcy5zaGFsbG93SW50ZXJzZWN0c0RhdGUoZGF5LnJhbmdlKSkgcmV0dXJuIG51bGw7IC8vIFJldHVybiB0aGlzIGRhdGUgaWYgcGF0dGVybnMgbWF0Y2hcblxuICAgIHJldHVybiB0aGlzLm1hdGNoZXNEYXkoZGF5KSA/IHRoaXMgOiBudWxsO1xuICB9XG5cbiAgbWF0Y2hlc0RheShkYXkpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIE5vIHBhdHRlcm5zIHRvIHRlc3RcbiAgICBpZiAoIXRoaXMub24pIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmICdhbmQnIGNvbmRpdGlvbiBmYWlsc1xuXG4gICAgaWYgKHRoaXMub24uYW5kICYmICFkYXRlSW5mb19EYXRlSW5mby50ZXN0Q29uZmlnKHRoaXMub24uYW5kLCBkYXksIHRoaXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBGYWlsIGlmIGV2ZXJ5ICdvcicgY29uZGl0aW9uIGZhaWxzXG5cblxuICAgIGlmICh0aGlzLm9uLm9yICYmICF0aGlzLm9uLm9yLnNvbWUoZnVuY3Rpb24gKG9yKSB7XG4gICAgICByZXR1cm4gZGF0ZUluZm9fRGF0ZUluZm8udGVzdENvbmZpZyhvciwgZGF5LCBfdGhpczMpO1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBQYXR0ZXJucyBtYXRjaFxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRvUmFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuaXNEYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IGRhdGVJbmZvX0RhdGVJbmZvKHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuZGF0ZSxcbiAgICAgICAgZW5kOiB0aGlzLmRhdGVcbiAgICAgIH0sIHRoaXMub3B0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBkYXRlSW5mb19EYXRlSW5mbyh7XG4gICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgIGVuZDogdGhpcy5lbmRcbiAgICB9LCB0aGlzLm9wdHMpO1xuICB9IC8vIEJ1aWxkIHRoZSAnY29tcGFyZSB0byBvdGhlcicgZnVuY3Rpb25cblxuXG4gIGNvbXBhcmUob3RoZXIpIHtcbiAgICBpZiAodGhpcy5vcmRlciAhPT0gb3RoZXIub3JkZXIpIHJldHVybiB0aGlzLm9yZGVyIC0gb3RoZXIub3JkZXI7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gb3RoZXIudHlwZSkgcmV0dXJuIHRoaXMuaXNEYXRlID8gMSA6IC0xO1xuICAgIGlmICh0aGlzLmlzRGF0ZSkgcmV0dXJuIDA7XG4gICAgY29uc3QgZGlmZiA9IHRoaXMuc3RhcnQgLSBvdGhlci5zdGFydDtcbiAgICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiB0aGlzLmVuZCAtIG90aGVyLmVuZDtcbiAgfVxuXG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9hdHRyaWJ1dGUuanNcblxuXG5cbmNsYXNzIGF0dHJpYnV0ZV9BdHRyaWJ1dGUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAga2V5LFxuICAgIGhhc2hjb2RlLFxuICAgIGhpZ2hsaWdodCxcbiAgICBjb250ZW50LFxuICAgIGRvdCxcbiAgICBiYXIsXG4gICAgcG9wb3ZlcixcbiAgICBkYXRlcyxcbiAgICBleGNsdWRlRGF0ZXMsXG4gICAgZXhjbHVkZU1vZGUsXG4gICAgY3VzdG9tRGF0YSxcbiAgICBvcmRlcixcbiAgICBwaW5QYWdlXG4gIH0sIHRoZW1lLCBsb2NhbGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5rZXkgPSBpc1VuZGVmaW5lZF9kZWZhdWx0KCkoa2V5KSA/IGNyZWF0ZUd1aWQoKSA6IGtleTtcbiAgICB0aGlzLmhhc2hjb2RlID0gaGFzaGNvZGU7XG4gICAgdGhpcy5jdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcbiAgICB0aGlzLm9yZGVyID0gb3JkZXIgfHwgMDtcbiAgICB0aGlzLmRhdGVPcHRzID0ge1xuICAgICAgb3JkZXIsXG4gICAgICBsb2NhbGVcbiAgICB9O1xuICAgIHRoaXMucGluUGFnZSA9IHBpblBhZ2U7IC8vIE5vcm1hbGl6ZSBhdHRyaWJ1dGUgdHlwZXNcblxuICAgIGlmIChoaWdobGlnaHQpIHtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ID0gdGhlbWUubm9ybWFsaXplSGlnaGxpZ2h0KGhpZ2hsaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIHRoaXMuY29udGVudCA9IHRoZW1lLm5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCk7XG4gICAgfVxuXG4gICAgaWYgKGRvdCkge1xuICAgICAgdGhpcy5kb3QgPSB0aGVtZS5ub3JtYWxpemVEb3QoZG90KTtcbiAgICB9XG5cbiAgICBpZiAoYmFyKSB7XG4gICAgICB0aGlzLmJhciA9IHRoZW1lLm5vcm1hbGl6ZUJhcihiYXIpO1xuICAgIH1cblxuICAgIGlmIChwb3BvdmVyKSB7XG4gICAgICB0aGlzLnBvcG92ZXIgPSBwb3BvdmVyO1xuICAgIH0gLy8gV3JhcCBkYXRlcyBpbiBhcnJheSBpZiBuZWVkZWRcblxuXG4gICAgaWYgKGRhdGVzKSB7XG4gICAgICB0aGlzLmRhdGVzID0gaXNBcnJheUxpa2VPYmplY3RfZGVmYXVsdCgpKGRhdGVzKSA/IGRhdGVzIDogW2RhdGVzXTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0RhdGVzID0gYXJyYXlIYXNJdGVtcyh0aGlzLmRhdGVzKTsgLy8gV3JhcCBleGNsdWRlIGRhdGVzIGluIGFycmF5IGlmIG5lZWRlZFxuXG4gICAgaWYgKGV4Y2x1ZGVEYXRlcykge1xuICAgICAgdGhpcy5leGNsdWRlRGF0ZXMgPSBpc0FycmF5TGlrZU9iamVjdF9kZWZhdWx0KCkoZXhjbHVkZURhdGVzKSA/IGV4Y2x1ZGVEYXRlcyA6IFtleGNsdWRlRGF0ZXNdO1xuICAgIH1cblxuICAgIHRoaXMuaGFzRXhjbHVkZURhdGVzID0gYXJyYXlIYXNJdGVtcyh0aGlzLmV4Y2x1ZGVEYXRlcyk7XG4gICAgdGhpcy5leGNsdWRlTW9kZSA9IGV4Y2x1ZGVNb2RlIHx8ICdpbnRlcnNlY3RzJzsgLy8gQXNzaWduIGZpbmFsIGRhdGVzXG5cbiAgICB0aGlzLmRhdGVzID0gKHRoaXMuaGFzRGF0ZXMgJiYgdGhpcy5kYXRlcyB8fCB0aGlzLmhhc0V4Y2x1ZGVEYXRlcyAmJiBbe31dIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkICYmIChkIGluc3RhbmNlb2YgZGF0ZUluZm9fRGF0ZUluZm8gPyBkIDogbmV3IGRhdGVJbmZvX0RhdGVJbmZvKGQsIF90aGlzLmRhdGVPcHRzKSk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTsgLy8gQXNzaWduIGZpbmFsIGV4Y2x1ZGUgZGF0ZXNcblxuICAgIHRoaXMuZXhjbHVkZURhdGVzID0gKHRoaXMuaGFzRXhjbHVkZURhdGVzICYmIHRoaXMuZXhjbHVkZURhdGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkICYmIChkIGluc3RhbmNlb2YgZGF0ZUluZm9fRGF0ZUluZm8gPyBkIDogbmV3IGRhdGVJbmZvX0RhdGVJbmZvKGQsIF90aGlzLmRhdGVPcHRzKSk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcbiAgICB0aGlzLmlzQ29tcGxleCA9IF9zb21lKHRoaXMuZGF0ZXMsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5pc0NvbXBsZXg7XG4gICAgfSk7XG4gIH0gLy8gQWNjZXB0czogRGF0ZSBvciBkYXRlIHJhbmdlIG9iamVjdFxuICAvLyBSZXR1cm5zOiBGaXJzdCBkYXRlIHRoYXQgcGFydGlhbGx5IGludGVyc2VjdHMgdGhlIGdpdmVuIGRhdGVcblxuXG4gIGludGVyc2VjdHNEYXRlKGRhdGUpIHtcbiAgICByZXR1cm4gIXRoaXMuZXhjbHVkZXNEYXRlKGRhdGUpICYmICh0aGlzLmRhdGVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmludGVyc2VjdHNEYXRlKGRhdGUpO1xuICAgIH0pIHx8IGZhbHNlKTtcbiAgfSAvLyBBY2NlcHRzOiBEYXRlIG9yIGRhdGUgcmFuZ2Ugb2JqZWN0XG4gIC8vIFJldHVybnM6IEZpcnN0IGRhdGUgdGhhdCBjb21wbGV0ZWx5IGluY2x1ZGVzIHRoZSBnaXZlbiBkYXRlXG5cblxuICBpbmNsdWRlc0RhdGUoZGF0ZSkge1xuICAgIGRhdGUgPSBkYXRlIGluc3RhbmNlb2YgZGF0ZUluZm9fRGF0ZUluZm8gPyBkYXRlIDogbmV3IGRhdGVJbmZvX0RhdGVJbmZvKGRhdGUsIHRoaXMuZGF0ZU9wdHMpO1xuICAgIHJldHVybiAhdGhpcy5leGNsdWRlc0RhdGUoZGF0ZSkgJiYgKHRoaXMuZGF0ZXMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQuaW5jbHVkZXNEYXRlKGRhdGUpO1xuICAgIH0pIHx8IGZhbHNlKTtcbiAgfVxuXG4gIGV4Y2x1ZGVzRGF0ZShkYXRlKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBkYXRlID0gZGF0ZSBpbnN0YW5jZW9mIGRhdGVJbmZvX0RhdGVJbmZvID8gZGF0ZSA6IG5ldyBkYXRlSW5mb19EYXRlSW5mbyhkYXRlLCB0aGlzLmRhdGVPcHRzKTtcbiAgICByZXR1cm4gdGhpcy5oYXNFeGNsdWRlRGF0ZXMgJiYgdGhpcy5leGNsdWRlRGF0ZXMuZmluZChmdW5jdGlvbiAoZWQpIHtcbiAgICAgIHJldHVybiBfdGhpczIuZXhjbHVkZU1vZGUgPT09ICdpbnRlcnNlY3RzJyAmJiBlZC5pbnRlcnNlY3RzRGF0ZShkYXRlKSB8fCBfdGhpczIuZXhjbHVkZU1vZGUgPT09ICdpbmNsdWRlcycgJiYgZWQuaW5jbHVkZXNEYXRlKGRhdGUpO1xuICAgIH0pO1xuICB9IC8vIEFjY2VwdHM6IERheSBvYmplY3RcbiAgLy8gUmV0dXJuczogRmlyc3QgYXR0cmlidXRlIGRhdGUgaW5mbyB0aGF0IG9jY3VycyBvbiBnaXZlbiBkYXkuXG5cblxuICBpbnRlcnNlY3RzRGF5KGRheSkge1xuICAgIHJldHVybiAhdGhpcy5leGNsdWRlc0RheShkYXkpICYmICh0aGlzLmRhdGVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmludGVyc2VjdHNEYXkoZGF5KTtcbiAgICB9KSB8fCBmYWxzZSk7XG4gIH1cblxuICBleGNsdWRlc0RheShkYXkpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNFeGNsdWRlRGF0ZXMgJiYgdGhpcy5leGNsdWRlRGF0ZXMuZmluZChmdW5jdGlvbiAoZWQpIHtcbiAgICAgIHJldHVybiBlZC5pbnRlcnNlY3RzRGF5KGRheSk7XG4gICAgfSk7XG4gIH1cblxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvbWl4aW5zL3Jvb3QuanNcblxuXG5cblxuXG5cblxuY29uc3Qgcm9vdE1peGluID0ge1xuICBtaXhpbnM6IFtkZWZhdWx0c01peGluXSxcbiAgcHJvcHM6IHtcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGlzRGFyazogQm9vbGVhbixcbiAgICBmaXJzdERheU9mV2VlazogTnVtYmVyLFxuICAgIG1hc2tzOiBPYmplY3QsXG4gICAgbG9jYWxlOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIHRpbWV6b25lOiBTdHJpbmcsXG4gICAgbWluRGF0ZTogbnVsbCxcbiAgICBtYXhEYXRlOiBudWxsLFxuICAgIGRpc2FibGVkRGF0ZXM6IG51bGwsXG4gICAgYXZhaWxhYmxlRGF0ZXM6IG51bGwsXG4gICAgdGhlbWU6IG51bGxcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAkdGhlbWUoKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIHRoZW1lIHByb3AgaWYgaXQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFRoZW1lIGNsYXNzXG4gICAgICBpZiAodGhpcy50aGVtZSBpbnN0YW5jZW9mIHRoZW1lX1RoZW1lKSByZXR1cm4gdGhpcy50aGVtZTsgLy8gQ3JlYXRlIHRoZSB0aGVtZVxuXG4gICAgICByZXR1cm4gbmV3IHRoZW1lX1RoZW1lKHtcbiAgICAgICAgY29sb3I6IHRoaXMucGFzc2VkUHJvcCgnY29sb3InLCAnYmx1ZScpLFxuICAgICAgICBpc0Rhcms6IHRoaXMucGFzc2VkUHJvcCgnaXNEYXJrJywgZmFsc2UpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgJGxvY2FsZSgpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgbG9jYWxlIHByb3AgaWYgaXQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIExvY2FsZSBjbGFzc1xuICAgICAgaWYgKHRoaXMubG9jYWxlIGluc3RhbmNlb2YgbG9jYWxlX0xvY2FsZSkgcmV0dXJuIHRoaXMubG9jYWxlOyAvLyBCdWlsZCB1cCBhIGJhc2UgY29uZmlnIGZyb20gY29tcG9uZW50IHByb3BzXG5cbiAgICAgIGNvbnN0IGNvbmZpZyA9IGlzT2JqZWN0KHRoaXMubG9jYWxlKSA/IHRoaXMubG9jYWxlIDoge1xuICAgICAgICBpZDogdGhpcy5sb2NhbGUsXG4gICAgICAgIGZpcnN0RGF5T2ZXZWVrOiB0aGlzLmZpcnN0RGF5T2ZXZWVrLFxuICAgICAgICBtYXNrczogdGhpcy5tYXNrc1xuICAgICAgfTsgLy8gUmV0dXJuIG5ldyBsb2NhbGVcblxuICAgICAgcmV0dXJuIG5ldyBsb2NhbGVfTG9jYWxlKGNvbmZpZywgdGhpcy4kbG9jYWxlcyk7XG4gICAgfSxcblxuICAgIGRpc2FibGVkQXR0cmlidXRlKCkge1xuICAgICAgLy8gQnVpbGQgdXAgYSBjb21wbGV0ZSBsaXN0IG9mIGRpc2FibGVkIGRhdGVzXG4gICAgICBsZXQgZGF0ZXMgPSBbXTsgLy8gSW5pdGlhbGl6ZSB3aXRoIGRpc2FibGVkIGRhdGVzIHByb3AsIGlmIGFueVxuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlZERhdGVzKSB7XG4gICAgICAgIGRhdGVzID0gaXNBcnJheUxpa2VPYmplY3RfZGVmYXVsdCgpKHRoaXMuZGlzYWJsZWREYXRlcykgPyB0aGlzLmRpc2FibGVkRGF0ZXMgOiBbdGhpcy5kaXNhYmxlZERhdGVzXTtcbiAgICAgIH0gLy8gQWRkIGRpc2FibGVkIGRhdGVzIGZvciBtaW5EYXRlIGFuZCBtYXhEYXRlIHByb3BzXG5cblxuICAgICAgY29uc3QgbWluRGF0ZSA9IHRoaXMubm9ybWFsaXplRGF0ZSh0aGlzLm1pbkRhdGUpO1xuICAgICAgY29uc3QgbWF4RGF0ZSA9IHRoaXMubm9ybWFsaXplRGF0ZSh0aGlzLm1heERhdGUpO1xuXG4gICAgICBpZiAobWluRGF0ZSkge1xuICAgICAgICBkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgICBlbmQ6IGFkZERheXMobWluRGF0ZSwgLTEpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4RGF0ZSkge1xuICAgICAgICBkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzdGFydDogYWRkRGF5cyhtYXhEYXRlLCAxKSxcbiAgICAgICAgICBlbmQ6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFJldHVybiB0aGUgbmV3IGRpc2FibGVkIGF0dHJpYnV0ZVxuXG5cbiAgICAgIHJldHVybiBuZXcgYXR0cmlidXRlX0F0dHJpYnV0ZSh7XG4gICAgICAgIGtleTogJ2Rpc2FibGVkJyxcbiAgICAgICAgZGF0ZXMsXG4gICAgICAgIGV4Y2x1ZGVEYXRlczogdGhpcy5hdmFpbGFibGVEYXRlcyxcbiAgICAgICAgZXhjbHVkZU1vZGU6ICdpbmNsdWRlcycsXG4gICAgICAgIG9yZGVyOiAxMDBcbiAgICAgIH0sIHRoaXMuJHRoZW1lLCB0aGlzLiRsb2NhbGUpO1xuICAgIH1cblxuICB9LFxuXG4gIGNyZWF0ZWQoKSB7XG4gICAgc2V0dXBTY3JlZW5zKHRoaXMuJGRlZmF1bHRzLnNjcmVlbnMpO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBmb3JtYXREYXRlKGRhdGUsIG1hc2spIHtcbiAgICAgIHJldHVybiB0aGlzLiRsb2NhbGUgPyB0aGlzLiRsb2NhbGUuZm9ybWF0KGRhdGUsIG1hc2spIDogJyc7XG4gICAgfSxcblxuICAgIHBhcnNlRGF0ZSh0ZXh0LCBtYXNrKSB7XG4gICAgICBpZiAoIXRoaXMuJGxvY2FsZSkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuJGxvY2FsZS5wYXJzZSh0ZXh0LCBtYXNrKTtcbiAgICAgIHJldHVybiBfaXNEYXRlKHZhbHVlKSA/IHZhbHVlIDogbnVsbDtcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplRGF0ZShkYXRlLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLiRsb2NhbGUgPyB0aGlzLiRsb2NhbGUubm9ybWFsaXplRGF0ZShkYXRlLCBjb25maWcpIDogZGF0ZTtcbiAgICB9XG5cbiAgfVxufTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL21peGlucy9zYWZlU2NvcGVkU2xvdC5qc1xuXG5jb25zdCBzYWZlU2NvcGVkU2xvdE1peGluID0ge1xuICBtZXRob2RzOiB7XG4gICAgc2FmZVNjb3BlZFNsb3QobmFtZSwgYXJncywgZGVmID0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb25fZGVmYXVsdCgpKHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdKSA/IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdKGFyZ3MpIDogZGVmO1xuICAgIH1cblxuICB9XG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvbWl4aW5zL2luZGV4LmpzXG5cblxuXG5jb25zdCBtaXhpbnNfY2hpbGRNaXhpbiA9IGNoaWxkTWl4aW47XG5jb25zdCBtaXhpbnNfcm9vdE1peGluID0gcm9vdE1peGluO1xuY29uc3QgbWl4aW5zX3NhZmVTY29wZWRTbG90TWl4aW4gPSBzYWZlU2NvcGVkU2xvdE1peGluO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1BvcG92ZXJSb3cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgUG9wb3ZlclJvd3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdQb3BvdmVyUm93JyxcbiAgbWl4aW5zOiBbbWl4aW5zX2NoaWxkTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGF0dHJpYnV0ZTogT2JqZWN0XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaW5kaWNhdG9yKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBoaWdobGlnaHQsXG4gICAgICAgIGRvdCxcbiAgICAgICAgYmFyLFxuICAgICAgICBwb3BvdmVyXG4gICAgICB9ID0gdGhpcy5hdHRyaWJ1dGU7XG4gICAgICBpZiAocG9wb3ZlciAmJiBwb3BvdmVyLmhpZGVJbmRpY2F0b3IpIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBpc0RhcmtcbiAgICAgICAgfSA9IGhpZ2hsaWdodC5zdGFydDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHlsZTogeyAuLi50aGlzLnRoZW1lLmJnQWNjZW50SGlnaCh7XG4gICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICBpc0Rhcms6ICFpc0RhcmtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2lkdGg6ICcxMHB4JyxcbiAgICAgICAgICAgIGhlaWdodDogJzVweCcsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6ICczcHgnXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZG90KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBpc0RhcmtcbiAgICAgICAgfSA9IGRvdC5zdGFydDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHlsZTogeyAuLi50aGlzLnRoZW1lLmJnQWNjZW50SGlnaCh7XG4gICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICBpc0Rhcms6ICFpc0RhcmtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2lkdGg6ICc1cHgnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnNXB4JyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJSdcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChiYXIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIGlzRGFya1xuICAgICAgICB9ID0gYmFyLnN0YXJ0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0eWxlOiB7IC4uLnRoaXMudGhlbWUuYmdBY2NlbnRIaWdoKHtcbiAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgIGlzRGFyazogIWlzRGFya1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3aWR0aDogJzEwcHgnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnM3B4J1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Qb3BvdmVyUm93LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX1BvcG92ZXJSb3d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoUG9wb3ZlclJvd3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1BvcG92ZXJSb3cudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NDk3NWQ2OWUmbGFuZz1wb3N0Y3NzJnNjb3BlZD10cnVlJlxudmFyIFBvcG92ZXJSb3d2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzQ5NzVkNjllX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmIyN1wiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9Qb3BvdmVyUm93LnZ1ZVxuXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgUG9wb3ZlclJvd19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfUG9wb3ZlclJvd3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgUG9wb3ZlclJvd3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzQ5NzVkNjllX3Njb3BlZF90cnVlX3JlbmRlcixcbiAgUG9wb3ZlclJvd3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzQ5NzVkNjllX3Njb3BlZF90cnVlX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNDk3NWQ2OWVcIixcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgUG9wb3ZlclJvdyA9IChQb3BvdmVyUm93X2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9HcmlkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuY29uc3QgZGlyZWN0aW9ucyA9IHtcbiAgdkxlYWRpbmc6ICd2ZXJ0aWNhbC1sZWFkaW5nJyxcbiAgdlRyYWlsaW5nOiAndmVydGljYWwtdHJhaWxpbmcnLFxuICBoTGVhZGluZzogJ2hvcml6b250YWwtbGVhZGluZycsXG4gIGhUcmFpbGluZzogJ2hvcml6b250YWwtdHJhaWxpbmcnXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdHcmlkJyxcblxuICByZW5kZXIoaCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBHcmlkIGNlbGwgcmVuZGVyZXJcbiAgICBjb25zdCBnZXRDZWxsID0gZnVuY3Rpb24gKHtcbiAgICAgIG5vZGVzLFxuICAgICAgcG9zaXRpb24sXG4gICAgICByb3csXG4gICAgICBjb2x1bW5cbiAgICB9KSB7XG4gICAgICAvLyBHZXQgdGhlIGRlZmF1bHQgc2xvdCBmaXJzdFxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+PSBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbm9kZXNbcG9zaXRpb24gLSAxXTtcbiAgICAgIH0gLy8gR2V0IHRoZSBzY29wZWQgc2xvdCBzZWNvbmRcblxuXG4gICAgICBpZiAoX3RoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0KHtcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICByb3csXG4gICAgICAgICAgY29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9OyAvLyBHcmlkIGNlbGxzIHJlbmRlcmVyXG5cblxuICAgIGNvbnN0IGdldENlbGxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgY2VsbHMgPSBbXTsgLy8gUmVzb2x2ZSBkZWZhdWx0IHNsb3Qgbm9kZXMgKHJlbW92ZSB3aGl0ZXNwYWNlZClcblxuICAgICAgY29uc3Qgbm9kZXMgPSBfdGhpcy4kc2xvdHMuZGVmYXVsdCAmJiBfdGhpcy4kc2xvdHMuZGVmYXVsdC5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG4udGFnICE9PSB1bmRlZmluZWQ7XG4gICAgICB9KSB8fCBbXTsgLy8gQnVpbGQgY2VsbHNcblxuICAgICAgZm9yIChsZXQgciA9IDEsIHAgPSAxOyByIDw9IF90aGlzLnJvd3M7IHIrKykge1xuICAgICAgICBmb3IgKGxldCBjID0gMTsgYyA8PSBfdGhpcy5jb2x1bW5zOyBjKyspIHtcbiAgICAgICAgICBjb25zdCByRnJvbUVuZCA9IHIgLSBfdGhpcy5yb3dzIC0gMTtcbiAgICAgICAgICBjb25zdCBjRnJvbUVuZCA9IGMgLSBfdGhpcy5jb2x1bW5zIC0gMTsgLy8gQWRkIHRoZSBjZWxsIGZvciBjdXJyZW50IHJvdyAmIGNvbHVtblxuXG4gICAgICAgICAgY2VsbHMucHVzaChoKCdkaXYnLCB7XG4gICAgICAgICAgICBjbGFzczogWyd2Yy1ncmlkLWNlbGwnLCBgdmMtZ3JpZC1jZWxsLXJvdy0ke3J9YCwgYHZjLWdyaWQtY2VsbC1yb3ctJHtyRnJvbUVuZH1gLCBgdmMtZ3JpZC1jZWxsLWNvbC0ke2N9YCwgYHZjLWdyaWQtY2VsbC1jb2wtJHtjRnJvbUVuZH1gXSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICdncmlkLXJvdyc6IHIsXG4gICAgICAgICAgICAgICdncmlkLWNvbHVtbic6IGNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBrZXlkb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVDZWxsS2V5ZG93bih7XG4gICAgICAgICAgICAgICAgICByb3c6IHIsXG4gICAgICAgICAgICAgICAgICBjb2x1bW46IGMsXG4gICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgW2dldENlbGwoe1xuICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICBwb3NpdGlvbjogcCsrLFxuICAgICAgICAgICAgcm93OiByLFxuICAgICAgICAgICAgY29sdW1uOiBjXG4gICAgICAgICAgfSldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH07XG5cbiAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgY2xhc3M6ICd2Yy1ncmlkLWNvbnRhaW5lcicsXG4gICAgICBzdHlsZTogdGhpcy5jb250YWluZXJTdHlsZVxuICAgIH0sIFsuLi5nZXRDZWxscygpXSk7XG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICBjb3VudDogTnVtYmVyLFxuICAgIHJvd3M6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDFcbiAgICB9LFxuICAgIGNvbHVtbnM6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDFcbiAgICB9LFxuICAgIGdhcDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJzBweCdcbiAgICB9LFxuICAgIGF1dG9maXQ6IEJvb2xlYW4sXG4gICAgY29sdW1uV2lkdGg6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcxZnInXG4gICAgfSxcbiAgICBkaXNhYmxlRm9jdXM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjb250YWluZXJTdHlsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6IHRoaXMuZ3JpZFRlbXBsYXRlQ29sdW1ucyxcbiAgICAgICAgZ3JpZEdhcDogdGhpcy5nYXBcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnMoKSB7XG4gICAgICByZXR1cm4gYHJlcGVhdCgke3RoaXMuYXV0b2ZpdCA/ICdhdXRvLWZpdCcgOiB0aGlzLmNvbHVtbnN9LCAke3RoaXMuY29sdW1uV2lkdGh9KWA7XG4gICAgfVxuXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVDZWxsS2V5ZG93bih7XG4gICAgICByb3csXG4gICAgICBjb2x1bW4sXG4gICAgICBldmVudFxuICAgIH0pIHtcbiAgICAgIC8vIFJldHVybiBpZiBmb2N1cyBtYW5hZ2VtZW50IGlzIGRpc2FibGVkXG4gICAgICBpZiAodGhpcy5kaXNhYmxlRm9jdXMpIHJldHVybjtcbiAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICByb3csXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgYWx0OiBmYWxzZSxcbiAgICAgICAgaGFuZGxlZDogZmFsc2VcbiAgICAgIH07IC8vIEluY3JlbWVudCByb3cvY29sdW1uIGJhc2VkIG9uIGtleVxuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0ZS5yb3ctLTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRlLnJvdysrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdGUuY29sdW1uLS07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdGUuY29sdW1uKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdGUuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRlLmNvbHVtbiA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdQYWdlVXAnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRlLmFsdCA9IGV2ZW50LmFsdEtleTtcbiAgICAgICAgICAgIHN0YXRlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbnMudkxlYWRpbmc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnUGFnZURvd24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRlLmFsdCA9IGV2ZW50LmFsdEtleTtcbiAgICAgICAgICAgIHN0YXRlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbnMudlRyYWlsaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH0gLy8gSGFuZGxlIHN0YXRlIGZvciByb3cgcm9sbG92ZXJzXG5cblxuICAgICAgaWYgKHN0YXRlLnJvdyA8IDEpIHtcbiAgICAgICAgc3RhdGUuZGlyZWN0aW9uID0gZGlyZWN0aW9ucy52TGVhZGluZztcbiAgICAgICAgc3RhdGUucm93ID0gdGhpcy5yb3dzO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5yb3cgPiB0aGlzLnJvd3MpIHtcbiAgICAgICAgc3RhdGUuZGlyZWN0aW9uID0gZGlyZWN0aW9ucy52VHJhaWxpbmc7XG4gICAgICAgIHN0YXRlLnJvdyA9IDE7XG4gICAgICB9IC8vIEhhbmRsZSBzdGF0ZSBmb3IgY29sdW1uIHJvbGxvdmVyc1xuXG5cbiAgICAgIGlmIChzdGF0ZS5jb2x1bW4gPCAxKSB7XG4gICAgICAgIHN0YXRlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbnMuaExlYWRpbmc7XG4gICAgICAgIHN0YXRlLmNvbHVtbiA9IHRoaXMuY29sdW1ucztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuY29sdW1uID4gdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgIHN0YXRlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbnMuaFRyYWlsaW5nO1xuICAgICAgICBzdGF0ZS5jb2x1bW4gPSAxO1xuICAgICAgfSAvLyBFbWl0IHJvbGxvdmVyIGV2ZW50IGlmIGRpcmVjdGlvbiB3YXMgYXNzaWduZWRcblxuXG4gICAgICBpZiAoc3RhdGUuZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3JvbGxvdmVyJywgc3RhdGUpO1xuICAgICAgfSAvLyBGb2N1c2Qgb24gY2VsbCBmb3IgY3VycmVudCBzdGF0ZSBpZiBldmVudCB3YXNuJ3QgaGFuZGxlZFxuXG5cbiAgICAgIGlmICghc3RhdGUuaGFuZGxlZCkge1xuICAgICAgICAvLyBHZXQgZ3JpZCBjZWxsIGVsZW1lbnRcbiAgICAgICAgY29uc3QgY2VsbFNlbGVjdG9yID0gYC52Yy1ncmlkLWNlbGwtcm93LSR7c3RhdGUucm93fS52Yy1ncmlkLWNlbGwtY29sLSR7c3RhdGUuY29sdW1ufWA7XG4gICAgICAgIGNvbnN0IGNlbGxFbCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoY2VsbFNlbGVjdG9yKTtcblxuICAgICAgICBpZiAoY2VsbEVsKSB7XG4gICAgICAgICAgdGhpcy50cnlGb2N1cyhjZWxsRWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgdHJ5Rm9jdXMoZWwgPSB0aGlzLiRlbCkge1xuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzZWxlY3RvcnMgPSBbJy52Yy1ncmlkLWZvY3VzJywgJ2J1dHRvbiwgW2hyZWZdLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgW3RhYmluZGV4PVwiMFwiXScsICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCJ1bmRlZmluZWRcIl0pJ107XG4gICAgICAgIGNvbnN0IGZvY3VzYWJsZUVsID0gc2VsZWN0b3JzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yKHMpO1xuICAgICAgICB9KS5maW5kKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChmb2N1c2FibGVFbCkge1xuICAgICAgICAgIGZvY3VzYWJsZUVsLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0dyaWQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfR3JpZHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChHcmlkdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvR3JpZC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01ZTgyZTdlZCZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcbnZhciBHcmlkdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF81ZTgyZTdlZF9zY29wZWRfdHJ1ZV9sYW5nX2Nzc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzNlYVwiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9HcmlkLnZ1ZVxudmFyIEdyaWRfcmVuZGVyLCBHcmlkX3N0YXRpY1JlbmRlckZuc1xuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIEdyaWRfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0dyaWR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEdyaWRfcmVuZGVyLFxuICBHcmlkX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNWU4MmU3ZWRcIixcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgR3JpZCA9IChHcmlkX2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcIjg3NzM5NzllLXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyTmF2LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02ZjJjZGIxMSZcbnZhciBDYWxlbmRhck5hdnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzZmMmNkYjExX3JlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmMtbmF2LWNvbnRhaW5lclwifSxbX2MoJ2dyaWQnLHtyZWY6XCJoZWFkZXJHcmlkXCIsYXR0cnM6e1wiY29sdW1uc1wiOjN9LG9uOntcInJvbGxvdmVyXCI6X3ZtLm9uSGVhZGVyUm9sbG92ZXJ9fSxbX2MoJ3NwYW4nLHtyZWY6XCJwcmV2QnV0dG9uXCIsc3RhdGljQ2xhc3M6XCJ2Yy1uYXYtYXJyb3cgaXMtbGVmdFwiLGF0dHJzOntcInJvbGVcIjpcImJ1dHRvblwiLFwidGFiaW5kZXhcIjpcIi0xXCJ9LG9uOntcImNsaWNrXCI6X3ZtLm1vdmVQcmV2LFwia2V5ZG93blwiOmZ1bmN0aW9uIChlKSB7IHJldHVybiBfdm0ub25TcGFjZU9yRW50ZXIoZSwgX3ZtLm1vdmVQcmV2KTsgfX19LFtfdm0uX3QoXCJuYXYtbGVmdC1idXR0b25cIixbX2MoJ3N2Zy1pY29uJyx7YXR0cnM6e1wibmFtZVwiOlwibGVmdC1hcnJvd1wiLFwid2lkdGhcIjpcIjIwcHhcIixcImhlaWdodFwiOlwiMjRweFwifX0pXSldLDIpLF9jKCdzcGFuJyx7cmVmOlwidGl0bGVCdXR0b25cIixzdGF0aWNDbGFzczpcInZjLW5hdi10aXRsZSB2Yy1ncmlkLWZvY3VzXCIsc3R5bGU6KHsgd2hpdGVTcGFjZTogJ25vd3JhcCcgfSksYXR0cnM6e1wicm9sZVwiOlwiYnV0dG9uXCIsXCJ0YWJpbmRleFwiOlwiMFwifSxvbjp7XCJjbGlja1wiOl92bS50b2dnbGVNb2RlLFwia2V5ZG93blwiOmZ1bmN0aW9uIChlKSB7IHJldHVybiBfdm0ub25TcGFjZU9yRW50ZXIoZSwgX3ZtLnRvZ2dsZU1vZGUpOyB9fX0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLnRpdGxlKStcIiBcIildKSxfYygnc3Bhbicse3JlZjpcIm5leHRCdXR0b25cIixzdGF0aWNDbGFzczpcInZjLW5hdi1hcnJvdyBpcy1yaWdodFwiLGF0dHJzOntcInJvbGVcIjpcImJ1dHRvblwiLFwidGFiaW5kZXhcIjpcIi0xXCJ9LG9uOntcImNsaWNrXCI6X3ZtLm1vdmVOZXh0LFwia2V5ZG93blwiOmZ1bmN0aW9uIChlKSB7IHJldHVybiBfdm0ub25TcGFjZU9yRW50ZXIoZSwgX3ZtLm1vdmVOZXh0KTsgfX19LFtfdm0uX3QoXCJuYXYtcmlnaHQtYnV0dG9uXCIsW19jKCdzdmctaWNvbicse2F0dHJzOntcIm5hbWVcIjpcInJpZ2h0LWFycm93XCIsXCJ3aWR0aFwiOlwiMjBweFwiLFwiaGVpZ2h0XCI6XCIyNHB4XCJ9fSldKV0sMildKSxfYygnZ3JpZCcse3JlZjpcIml0ZW1zR3JpZFwiLGF0dHJzOntcInJvd3NcIjo0LFwiY29sdW1uc1wiOjMsXCJnYXBcIjpcIjJweCA1cHhcIn0sb246e1wicm9sbG92ZXJcIjpfdm0ub25JdGVtc1JvbGxvdmVyfX0sX3ZtLl9sKChfdm0uYWN0aXZlSXRlbXMpLGZ1bmN0aW9uKGl0ZW0pe3JldHVybiBfYygnc3Bhbicse2tleTppdGVtLmxhYmVsLHJlZjpcIml0ZW1zXCIscmVmSW5Gb3I6dHJ1ZSxjbGFzczpfdm0uZ2V0SXRlbUNsYXNzZXMoaXRlbSksYXR0cnM6e1wicm9sZVwiOlwiYnV0dG9uXCIsXCJhcmlhLWxhYmVsXCI6aXRlbS5hcmlhTGFiZWwsXCJ0YWJpbmRleFwiOml0ZW0uaXNEaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGl0ZW0uaXNBY3RpdmUgPyAwIDogLTF9LG9uOntcImNsaWNrXCI6aXRlbS5jbGljayxcImtleWRvd25cIjpmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3ZtLm9uU3BhY2VPckVudGVyKGUsIGl0ZW0uY2xpY2spOyB9fX0sW192bS5fdihcIiBcIitfdm0uX3MoaXRlbS5sYWJlbCkrXCIgXCIpXSl9KSwwKV0sMSl9XG52YXIgQ2FsZW5kYXJOYXZ2dWVfdHlwZV90ZW1wbGF0ZV9pZF82ZjJjZGIxMV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQ2FsZW5kYXJOYXYudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTZmMmNkYjExJlxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1wiY2FjaGVEaXJlY3RvcnlcIjpcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclwiLFwiY2FjaGVJZGVudGlmaWVyXCI6XCI4NzczOTc5ZS12dWUtbG9hZGVyLXRlbXBsYXRlXCJ9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9TdmdJY29uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xOWI2Y2Y3OCZzY29wZWQ9dHJ1ZSZcbnZhciBTdmdJY29udnVlX3R5cGVfdGVtcGxhdGVfaWRfMTliNmNmNzhfc2NvcGVkX3RydWVfcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnc3ZnJyxfdm0uX2coe3N0YXRpY0NsYXNzOlwidmMtc3ZnLWljb25cIixhdHRyczp7XCJ3aWR0aFwiOl92bS53aWR0aCxcImhlaWdodFwiOl92bS5oZWlnaHQsXCJ2aWV3Qm94XCI6X3ZtLnZpZXdCb3h9fSxfdm0uJGxpc3RlbmVycyksW19jKCdwYXRoJyx7YXR0cnM6e1wiZFwiOl92bS5wYXRofX0pXSl9XG52YXIgU3ZnSWNvbnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzE5YjZjZjc4X3Njb3BlZF90cnVlX3N0YXRpY1JlbmRlckZucyA9IFtdXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TdmdJY29uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xOWI2Y2Y3OCZzY29wZWQ9dHJ1ZSZcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1N2Z0ljb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuY29uc3QgX2RlZlNpemUgPSAnMjZweCc7XG5jb25zdCBfZGVmVmlld0JveCA9ICcwIDAgMzIgMzInO1xuY29uc3QgaWNvbnMgPSB7XG4gICdsZWZ0LWFycm93Jzoge1xuICAgIHZpZXdCb3g6ICcwIC0xIDE2IDM0JyxcbiAgICBwYXRoOiAnTTExLjE5NiAxMGMwIDAuMTQzLTAuMDcxIDAuMzA0LTAuMTc5IDAuNDExbC03LjAxOCA3LjAxOCA3LjAxOCA3LjAxOGMwLjEwNyAwLjEwNyAwLjE3OSAwLjI2OCAwLjE3OSAwLjQxMXMtMC4wNzEgMC4zMDQtMC4xNzkgMC40MTFsLTAuODkzIDAuODkzYy0wLjEwNyAwLjEwNy0wLjI2OCAwLjE3OS0wLjQxMSAwLjE3OXMtMC4zMDQtMC4wNzEtMC40MTEtMC4xNzlsLTguMzIxLTguMzIxYy0wLjEwNy0wLjEwNy0wLjE3OS0wLjI2OC0wLjE3OS0wLjQxMXMwLjA3MS0wLjMwNCAwLjE3OS0wLjQxMWw4LjMyMS04LjMyMWMwLjEwNy0wLjEwNyAwLjI2OC0wLjE3OSAwLjQxMS0wLjE3OXMwLjMwNCAwLjA3MSAwLjQxMSAwLjE3OWwwLjg5MyAwLjg5M2MwLjEwNyAwLjEwNyAwLjE3OSAwLjI1IDAuMTc5IDAuNDExeidcbiAgfSxcbiAgJ3JpZ2h0LWFycm93Jzoge1xuICAgIHZpZXdCb3g6ICctNSAtMSAxNiAzNCcsXG4gICAgcGF0aDogJ00xMC42MjUgMTcuNDI5YzAgMC4xNDMtMC4wNzEgMC4zMDQtMC4xNzkgMC40MTFsLTguMzIxIDguMzIxYy0wLjEwNyAwLjEwNy0wLjI2OCAwLjE3OS0wLjQxMSAwLjE3OXMtMC4zMDQtMC4wNzEtMC40MTEtMC4xNzlsLTAuODkzLTAuODkzYy0wLjEwNy0wLjEwNy0wLjE3OS0wLjI1LTAuMTc5LTAuNDExIDAtMC4xNDMgMC4wNzEtMC4zMDQgMC4xNzktMC40MTFsNy4wMTgtNy4wMTgtNy4wMTgtNy4wMThjLTAuMTA3LTAuMTA3LTAuMTc5LTAuMjY4LTAuMTc5LTAuNDExczAuMDcxLTAuMzA0IDAuMTc5LTAuNDExbDAuODkzLTAuODkzYzAuMTA3LTAuMTA3IDAuMjY4LTAuMTc5IDAuNDExLTAuMTc5czAuMzA0IDAuMDcxIDAuNDExIDAuMTc5bDguMzIxIDguMzIxYzAuMTA3IDAuMTA3IDAuMTc5IDAuMjY4IDAuMTc5IDAuNDExeidcbiAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIFN2Z0ljb252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBwcm9wczogWyduYW1lJ10sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IF9kZWZTaXplLFxuICAgICAgaGVpZ2h0OiBfZGVmU2l6ZSxcbiAgICAgIHZpZXdCb3g6IF9kZWZWaWV3Qm94LFxuICAgICAgcGF0aDogJycsXG4gICAgICBpc0Jhc2VsaW5lOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnVwZGF0ZUljb24oKTtcbiAgfSxcblxuICB3YXRjaDoge1xuICAgIG5hbWUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUljb24oKTtcbiAgICB9XG5cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHVwZGF0ZUljb24oKSB7XG4gICAgICBjb25zdCBpY29uID0gaWNvbnNbdGhpcy5uYW1lXTtcblxuICAgICAgaWYgKGljb24pIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IGljb24ud2lkdGggfHwgX2RlZlNpemU7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaWNvbi5oZWlnaHQgfHwgX2RlZlNpemU7XG4gICAgICAgIHRoaXMudmlld0JveCA9IGljb24udmlld0JveDtcbiAgICAgICAgdGhpcy5wYXRoID0gaWNvbi5wYXRoO1xuICAgICAgfVxuICAgIH1cblxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU3ZnSWNvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19TdmdJY29udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFN2Z0ljb252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9TdmdJY29uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTE5YjZjZjc4Jmxhbmc9cG9zdGNzcyZzY29wZWQ9dHJ1ZSZcbnZhciBTdmdJY29udnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF8xOWI2Y2Y3OF9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNjMmVcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvU3ZnSWNvbi52dWVcblxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFN2Z0ljb25fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1N2Z0ljb252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFN2Z0ljb252dWVfdHlwZV90ZW1wbGF0ZV9pZF8xOWI2Y2Y3OF9zY29wZWRfdHJ1ZV9yZW5kZXIsXG4gIFN2Z0ljb252dWVfdHlwZV90ZW1wbGF0ZV9pZF8xOWI2Y2Y3OF9zY29wZWRfdHJ1ZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjE5YjZjZjc4XCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIFN2Z0ljb24gPSAoU3ZnSWNvbl9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQ2FsZW5kYXJOYXYudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cbmNvbnN0IF95ZWFyR3JvdXBDb3VudCA9IDEyO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgQ2FsZW5kYXJOYXZ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnQ2FsZW5kYXJOYXYnLFxuICBjb21wb25lbnRzOiB7XG4gICAgR3JpZDogR3JpZCxcbiAgICBTdmdJY29uOiBTdmdJY29uXG4gIH0sXG4gIG1peGluczogW21peGluc19jaGlsZE1peGluXSxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vbnRoOiAwLFxuICAgICAgICAgIHllYXI6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRvcjoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vbnRoTW9kZTogdHJ1ZSxcbiAgICAgIHllYXJJbmRleDogMCxcbiAgICAgIHllYXJHcm91cEluZGV4OiAwLFxuICAgICAgb25TcGFjZU9yRW50ZXI6IG9uU3BhY2VPckVudGVyXG4gICAgfTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIG1vbnRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLm1vbnRoIHx8IDAgOiAwO1xuICAgIH0sXG5cbiAgICB5ZWFyKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnllYXIgfHwgMCA6IDA7XG4gICAgfSxcblxuICAgIHRpdGxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9udGhNb2RlID8gdGhpcy55ZWFySW5kZXggOiBgJHt0aGlzLmZpcnN0WWVhcn0gLSAke3RoaXMubGFzdFllYXJ9YDtcbiAgICB9LFxuXG4gICAgbW9udGhJdGVtcygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbW9udGg6IHRoaXNNb250aCxcbiAgICAgICAgeWVhcjogdGhpc1llYXJcbiAgICAgIH0gPSBwYWdlRm9yRGF0ZShuZXcgRGF0ZSgpKTtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsZS5nZXRNb250aERhdGVzKCkubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gaSArIDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFiZWw6IF90aGlzLmxvY2FsZS5mb3JtYXQoZCwgX3RoaXMubWFza3MubmF2TW9udGhzKSxcbiAgICAgICAgICBhcmlhTGFiZWw6IF90aGlzLmxvY2FsZS5mb3JtYXQoZCwgJ01NTU0gWVlZWScpLFxuICAgICAgICAgIGlzQWN0aXZlOiBtb250aCA9PT0gX3RoaXMubW9udGggJiYgX3RoaXMueWVhckluZGV4ID09PSBfdGhpcy55ZWFyLFxuICAgICAgICAgIGlzQ3VycmVudDogbW9udGggPT09IHRoaXNNb250aCAmJiBfdGhpcy55ZWFySW5kZXggPT09IHRoaXNZZWFyLFxuICAgICAgICAgIGlzRGlzYWJsZWQ6ICFfdGhpcy52YWxpZGF0b3Ioe1xuICAgICAgICAgICAgbW9udGgsXG4gICAgICAgICAgICB5ZWFyOiBfdGhpcy55ZWFySW5kZXhcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1vbnRoQ2xpY2sobW9udGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB5ZWFySXRlbXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgY29uc3Qge1xuICAgICAgICBfLFxuICAgICAgICB5ZWFyOiB0aGlzWWVhclxuICAgICAgfSA9IHBhZ2VGb3JEYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgY29uc3Qgc3RhcnRZZWFyID0gdGhpcy55ZWFyR3JvdXBJbmRleCAqIF95ZWFyR3JvdXBDb3VudDtcbiAgICAgIGNvbnN0IGVuZFllYXIgPSBzdGFydFllYXIgKyBfeWVhckdyb3VwQ291bnQ7XG4gICAgICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gICAgICBmb3IgKGxldCB5ZWFyID0gc3RhcnRZZWFyOyB5ZWFyIDwgZW5kWWVhcjsgeWVhciArPSAxKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIHllYXIsXG4gICAgICAgICAgbGFiZWw6IHllYXIsXG4gICAgICAgICAgYXJpYUxhYmVsOiB5ZWFyLFxuICAgICAgICAgIGlzQWN0aXZlOiB5ZWFyID09PSB0aGlzLnllYXIsXG4gICAgICAgICAgaXNDdXJyZW50OiB5ZWFyID09PSB0aGlzWWVhcixcbiAgICAgICAgICBpc0Rpc2FibGVkOiAhdGhpcy52YWxpZGF0b3Ioe1xuICAgICAgICAgICAgbW9udGg6IHRoaXMubW9udGgsXG4gICAgICAgICAgICB5ZWFyXG4gICAgICAgICAgfSksXG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIueWVhckNsaWNrKHllYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuXG4gICAgYWN0aXZlSXRlbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb250aE1vZGUgPyB0aGlzLm1vbnRoSXRlbXMgOiB0aGlzLnllYXJJdGVtcztcbiAgICB9LFxuXG4gICAgZmlyc3RZZWFyKCkge1xuICAgICAgcmV0dXJuIGhlYWRfZGVmYXVsdCgpKHRoaXMueWVhckl0ZW1zLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS55ZWFyO1xuICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBsYXN0WWVhcigpIHtcbiAgICAgIHJldHVybiBsYXN0X2RlZmF1bHQoKSh0aGlzLnllYXJJdGVtcy5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkueWVhcjtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB5ZWFyKCkge1xuICAgICAgdGhpcy55ZWFySW5kZXggPSB0aGlzLnllYXI7XG4gICAgfSxcblxuICAgIHllYXJJbmRleCh2YWwpIHtcbiAgICAgIHRoaXMueWVhckdyb3VwSW5kZXggPSB0aGlzLmdldFllYXJHcm91cEluZGV4KHZhbCk7XG4gICAgfVxuXG4gIH0sXG5cbiAgY3JlYXRlZCgpIHtcbiAgICB0aGlzLnllYXJJbmRleCA9IHRoaXMueWVhcjtcbiAgfSxcblxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuJHJlZnMuaXRlbXNHcmlkLnRyeUZvY3VzKCk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGdldEl0ZW1DbGFzc2VzKHtcbiAgICAgIGlzQWN0aXZlLFxuICAgICAgaXNDdXJyZW50LFxuICAgICAgaXNEaXNhYmxlZFxuICAgIH0pIHtcbiAgICAgIGNvbnN0IGNsYXNzZXMgPSBbJ3ZjLW5hdi1pdGVtJ107XG5cbiAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goJ2lzLWFjdGl2ZScsICd2Yy1ncmlkLWZvY3VzJyk7XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VycmVudCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goJ2lzLWluYWN0aXZlLWN1cnJlbnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXNzZXMucHVzaCgnaXMtaW5hY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKCdpcy1kaXNhYmxlZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9LFxuXG4gICAgZ2V0WWVhckdyb3VwSW5kZXgoeWVhcikge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoeWVhciAvIF95ZWFyR3JvdXBDb3VudCk7XG4gICAgfSxcblxuICAgIG1vbnRoQ2xpY2sobW9udGgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2lucHV0Jywge1xuICAgICAgICBtb250aCxcbiAgICAgICAgeWVhcjogdGhpcy55ZWFySW5kZXhcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB5ZWFyQ2xpY2soeWVhcikge1xuICAgICAgdGhpcy55ZWFySW5kZXggPSB5ZWFyO1xuICAgICAgdGhpcy5tb250aE1vZGUgPSB0cnVlO1xuICAgICAgdGhpcy4kcmVmcy5pdGVtc0dyaWQudHJ5Rm9jdXMoKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlTW9kZSgpIHtcbiAgICAgIHRoaXMubW9udGhNb2RlID0gIXRoaXMubW9udGhNb2RlO1xuICAgIH0sXG5cbiAgICBtb3ZlUHJldigpIHtcbiAgICAgIGlmICh0aGlzLm1vbnRoTW9kZSkge1xuICAgICAgICB0aGlzLm1vdmVQcmV2WWVhcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vdmVQcmV2WWVhckdyb3VwKCk7XG4gICAgfSxcblxuICAgIG1vdmVOZXh0KCkge1xuICAgICAgaWYgKHRoaXMubW9udGhNb2RlKSB7XG4gICAgICAgIHRoaXMubW92ZU5leHRZZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW92ZU5leHRZZWFyR3JvdXAoKTtcbiAgICB9LFxuXG4gICAgbW92ZVByZXZZZWFyKCkge1xuICAgICAgdGhpcy55ZWFySW5kZXgtLTtcbiAgICB9LFxuXG4gICAgbW92ZU5leHRZZWFyKCkge1xuICAgICAgdGhpcy55ZWFySW5kZXgrKztcbiAgICB9LFxuXG4gICAgbW92ZVByZXZZZWFyR3JvdXAoKSB7XG4gICAgICB0aGlzLnllYXJHcm91cEluZGV4LS07XG4gICAgfSxcblxuICAgIG1vdmVOZXh0WWVhckdyb3VwKCkge1xuICAgICAgdGhpcy55ZWFyR3JvdXBJbmRleCsrO1xuICAgIH0sXG5cbiAgICBvbkhlYWRlclJvbGxvdmVyKGUpIHtcbiAgICAgIHN3aXRjaCAoZS5kaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAndmVydGljYWwtdHJhaWxpbmcnOlxuICAgICAgICAgIHRoaXMuJHJlZnMuaXRlbXNHcmlkLnRyeUZvY3VzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGUuaGFuZGxlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIG9uSXRlbXNSb2xsb3ZlcihlKSB7XG4gICAgICBzd2l0Y2ggKGUuZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2hvcml6b250YWwtbGVhZGluZyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tb3ZlUHJldigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2hvcml6b250YWwtdHJhaWxpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubW92ZU5leHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICd2ZXJ0aWNhbC1sZWFkaW5nJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLiRyZWZzLmhlYWRlckdyaWQudHJ5Rm9jdXMoKTtcbiAgICAgICAgICAgIGUuaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAndmVydGljYWwtdHJhaWxpbmcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGUuaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9DYWxlbmRhck5hdi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19DYWxlbmRhck5hdnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDYWxlbmRhck5hdnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyTmF2LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9cG9zdGNzcyZcbnZhciBDYWxlbmRhck5hdnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19wb3N0Y3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzYzU1XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyTmF2LnZ1ZVxuXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgQ2FsZW5kYXJOYXZfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0NhbGVuZGFyTmF2dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDYWxlbmRhck5hdnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzZmMmNkYjExX3JlbmRlcixcbiAgQ2FsZW5kYXJOYXZ2dWVfdHlwZV90ZW1wbGF0ZV9pZF82ZjJjZGIxMV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBDYWxlbmRhck5hdiA9IChDYWxlbmRhck5hdl9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9wb3BvdmVycy5qc1xuXG5mdW5jdGlvbiBwb3BvdmVyc19zaG93UG9wb3ZlcihvcHRzKSB7XG4gIGlmIChkb2N1bWVudCkge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzaG93LXBvcG92ZXInLCB7XG4gICAgICBkZXRhaWw6IG9wdHNcbiAgICB9KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvcG92ZXJzX2hpZGVQb3BvdmVyKG9wdHMpIHtcbiAgaWYgKGRvY3VtZW50KSB7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2hpZGUtcG9wb3ZlcicsIHtcbiAgICAgIGRldGFpbDogb3B0c1xuICAgIH0pKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9wb3ZlcnNfdG9nZ2xlUG9wb3ZlcihvcHRzKSB7XG4gIGlmIChkb2N1bWVudCkge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd0b2dnbGUtcG9wb3ZlcicsIHtcbiAgICAgIGRldGFpbDogb3B0c1xuICAgIH0pKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUG9wb3ZlcihvcHRzKSB7XG4gIGlmIChkb2N1bWVudCkge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCd1cGRhdGUtcG9wb3ZlcicsIHtcbiAgICAgIGRldGFpbDogb3B0c1xuICAgIH0pKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UG9wb3ZlclRyaWdnZXJFdmVudHMob3B0cykge1xuICBjb25zdCB7XG4gICAgdmlzaWJpbGl0eVxuICB9ID0gb3B0cztcbiAgY29uc3QgY2xpY2sgPSB2aXNpYmlsaXR5ID09PSAnY2xpY2snO1xuICBjb25zdCBob3ZlciA9IHZpc2liaWxpdHkgPT09ICdob3Zlcic7XG4gIGNvbnN0IGhvdmVyRm9jdXMgPSB2aXNpYmlsaXR5ID09PSAnaG92ZXItZm9jdXMnO1xuICBjb25zdCBmb2N1cyA9IHZpc2liaWxpdHkgPT09ICdmb2N1cyc7XG4gIG9wdHMuYXV0b0hpZGUgPSAhY2xpY2s7XG4gIGxldCBob3ZlcmVkID0gZmFsc2U7XG4gIGxldCBmb2N1c2VkID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgY2xpY2soZSkge1xuICAgICAgaWYgKGNsaWNrKSB7XG4gICAgICAgIG9wdHMucmVmID0gZS50YXJnZXQ7XG4gICAgICAgIHBvcG92ZXJzX3RvZ2dsZVBvcG92ZXIob3B0cyk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1vdXNlbW92ZShlKSB7XG4gICAgICBvcHRzLnJlZiA9IGUuY3VycmVudFRhcmdldDtcblxuICAgICAgaWYgKCFob3ZlcmVkKSB7XG4gICAgICAgIGhvdmVyZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChob3ZlciB8fCBob3ZlckZvY3VzKSB7XG4gICAgICAgICAgcG9wb3ZlcnNfc2hvd1BvcG92ZXIob3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91c2VsZWF2ZShlKSB7XG4gICAgICBvcHRzLnJlZiA9IGUudGFyZ2V0O1xuXG4gICAgICBpZiAoaG92ZXJlZCkge1xuICAgICAgICBob3ZlcmVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGhvdmVyIHx8IGhvdmVyRm9jdXMgJiYgIWZvY3VzZWQpIHtcbiAgICAgICAgICBwb3BvdmVyc19oaWRlUG9wb3ZlcihvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmb2N1c2luKGUpIHtcbiAgICAgIG9wdHMucmVmID0gZS5jdXJyZW50VGFyZ2V0O1xuXG4gICAgICBpZiAoIWZvY3VzZWQpIHtcbiAgICAgICAgZm9jdXNlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKGZvY3VzIHx8IGhvdmVyRm9jdXMpIHtcbiAgICAgICAgICBwb3BvdmVyc19zaG93UG9wb3ZlcihvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmb2N1c291dChlKSB7XG4gICAgICBvcHRzLnJlZiA9IGUuY3VycmVudFRhcmdldDtcblxuICAgICAgaWYgKGZvY3VzZWQgJiYgIWVsZW1lbnRDb250YWlucyhvcHRzLnJlZiwgZS5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICBmb2N1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGZvY3VzIHx8IGhvdmVyRm9jdXMgJiYgIWhvdmVyZWQpIHtcbiAgICAgICAgICBwb3BvdmVyc19oaWRlUG9wb3ZlcihvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyRGF5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBDYWxlbmRhckRheXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDYWxlbmRhckRheScsXG4gIG1peGluczogW21peGluc19jaGlsZE1peGluLCBtaXhpbnNfc2FmZVNjb3BlZFNsb3RNaXhpbl0sXG5cbiAgcmVuZGVyKGgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gQmFja2dyb3VuZHMgbGF5ZXJcbiAgICBjb25zdCBiYWNrZ3JvdW5kc0xheWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmhhc0JhY2tncm91bmRzICYmIGgoJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6ICd2Yy1oaWdobGlnaHRzIHZjLWRheS1sYXllcidcbiAgICAgIH0sIF90aGlzLmJhY2tncm91bmRzLm1hcChmdW5jdGlvbiAoe1xuICAgICAgICBrZXksXG4gICAgICAgIHdyYXBwZXJDbGFzcyxcbiAgICAgICAgY2xhc3M6IGJnQ2xhc3MsXG4gICAgICAgIHN0eWxlXG4gICAgICB9KSB7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGNsYXNzOiB3cmFwcGVyQ2xhc3NcbiAgICAgICAgfSwgW2goJ2RpdicsIHtcbiAgICAgICAgICBjbGFzczogYmdDbGFzcyxcbiAgICAgICAgICBzdHlsZVxuICAgICAgICB9KV0pO1xuICAgICAgfSkpO1xuICAgIH07IC8vIENvbnRlbnQgbGF5ZXJcblxuXG4gICAgY29uc3QgY29udGVudExheWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnNhZmVTY29wZWRTbG90KCdkYXktY29udGVudCcsIHtcbiAgICAgICAgZGF5OiBfdGhpcy5kYXksXG4gICAgICAgIGF0dHJpYnV0ZXM6IF90aGlzLmRheS5hdHRyaWJ1dGVzLFxuICAgICAgICBhdHRyaWJ1dGVzTWFwOiBfdGhpcy5kYXkuYXR0cmlidXRlc01hcCxcbiAgICAgICAgZGF5UHJvcHM6IF90aGlzLmRheUNvbnRlbnRQcm9wcyxcbiAgICAgICAgZGF5RXZlbnRzOiBfdGhpcy5kYXlDb250ZW50RXZlbnRzXG4gICAgICB9KSB8fCBoKCdzcGFuJywge1xuICAgICAgICBjbGFzczogX3RoaXMuZGF5Q29udGVudENsYXNzLFxuICAgICAgICBzdHlsZTogX3RoaXMuZGF5Q29udGVudFN0eWxlLFxuICAgICAgICBhdHRyczogeyAuLi5fdGhpcy5kYXlDb250ZW50UHJvcHNcbiAgICAgICAgfSxcbiAgICAgICAgb246IF90aGlzLmRheUNvbnRlbnRFdmVudHMsXG4gICAgICAgIHJlZjogJ2NvbnRlbnQnXG4gICAgICB9LCBbX3RoaXMuZGF5LmxhYmVsXSk7XG4gICAgfTsgLy8gRG90cyBsYXllclxuXG5cbiAgICBjb25zdCBkb3RzTGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaGFzRG90cyAmJiBoKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAndmMtZGF5LWxheWVyIHZjLWRheS1ib3gtY2VudGVyLWJvdHRvbSdcbiAgICAgIH0sIFtoKCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAndmMtZG90cydcbiAgICAgIH0sIF90aGlzLmRvdHMubWFwKGZ1bmN0aW9uICh7XG4gICAgICAgIGtleSxcbiAgICAgICAgY2xhc3M6IGJnQ2xhc3MsXG4gICAgICAgIHN0eWxlXG4gICAgICB9KSB7XG4gICAgICAgIHJldHVybiBoKCdzcGFuJywge1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBjbGFzczogYmdDbGFzcyxcbiAgICAgICAgICBzdHlsZVxuICAgICAgICB9KTtcbiAgICAgIH0pKV0pO1xuICAgIH07IC8vIEJhcnMgbGF5ZXJcblxuXG4gICAgY29uc3QgYmFyc0xheWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmhhc0JhcnMgJiYgaCgnZGl2Jywge1xuICAgICAgICBjbGFzczogJ3ZjLWRheS1sYXllciB2Yy1kYXktYm94LWNlbnRlci1ib3R0b20nXG4gICAgICB9LCBbaCgnZGl2Jywge1xuICAgICAgICBjbGFzczogJ3ZjLWJhcnMnXG4gICAgICB9LCBfdGhpcy5iYXJzLm1hcChmdW5jdGlvbiAoe1xuICAgICAgICBrZXksXG4gICAgICAgIGNsYXNzOiBiZ0NsYXNzLFxuICAgICAgICBzdHlsZVxuICAgICAgfSkge1xuICAgICAgICByZXR1cm4gaCgnc3BhbicsIHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgY2xhc3M6IGJnQ2xhc3MsXG4gICAgICAgICAgc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9KSldKTtcbiAgICB9OyAvLyBSb290IGxheWVyXG5cblxuICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICBjbGFzczogWyd2Yy1kYXknLCAuLi50aGlzLmRheS5jbGFzc2VzLCB7XG4gICAgICAgICd2Yy1kYXktYm94LWNlbnRlci1jZW50ZXInOiAhdGhpcy4kc2NvcGVkU2xvdHNbJ2RheS1jb250ZW50J11cbiAgICAgIH0sIHtcbiAgICAgICAgJ2lzLW5vdC1pbi1tb250aCc6ICF0aGlzLmluTW9udGhcbiAgICAgIH1dXG4gICAgfSwgW2JhY2tncm91bmRzTGF5ZXIoKSwgY29udGVudExheWVyKCksIGRvdHNMYXllcigpLCBiYXJzTGF5ZXIoKV0pO1xuICB9LFxuXG4gIGluamVjdDogWydzaGFyZWRTdGF0ZSddLFxuICBwcm9wczoge1xuICAgIGRheToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2x5cGhzOiB7fSxcbiAgICAgIGRheUNvbnRlbnRFdmVudHM6IHt9XG4gICAgfTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGxhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF5LmxhYmVsO1xuICAgIH0sXG5cbiAgICBzdGFydFRpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXkucmFuZ2Uuc3RhcnQuZ2V0VGltZSgpO1xuICAgIH0sXG5cbiAgICBlbmRUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF5LnJhbmdlLmVuZC5nZXRUaW1lKCk7XG4gICAgfSxcblxuICAgIGluTW9udGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXkuaW5Nb250aDtcbiAgICB9LFxuXG4gICAgaXNEaXNhYmxlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRheS5pc0Rpc2FibGVkO1xuICAgIH0sXG5cbiAgICBiYWNrZ3JvdW5kcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdseXBocy5iYWNrZ3JvdW5kcztcbiAgICB9LFxuXG4gICAgaGFzQmFja2dyb3VuZHMoKSB7XG4gICAgICByZXR1cm4gISFhcnJheUhhc0l0ZW1zKHRoaXMuYmFja2dyb3VuZHMpO1xuICAgIH0sXG5cbiAgICBjb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2x5cGhzLmNvbnRlbnQ7XG4gICAgfSxcblxuICAgIGRvdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nbHlwaHMuZG90cztcbiAgICB9LFxuXG4gICAgaGFzRG90cygpIHtcbiAgICAgIHJldHVybiAhIWFycmF5SGFzSXRlbXModGhpcy5kb3RzKTtcbiAgICB9LFxuXG4gICAgYmFycygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdseXBocy5iYXJzO1xuICAgIH0sXG5cbiAgICBoYXNCYXJzKCkge1xuICAgICAgcmV0dXJuICEhYXJyYXlIYXNJdGVtcyh0aGlzLmJhcnMpO1xuICAgIH0sXG5cbiAgICBwb3BvdmVycygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdseXBocy5wb3BvdmVycztcbiAgICB9LFxuXG4gICAgaGFzUG9wb3ZlcnMoKSB7XG4gICAgICByZXR1cm4gISFhcnJheUhhc0l0ZW1zKHRoaXMucG9wb3ZlcnMpO1xuICAgIH0sXG5cbiAgICBkYXlDb250ZW50Q2xhc3MoKSB7XG4gICAgICByZXR1cm4gWyd2Yy1kYXktY29udGVudCB2Yy1mb2N1c2FibGUnLCB7XG4gICAgICAgICdpcy1kaXNhYmxlZCc6IHRoaXMuaXNEaXNhYmxlZFxuICAgICAgfSwgZ2V0X2RlZmF1bHQoKShsYXN0X2RlZmF1bHQoKSh0aGlzLmNvbnRlbnQpLCAnY2xhc3MnKSB8fCAnJ107XG4gICAgfSxcblxuICAgIGRheUNvbnRlbnRTdHlsZSgpIHtcbiAgICAgIHJldHVybiBnZXRfZGVmYXVsdCgpKGxhc3RfZGVmYXVsdCgpKHRoaXMuY29udGVudCksICdzdHlsZScpO1xuICAgIH0sXG5cbiAgICBkYXlDb250ZW50UHJvcHMoKSB7XG4gICAgICBsZXQgdGFiaW5kZXg7XG5cbiAgICAgIGlmICh0aGlzLmRheS5pc0ZvY3VzYWJsZSkge1xuICAgICAgICB0YWJpbmRleCA9ICcwJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXkuaW5Nb250aCkge1xuICAgICAgICB0YWJpbmRleCA9ICctMSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhYmluZGV4LFxuICAgICAgICAnYXJpYS1sYWJlbCc6IHRoaXMuZGF5LmFyaWFMYWJlbCxcbiAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiB0aGlzLmRheS5pc0Rpc2FibGVkID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgcm9sZTogJ2J1dHRvbidcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGRheUV2ZW50KCkge1xuICAgICAgcmV0dXJuIHsgLi4udGhpcy5kYXksXG4gICAgICAgIGVsOiB0aGlzLiRyZWZzLmNvbnRlbnQsXG4gICAgICAgIHBvcG92ZXJzOiB0aGlzLnBvcG92ZXJzXG4gICAgICB9O1xuICAgIH1cblxuICB9LFxuICB3YXRjaDoge1xuICAgIHRoZW1lKCkge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfSxcblxuICAgIHBvcG92ZXJzKCkge1xuICAgICAgdGhpcy5yZWZyZXNoUG9wb3ZlcnMoKTtcbiAgICB9XG5cbiAgfSxcblxuICBtb3VudGVkKCkge1xuICAgIHRoaXMucmVmcmVzaFBvcG92ZXJzKCk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGdldERheUV2ZW50KG9yaWdFdmVudCkge1xuICAgICAgcmV0dXJuIHsgLi4udGhpcy5kYXlFdmVudCxcbiAgICAgICAgZXZlbnQ6IG9yaWdFdmVudFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgY2xpY2soZSkge1xuICAgICAgdGhpcy4kZW1pdCgnZGF5Y2xpY2snLCB0aGlzLmdldERheUV2ZW50KGUpKTtcbiAgICB9LFxuXG4gICAgbW91c2VlbnRlcihlKSB7XG4gICAgICB0aGlzLiRlbWl0KCdkYXltb3VzZWVudGVyJywgdGhpcy5nZXREYXlFdmVudChlKSk7XG4gICAgfSxcblxuICAgIG1vdXNlbGVhdmUoZSkge1xuICAgICAgdGhpcy4kZW1pdCgnZGF5bW91c2VsZWF2ZScsIHRoaXMuZ2V0RGF5RXZlbnQoZSkpO1xuICAgIH0sXG5cbiAgICBmb2N1c2luKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2RheWZvY3VzaW4nLCB0aGlzLmdldERheUV2ZW50KGUpKTtcbiAgICB9LFxuXG4gICAgZm9jdXNvdXQoZSkge1xuICAgICAgdGhpcy4kZW1pdCgnZGF5Zm9jdXNvdXQnLCB0aGlzLmdldERheUV2ZW50KGUpKTtcbiAgICB9LFxuXG4gICAga2V5ZG93bihlKSB7XG4gICAgICB0aGlzLiRlbWl0KCdkYXlrZXlkb3duJywgdGhpcy5nZXREYXlFdmVudChlKSk7XG4gICAgfSxcblxuICAgIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmRheS5yZWZyZXNoKSByZXR1cm47XG4gICAgICB0aGlzLmRheS5yZWZyZXNoID0gZmFsc2U7XG4gICAgICBjb25zdCBnbHlwaHMgPSB7XG4gICAgICAgIGJhY2tncm91bmRzOiBbXSxcbiAgICAgICAgZG90czogW10sXG4gICAgICAgIGJhcnM6IFtdLFxuICAgICAgICBwb3BvdmVyczogW10sXG4gICAgICAgIGNvbnRlbnQ6IFtdXG4gICAgICB9OyAvLyBVc2UgJHNldCB0byB0cmlnZ2VyIHJlYWN0aXZpdHkgaW4gcG9wb3ZlcnMsIGlmIG5lZWRlZFxuXG4gICAgICB0aGlzLiRzZXQodGhpcy5kYXksICdhdHRyaWJ1dGVzJywgT2JqZWN0LnZhbHVlcyh0aGlzLmRheS5hdHRyaWJ1dGVzTWFwIHx8IHt9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuZGF5LmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAvLyBBZGQgZ2x5cGhzIGZvciBlYWNoIGF0dHJpYnV0ZVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdGFyZ2V0RGF0ZVxuICAgICAgICB9ID0gYXR0cjtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlzRGF0ZSxcbiAgICAgICAgICBpc0NvbXBsZXgsXG4gICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgIGVuZFRpbWVcbiAgICAgICAgfSA9IHRhcmdldERhdGU7XG4gICAgICAgIGNvbnN0IG9uU3RhcnQgPSBfdGhpczIuc3RhcnRUaW1lIDw9IHN0YXJ0VGltZTtcbiAgICAgICAgY29uc3Qgb25FbmQgPSBfdGhpczIuZW5kVGltZSA+PSBlbmRUaW1lO1xuICAgICAgICBjb25zdCBvblN0YXJ0QW5kRW5kID0gb25TdGFydCAmJiBvbkVuZDtcbiAgICAgICAgY29uc3Qgb25TdGFydE9yRW5kID0gb25TdGFydCB8fCBvbkVuZDtcbiAgICAgICAgY29uc3QgZGF0ZUluZm8gPSB7XG4gICAgICAgICAgaXNEYXRlLFxuICAgICAgICAgIGlzQ29tcGxleCxcbiAgICAgICAgICBvblN0YXJ0LFxuICAgICAgICAgIG9uRW5kLFxuICAgICAgICAgIG9uU3RhcnRBbmRFbmQsXG4gICAgICAgICAgb25TdGFydE9yRW5kXG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMyLnByb2Nlc3NIaWdobGlnaHQoYXR0ciwgZGF0ZUluZm8sIGdseXBocyk7XG5cbiAgICAgICAgX3RoaXMyLnByb2Nlc3NOb25IaWdobGlnaHQoYXR0ciwgJ2NvbnRlbnQnLCBkYXRlSW5mbywgZ2x5cGhzLmNvbnRlbnQpO1xuXG4gICAgICAgIF90aGlzMi5wcm9jZXNzTm9uSGlnaGxpZ2h0KGF0dHIsICdkb3QnLCBkYXRlSW5mbywgZ2x5cGhzLmRvdHMpO1xuXG4gICAgICAgIF90aGlzMi5wcm9jZXNzTm9uSGlnaGxpZ2h0KGF0dHIsICdiYXInLCBkYXRlSW5mbywgZ2x5cGhzLmJhcnMpO1xuXG4gICAgICAgIF90aGlzMi5wcm9jZXNzUG9wb3ZlcihhdHRyLCBnbHlwaHMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmdseXBocyA9IGdseXBocztcbiAgICB9LFxuXG4gICAgcHJvY2Vzc0hpZ2hsaWdodCh7XG4gICAgICBrZXksXG4gICAgICBoaWdobGlnaHRcbiAgICB9LCB7XG4gICAgICBpc0RhdGUsXG4gICAgICBpc0NvbXBsZXgsXG4gICAgICBvblN0YXJ0LFxuICAgICAgb25FbmQsXG4gICAgICBvblN0YXJ0QW5kRW5kXG4gICAgfSwge1xuICAgICAgYmFja2dyb3VuZHMsXG4gICAgICBjb250ZW50XG4gICAgfSkge1xuICAgICAgaWYgKCFoaWdobGlnaHQpIHJldHVybjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYmFzZSxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZFxuICAgICAgfSA9IGhpZ2hsaWdodDtcblxuICAgICAgaWYgKGlzRGF0ZSB8fCBpc0NvbXBsZXgpIHtcbiAgICAgICAgYmFja2dyb3VuZHMucHVzaCh7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHdyYXBwZXJDbGFzczogJ3ZjLWRheS1sYXllciB2Yy1kYXktYm94LWNlbnRlci1jZW50ZXInLFxuICAgICAgICAgIGNsYXNzOiBbJ3ZjLWhpZ2hsaWdodCcsIHN0YXJ0LmNsYXNzXSxcbiAgICAgICAgICBzdHlsZTogc3RhcnQuc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAga2V5OiBgJHtrZXl9LWNvbnRlbnRgLFxuICAgICAgICAgIGNsYXNzOiBzdGFydC5jb250ZW50Q2xhc3MsXG4gICAgICAgICAgc3R5bGU6IHN0YXJ0LmNvbnRlbnRTdHlsZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob25TdGFydEFuZEVuZCkge1xuICAgICAgICBiYWNrZ3JvdW5kcy5wdXNoKHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgd3JhcHBlckNsYXNzOiAndmMtZGF5LWxheWVyIHZjLWRheS1ib3gtY2VudGVyLWNlbnRlcicsXG4gICAgICAgICAgY2xhc3M6IFsndmMtaGlnaGxpZ2h0Jywgc3RhcnQuY2xhc3NdLFxuICAgICAgICAgIHN0eWxlOiBzdGFydC5zdHlsZVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICBrZXk6IGAke2tleX0tY29udGVudGAsXG4gICAgICAgICAgY2xhc3M6IHN0YXJ0LmNvbnRlbnRDbGFzcyxcbiAgICAgICAgICBzdHlsZTogc3RhcnQuY29udGVudFN0eWxlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvblN0YXJ0KSB7XG4gICAgICAgIGJhY2tncm91bmRzLnB1c2goe1xuICAgICAgICAgIGtleTogYCR7a2V5fS1iYXNlYCxcbiAgICAgICAgICB3cmFwcGVyQ2xhc3M6ICd2Yy1kYXktbGF5ZXIgdmMtZGF5LWJveC1yaWdodC1jZW50ZXInLFxuICAgICAgICAgIGNsYXNzOiBbJ3ZjLWhpZ2hsaWdodCB2Yy1oaWdobGlnaHQtYmFzZS1zdGFydCcsIGJhc2UuY2xhc3NdLFxuICAgICAgICAgIHN0eWxlOiBiYXNlLnN0eWxlXG4gICAgICAgIH0pO1xuICAgICAgICBiYWNrZ3JvdW5kcy5wdXNoKHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgd3JhcHBlckNsYXNzOiAndmMtZGF5LWxheWVyIHZjLWRheS1ib3gtY2VudGVyLWNlbnRlcicsXG4gICAgICAgICAgY2xhc3M6IFsndmMtaGlnaGxpZ2h0Jywgc3RhcnQuY2xhc3NdLFxuICAgICAgICAgIHN0eWxlOiBzdGFydC5zdHlsZVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICBrZXk6IGAke2tleX0tY29udGVudGAsXG4gICAgICAgICAgY2xhc3M6IHN0YXJ0LmNvbnRlbnRDbGFzcyxcbiAgICAgICAgICBzdHlsZTogc3RhcnQuY29udGVudFN0eWxlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvbkVuZCkge1xuICAgICAgICBiYWNrZ3JvdW5kcy5wdXNoKHtcbiAgICAgICAgICBrZXk6IGAke2tleX0tYmFzZWAsXG4gICAgICAgICAgd3JhcHBlckNsYXNzOiAndmMtZGF5LWxheWVyIHZjLWRheS1ib3gtbGVmdC1jZW50ZXInLFxuICAgICAgICAgIGNsYXNzOiBbJ3ZjLWhpZ2hsaWdodCB2Yy1oaWdobGlnaHQtYmFzZS1lbmQnLCBiYXNlLmNsYXNzXSxcbiAgICAgICAgICBzdHlsZTogYmFzZS5zdHlsZVxuICAgICAgICB9KTtcbiAgICAgICAgYmFja2dyb3VuZHMucHVzaCh7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHdyYXBwZXJDbGFzczogJ3ZjLWRheS1sYXllciB2Yy1kYXktYm94LWNlbnRlci1jZW50ZXInLFxuICAgICAgICAgIGNsYXNzOiBbJ3ZjLWhpZ2hsaWdodCcsIGVuZC5jbGFzc10sXG4gICAgICAgICAgc3R5bGU6IGVuZC5zdHlsZVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICBrZXk6IGAke2tleX0tY29udGVudGAsXG4gICAgICAgICAgY2xhc3M6IGVuZC5jb250ZW50Q2xhc3MsXG4gICAgICAgICAgc3R5bGU6IGVuZC5jb250ZW50U3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWNrZ3JvdW5kcy5wdXNoKHtcbiAgICAgICAgICBrZXk6IGAke2tleX0tbWlkZGxlYCxcbiAgICAgICAgICB3cmFwcGVyQ2xhc3M6ICd2Yy1kYXktbGF5ZXIgdmMtZGF5LWJveC1jZW50ZXItY2VudGVyJyxcbiAgICAgICAgICBjbGFzczogWyd2Yy1oaWdobGlnaHQgdmMtaGlnaGxpZ2h0LWJhc2UtbWlkZGxlJywgYmFzZS5jbGFzc10sXG4gICAgICAgICAgc3R5bGU6IGJhc2Uuc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAga2V5OiBgJHtrZXl9LWNvbnRlbnRgLFxuICAgICAgICAgIGNsYXNzOiBiYXNlLmNvbnRlbnRDbGFzcyxcbiAgICAgICAgICBzdHlsZTogYmFzZS5jb250ZW50U3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHByb2Nlc3NOb25IaWdobGlnaHQoYXR0ciwgaXRlbUtleSwge1xuICAgICAgaXNEYXRlLFxuICAgICAgb25TdGFydCxcbiAgICAgIG9uRW5kXG4gICAgfSwgbGlzdCkge1xuICAgICAgaWYgKCFhdHRyW2l0ZW1LZXldKSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleVxuICAgICAgfSA9IGF0dHI7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBgdmMtJHtpdGVtS2V5fWA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJhc2UsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmRcbiAgICAgIH0gPSBhdHRyW2l0ZW1LZXldO1xuXG4gICAgICBpZiAoaXNEYXRlIHx8IG9uU3RhcnQpIHtcbiAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgY2xhc3M6IFtjbGFzc05hbWUsIHN0YXJ0LmNsYXNzXSxcbiAgICAgICAgICBzdHlsZTogc3RhcnQuc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG9uRW5kKSB7XG4gICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGNsYXNzOiBbY2xhc3NOYW1lLCBlbmQuY2xhc3NdLFxuICAgICAgICAgIHN0eWxlOiBlbmQuc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LnB1c2goe1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBjbGFzczogW2NsYXNzTmFtZSwgYmFzZS5jbGFzc10sXG4gICAgICAgICAgc3R5bGU6IGJhc2Uuc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHByb2Nlc3NQb3BvdmVyKGF0dHJpYnV0ZSwge1xuICAgICAgcG9wb3ZlcnNcbiAgICB9KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgY3VzdG9tRGF0YSxcbiAgICAgICAgcG9wb3ZlclxuICAgICAgfSA9IGF0dHJpYnV0ZTtcbiAgICAgIGlmICghcG9wb3ZlcikgcmV0dXJuO1xuICAgICAgY29uc3QgcmVzb2x2ZWRQb3BvdmVyID0gZGVmYXVsdHNfZGVmYXVsdCgpKHtcbiAgICAgICAga2V5LFxuICAgICAgICBjdXN0b21EYXRhLFxuICAgICAgICBhdHRyaWJ1dGVcbiAgICAgIH0sIHsgLi4ucG9wb3ZlclxuICAgICAgfSwge1xuICAgICAgICB2aXNpYmlsaXR5OiBwb3BvdmVyLmxhYmVsID8gJ2hvdmVyJyA6ICdjbGljaycsXG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICAgIGlzSW50ZXJhY3RpdmU6ICFwb3BvdmVyLmxhYmVsXG4gICAgICB9KTtcbiAgICAgIHBvcG92ZXJzLnNwbGljZSgwLCAwLCByZXNvbHZlZFBvcG92ZXIpO1xuICAgIH0sXG5cbiAgICByZWZyZXNoUG9wb3ZlcnMoKSB7XG4gICAgICBsZXQgcG9wb3ZlckV2ZW50cyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5wb3BvdmVycykge1xuICAgICAgICBjb25zdCB2aXNpYmlsaXRpZXMgPSBbJ2NsaWNrJywgJ2ZvY3VzJywgJ2hvdmVyJywgJ3Zpc2libGUnXTtcbiAgICAgICAgbGV0IHBsYWNlbWVudCA9ICcnO1xuICAgICAgICBsZXQgbW9kaWZpZXJzID0gbnVsbDtcbiAgICAgICAgbGV0IGlzSW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHZJZHggPSAtMTtcbiAgICAgICAgdGhpcy5wb3BvdmVycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgY29uc3Qgdk5ldyA9IHZpc2liaWxpdGllcy5pbmRleE9mKHAudmlzaWJpbGl0eSk7XG4gICAgICAgICAgdklkeCA9IHZOZXcgPiB2SWR4ID8gdk5ldyA6IHZJZHg7XG4gICAgICAgICAgcGxhY2VtZW50ID0gcGxhY2VtZW50IHx8IHAucGxhY2VtZW50O1xuICAgICAgICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBwLm1vZGlmaWVycztcbiAgICAgICAgICBpc0ludGVyYWN0aXZlID0gaXNJbnRlcmFjdGl2ZSB8fCBwLmlzSW50ZXJhY3RpdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBwb3BvdmVyRXZlbnRzID0gZ2V0UG9wb3ZlclRyaWdnZXJFdmVudHMoe1xuICAgICAgICAgIGlkOiB0aGlzLmRheVBvcG92ZXJJZCxcbiAgICAgICAgICBkYXRhOiB0aGlzLmRheSxcbiAgICAgICAgICB2aXNpYmlsaXR5OiB2SWR4ID49IDAgPyB2aXNpYmlsaXRpZXNbdklkeF0gOiAnaGlkZGVuJyxcbiAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCB8fCAnYm90dG9tJyxcbiAgICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgICAgaXNJbnRlcmFjdGl2ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXlDb250ZW50RXZlbnRzID0gbWVyZ2VFdmVudHMoe1xuICAgICAgICBjbGljazogdGhpcy5jbGljayxcbiAgICAgICAgbW91c2VlbnRlcjogdGhpcy5tb3VzZWVudGVyLFxuICAgICAgICBtb3VzZWxlYXZlOiB0aGlzLm1vdXNlbGVhdmUsXG4gICAgICAgIGZvY3VzaW46IHRoaXMuZm9jdXNpbixcbiAgICAgICAgZm9jdXNvdXQ6IHRoaXMuZm9jdXNvdXQsXG4gICAgICAgIGtleWRvd246IHRoaXMua2V5ZG93blxuICAgICAgfSwgcG9wb3ZlckV2ZW50cyk7XG4gICAgICB1cGRhdGVQb3BvdmVyKHtcbiAgICAgICAgaWQ6IHRoaXMuZGF5UG9wb3ZlcklkLFxuICAgICAgICBkYXRhOiB0aGlzLmRheVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9DYWxlbmRhckRheS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19DYWxlbmRhckRheXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChDYWxlbmRhckRheXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyRGF5LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWExMTEwYjQwJmxhbmc9cG9zdGNzcyZzY29wZWQ9dHJ1ZSZcbnZhciBDYWxlbmRhckRheXZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfYTExMTBiNDBfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzOGVhXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyRGF5LnZ1ZVxudmFyIENhbGVuZGFyRGF5X3JlbmRlciwgQ2FsZW5kYXJEYXlfc3RhdGljUmVuZGVyRm5zXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgQ2FsZW5kYXJEYXlfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0NhbGVuZGFyRGF5dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBDYWxlbmRhckRheV9yZW5kZXIsXG4gIENhbGVuZGFyRGF5X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiYTExMTBiNDBcIixcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgQ2FsZW5kYXJEYXkgPSAoQ2FsZW5kYXJEYXlfY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyUGFuZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgQ2FsZW5kYXJQYW5ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0NhbGVuZGFyUGFuZScsXG4gIG1peGluczogW21peGluc19jaGlsZE1peGluLCBtaXhpbnNfc2FmZVNjb3BlZFNsb3RNaXhpbl0sXG5cbiAgcmVuZGVyKGgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gSGVhZGVyXG4gICAgY29uc3QgaGVhZGVyID0gdGhpcy5zYWZlU2NvcGVkU2xvdCgnaGVhZGVyJywgdGhpcy5wYWdlKSB8fCBoKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ3ZjLWhlYWRlcidcbiAgICB9LCBbLy8gSGVhZGVyIHRpdGxlXG4gICAgaCgnZGl2Jywge1xuICAgICAgY2xhc3M6IGB2Yy10aXRsZS1sYXlvdXQgYWxpZ24tJHt0aGlzLnRpdGxlUG9zaXRpb259YFxuICAgIH0sIFtoKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ3ZjLXRpdGxlLXdyYXBwZXInXG4gICAgfSwgWy8vIFRpdGxlIGNvbnRlbnRcbiAgICBoKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ3ZjLXRpdGxlJyxcbiAgICAgIG9uOiB0aGlzLm5hdlBvcG92ZXJFdmVudHNcbiAgICB9LCBbdGhpcy5zYWZlU2NvcGVkU2xvdCgnaGVhZGVyLXRpdGxlJywgdGhpcy5wYWdlLCB0aGlzLnBhZ2UudGl0bGUpXSksIC8vIE5hdmlnYXRpb24gcG9wb3ZlclxuICAgIGgoUG9wb3Zlciwge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaWQ6IHRoaXMubmF2UG9wb3ZlcklkLFxuICAgICAgICBjb250ZW50Q2xhc3M6ICd2Yy1uYXYtcG9wb3Zlci1jb250YWluZXInXG4gICAgICB9XG4gICAgfSwgWy8vIE5hdmlnYXRpb24gcGFuZVxuICAgIGgoQ2FsZW5kYXJOYXYsIHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLnBhZ2UsXG4gICAgICAgIHZhbGlkYXRvcjogdGhpcy5jYW5Nb3ZlXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMubW92ZSgkZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2NvcGVkU2xvdHM6IHRoaXMuJHNjb3BlZFNsb3RzXG4gICAgfSldKV0pXSldKTsgLy8gV2Vla3NcblxuICAgIGNvbnN0IHdlZWtzID0gaChHcmlkLCB7XG4gICAgICBjbGFzczogJ3ZjLXdlZWtzJyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHJvd3M6IDcsXG4gICAgICAgIGNvbHVtbnM6IDcsXG4gICAgICAgIGNvbHVtbldpZHRoOiAnMWZyJyxcbiAgICAgICAgZGlzYWJsZUZvY3VzOiB0cnVlXG4gICAgICB9XG4gICAgfSwgWy4uLnRoaXMud2Vla2RheUxhYmVscy5tYXAoZnVuY3Rpb24gKHdsLCBpKSB7XG4gICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICBrZXk6IGkgKyAxLFxuICAgICAgICBjbGFzczogJ3ZjLXdlZWtkYXknXG4gICAgICB9LCBbd2xdKTtcbiAgICB9KSwgLi4udGhpcy5wYWdlLmRheXMubWFwKGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgIHJldHVybiBoKENhbGVuZGFyRGF5LCB7XG4gICAgICAgIGF0dHJzOiB7IC4uLl90aGlzLiRhdHRycyxcbiAgICAgICAgICBkYXlcbiAgICAgICAgfSxcbiAgICAgICAgb246IHsgLi4uX3RoaXMuJGxpc3RlbmVyc1xuICAgICAgICB9LFxuICAgICAgICBzY29wZWRTbG90czogX3RoaXMuJHNjb3BlZFNsb3RzLFxuICAgICAgICBrZXk6IGRheS5pZCxcbiAgICAgICAgcmVmOiAnZGF5cycsXG4gICAgICAgIHJlZkluRm9yOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KV0pO1xuICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ3ZjLXBhbmUnLFxuICAgICAgcmVmOiAncGFuZSdcbiAgICB9LCBbaGVhZGVyLCB3ZWVrc10pO1xuICB9LFxuXG4gIHByb3BzOiB7XG4gICAgcGFnZTogT2JqZWN0LFxuICAgIHRpdGxlUG9zaXRpb246IFN0cmluZyxcbiAgICBuYXZWaXNpYmlsaXR5OiBTdHJpbmcsXG4gICAgY2FuTW92ZToge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYXZQb3BvdmVySWQ6IGNyZWF0ZUd1aWQoKVxuICAgIH07XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBuYXZWaXNpYmlsaXR5XygpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BPckRlZmF1bHQoJ25hdlZpc2liaWxpdHknLCAnbmF2VmlzaWJpbGl0eScpO1xuICAgIH0sXG5cbiAgICBuYXZQbGFjZW1lbnQoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMudGl0bGVQb3NpdGlvbikge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICByZXR1cm4gJ2JvdHRvbS1zdGFydCc7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHJldHVybiAnYm90dG9tLWVuZCc7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG5hdlBvcG92ZXJFdmVudHMoKSB7XG4gICAgICByZXR1cm4gZ2V0UG9wb3ZlclRyaWdnZXJFdmVudHMoe1xuICAgICAgICBpZDogdGhpcy5uYXZQb3BvdmVySWQsXG4gICAgICAgIHZpc2liaWxpdHk6IHRoaXMubmF2VmlzaWJpbGl0eV8sXG4gICAgICAgIHBsYWNlbWVudDogdGhpcy5uYXZQbGFjZW1lbnQsXG4gICAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBbJ2JvdHRvbSddXG4gICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgaXNJbnRlcmFjdGl2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHdlZWtkYXlMYWJlbHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMubG9jYWxlLmdldFdlZWtkYXlEYXRlcygpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmZvcm1hdChkLCBfdGhpczIubWFza3Mud2Vla2RheXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBtb3ZlKHBhZ2UpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpwYWdlJywgcGFnZSk7XG4gICAgfSxcblxuICAgIHJlZnJlc2goKSB7XG4gICAgICB0aGlzLiRyZWZzLmRheXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5yZWZyZXNoKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyUGFuZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19DYWxlbmRhclBhbmV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQ2FsZW5kYXJQYW5ldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQ2FsZW5kYXJQYW5lLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTM0OTFiMjkwJmxhbmc9cG9zdGNzcyZzY29wZWQ9dHJ1ZSZcbnZhciBDYWxlbmRhclBhbmV2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzM0OTFiMjkwX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYmFiNFwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyUGFuZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MSZsYW5nPWNzcyZcbnZhciBDYWxlbmRhclBhbmV2dWVfdHlwZV9zdHlsZV9pbmRleF8xX2xhbmdfY3NzXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ODg5XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyUGFuZS52dWVcbnZhciBDYWxlbmRhclBhbmVfcmVuZGVyLCBDYWxlbmRhclBhbmVfc3RhdGljUmVuZGVyRm5zXG5cblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBDYWxlbmRhclBhbmVfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0NhbGVuZGFyUGFuZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQ2FsZW5kYXJQYW5lX3JlbmRlcixcbiAgQ2FsZW5kYXJQYW5lX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMzQ5MWIyOTBcIixcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgQ2FsZW5kYXJQYW5lID0gKENhbGVuZGFyUGFuZV9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQ3VzdG9tVHJhbnNpdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBDdXN0b21UcmFuc2l0aW9udnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0N1c3RvbVRyYW5zaXRpb24nLFxuXG4gIHJlbmRlcihoKSB7XG4gICAgcmV0dXJuIGgoJ3RyYW5zaXRpb24nLCB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBhcHBlYXI6IHRoaXMuYXBwZWFyXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgYmVmb3JlRW50ZXI6IHRoaXMuYmVmb3JlRW50ZXIsXG4gICAgICAgIGFmdGVyRW50ZXI6IHRoaXMuYWZ0ZXJFbnRlclxuICAgICAgfVxuICAgIH0sIFt0aGlzLiRzbG90cy5kZWZhdWx0XSk7XG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgYXBwZWFyOiBCb29sZWFuXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbmFtZV8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lIHx8ICdub25lJztcbiAgICB9XG5cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGJlZm9yZUVudGVyKGVsKSB7XG4gICAgICB0aGlzLiRlbWl0KCdiZWZvcmVFbnRlcicsIGVsKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2JlZm9yZVRyYW5zaXRpb24nLCBlbCk7XG4gICAgfSxcblxuICAgIGFmdGVyRW50ZXIoZWwpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2FmdGVyRW50ZXInLCBlbCk7XG4gICAgICB0aGlzLiRlbWl0KCdhZnRlclRyYW5zaXRpb24nLCBlbCk7XG4gICAgfVxuXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9DdXN0b21UcmFuc2l0aW9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX0N1c3RvbVRyYW5zaXRpb252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoQ3VzdG9tVHJhbnNpdGlvbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0N1c3RvbVRyYW5zaXRpb24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ODQ2NjU5MmUmbGFuZz1wb3N0Y3NzJnNjb3BlZD10cnVlJlxudmFyIEN1c3RvbVRyYW5zaXRpb252dWVfdHlwZV9zdHlsZV9pbmRleF8wX2lkXzg0NjY1OTJlX2xhbmdfcG9zdGNzc19zY29wZWRfdHJ1ZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTc2ZlwiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9DdXN0b21UcmFuc2l0aW9uLnZ1ZVxudmFyIEN1c3RvbVRyYW5zaXRpb25fcmVuZGVyLCBDdXN0b21UcmFuc2l0aW9uX3N0YXRpY1JlbmRlckZuc1xuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIEN1c3RvbVRyYW5zaXRpb25fY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0N1c3RvbVRyYW5zaXRpb252dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIEN1c3RvbVRyYW5zaXRpb25fcmVuZGVyLFxuICBDdXN0b21UcmFuc2l0aW9uX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiODQ2NjU5MmVcIixcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgQ3VzdG9tVHJhbnNpdGlvbiA9IChDdXN0b21UcmFuc2l0aW9uX2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL2F0dHJpYnV0ZVN0b3JlLmpzXG5cblxuXG5jbGFzcyBhdHRyaWJ1dGVTdG9yZV9BdHRyaWJ1dGVTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKHRoZW1lLCBsb2NhbGUsIGF0dHJzKSB7XG4gICAgdGhpcy50aGVtZSA9IHRoZW1lO1xuICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5yZWZyZXNoKGF0dHJzLCB0cnVlKTtcbiAgfVxuXG4gIHJlZnJlc2goYXR0cnMsIHJlc2V0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBsZXQgcGluQXR0ciA9IG51bGw7IC8vIEtlZXAgcmVjb3JkIG9mIGFkZGVkIGFuZCBkZWxldGVkIGF0dHJpYnV0ZXNcblxuICAgIGNvbnN0IGFkZHMgPSBbXTtcbiAgICBjb25zdCBkZWxldGVzID0gcmVzZXQgPyBuZXcgU2V0KCkgOiBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMubWFwKSk7XG5cbiAgICBpZiAoYXJyYXlIYXNJdGVtcyhhdHRycykpIHtcbiAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIsIGkpIHtcbiAgICAgICAgaWYgKCFhdHRyIHx8ICFhdHRyLmRhdGVzKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGtleSA9IGF0dHIua2V5ID8gYXR0ci5rZXkudG9TdHJpbmcoKSA6IGkudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgb3JkZXIgPSBhdHRyLm9yZGVyIHx8IDA7XG4gICAgICAgIGNvbnN0IGhhc2hjb2RlID0gaGVscGVyc19oYXNoKEpTT04uc3RyaW5naWZ5KGF0dHIpKTtcbiAgICAgICAgbGV0IGV4QXR0ciA9IF90aGlzLm1hcFtrZXldOyAvLyBJZiBqdXN0IHRyYWNraW5nIGRlbHRhIGNoYW5nZXMgYW5kIGF0dHJpYnV0ZSBoYXNoIGhhc24ndCBjaGFuZ2VkXG5cbiAgICAgICAgaWYgKCFyZXNldCAmJiBleEF0dHIgJiYgZXhBdHRyLmhhc2hjb2RlID09PSBoYXNoY29kZSkge1xuICAgICAgICAgIC8vIC4uLmRvbid0IG5lZWQgdG8gcmVwbGFjZSB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgZGVsZXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhdHRyaWJ1dGUgYW5kIGFkZCB0byB0aGUgbGlzdCBvZiBhZGRzXG4gICAgICAgICAgZXhBdHRyID0gbmV3IGF0dHJpYnV0ZV9BdHRyaWJ1dGUoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgb3JkZXIsXG4gICAgICAgICAgICBoYXNoY29kZSxcbiAgICAgICAgICAgIC4uLmF0dHJcbiAgICAgICAgICB9LCBfdGhpcy50aGVtZSwgX3RoaXMubG9jYWxlKTtcbiAgICAgICAgICBhZGRzLnB1c2goZXhBdHRyKTtcbiAgICAgICAgfSAvLyBLZWVwIHRyYWNrIG9mIGF0dHJpYnV0ZSB0byBwaW4gZm9yIGluaXRpYWwgcGFnZVxuXG5cbiAgICAgICAgaWYgKGV4QXR0ciAmJiBleEF0dHIucGluUGFnZSkge1xuICAgICAgICAgIHBpbkF0dHIgPSBleEF0dHI7XG4gICAgICAgIH0gLy8gQWRkIGF0dHJpYnV0ZSB0byBtYXAgYW5kIGxpc3RcblxuXG4gICAgICAgIG1hcFtrZXldID0gZXhBdHRyO1xuICAgICAgICBsaXN0LnB1c2goZXhBdHRyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgdGhpcy5waW5BdHRyID0gcGluQXR0cjtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcyxcbiAgICAgIGRlbGV0ZXM6IEFycmF5LmZyb20oZGVsZXRlcylcbiAgICB9O1xuICB9XG5cbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvc3R5bGVzL2Jhc2UuY3NzXG52YXIgYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzZWUyXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvQ2FsZW5kYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBDYWxlbmRhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdDYWxlbmRhcicsXG5cbiAgcmVuZGVyKGgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gUmVuZGVyZXIgZm9yIGNhbGVuZGFyIHBhbmVzXG4gICAgY29uc3QgcGFuZXMgPSB0aGlzLnBhZ2VzLm1hcChmdW5jdGlvbiAocGFnZSwgaSkge1xuICAgICAgcmV0dXJuIGgoQ2FsZW5kYXJQYW5lLCB7XG4gICAgICAgIGF0dHJzOiB7IC4uLl90aGlzLiRhdHRycyxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBfdGhpcy5zdG9yZVxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHRpdGxlUG9zaXRpb246IF90aGlzLnRpdGxlUG9zaXRpb25fLFxuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgbWluUGFnZTogX3RoaXMubWluUGFnZV8sXG4gICAgICAgICAgbWF4UGFnZTogX3RoaXMubWF4UGFnZV8sXG4gICAgICAgICAgY2FuTW92ZTogX3RoaXMuY2FuTW92ZVxuICAgICAgICB9LFxuICAgICAgICBvbjogeyAuLi5fdGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICAgICd1cGRhdGU6cGFnZSc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucmVmcmVzaFBhZ2VzKHtcbiAgICAgICAgICAgICAgcGFnZTogZSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IGkgKyAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRheWZvY3VzaW46IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXN0Rm9jdXNlZERheSA9IGU7XG5cbiAgICAgICAgICAgIF90aGlzLiRlbWl0KCdkYXlmb2N1c2luJywgZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXlmb2N1c291dDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmxhc3RGb2N1c2VkRGF5ID0gbnVsbDtcblxuICAgICAgICAgICAgX3RoaXMuJGVtaXQoJ2RheWZvY3Vzb3V0JywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzY29wZWRTbG90czogX3RoaXMuJHNjb3BlZFNsb3RzLFxuICAgICAgICBrZXk6IHBhZ2Uua2V5LFxuICAgICAgICByZWY6ICdwYWdlcycsXG4gICAgICAgIHJlZkluRm9yOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTsgLy8gUmVuZGVyZXIgZm9yIGNhbGVuZGFyIGFycm93c1xuXG4gICAgY29uc3QgZ2V0QXJyb3dCdXR0b24gPSBmdW5jdGlvbiAoaXNQcmV2KSB7XG4gICAgICBjb25zdCBjbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm1vdmUoaXNQcmV2ID8gLV90aGlzLnN0ZXBfIDogX3RoaXMuc3RlcF8pO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qga2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBvblNwYWNlT3JFbnRlcihlLCBjbGljayk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpc0Rpc2FibGVkID0gaXNQcmV2ID8gIV90aGlzLmNhbk1vdmVQcmV2IDogIV90aGlzLmNhbk1vdmVOZXh0O1xuICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6IFsndmMtYXJyb3cnLCB7XG4gICAgICAgICAgJ2lzLWRpc2FibGVkJzogaXNEaXNhYmxlZFxuICAgICAgICB9XSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICByb2xlOiAnYnV0dG9uJ1xuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGNsaWNrLFxuICAgICAgICAgIGtleWRvd25cbiAgICAgICAgfVxuICAgICAgfSwgWyhpc1ByZXYgPyBfdGhpcy5zYWZlU2NvcGVkU2xvdCgnaGVhZGVyLWxlZnQtYnV0dG9uJywge1xuICAgICAgICBjbGlja1xuICAgICAgfSkgOiBfdGhpcy5zYWZlU2NvcGVkU2xvdCgnaGVhZGVyLXJpZ2h0LWJ1dHRvbicsIHtcbiAgICAgICAgY2xpY2tcbiAgICAgIH0pKSB8fCBoKFN2Z0ljb24sIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBuYW1lOiBpc1ByZXYgPyAnbGVmdC1hcnJvdycgOiAncmlnaHQtYXJyb3cnXG4gICAgICAgIH1cbiAgICAgIH0pXSk7XG4gICAgfTsgLy8gRGF5IHBvcG92ZXJcblxuXG4gICAgY29uc3QgZ2V0RGF5UG9wb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBoKFBvcG92ZXIsIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBpZDogX3RoaXMuc2hhcmVkU3RhdGUuZGF5UG9wb3ZlcklkLFxuICAgICAgICAgIGNvbnRlbnRDbGFzczogJ3ZjLWRheS1wb3BvdmVyLWNvbnRhaW5lcidcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVkU2xvdHM6IHtcbiAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoe1xuICAgICAgICAgICAgZGF0YTogZGF5LFxuICAgICAgICAgICAgdXBkYXRlTGF5b3V0LFxuICAgICAgICAgICAgaGlkZVxuICAgICAgICAgIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QudmFsdWVzKGRheS5hdHRyaWJ1dGVzKS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEucG9wb3ZlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbWFza3MgPSBfdGhpcy4kbG9jYWxlLm1hc2tzO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gX3RoaXMuZm9ybWF0RGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGRheVRpdGxlID0gZm9ybWF0KGRheS5kYXRlLCBtYXNrcy5kYXlQb3BvdmVyKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zYWZlU2NvcGVkU2xvdCgnZGF5LXBvcG92ZXInLCB7XG4gICAgICAgICAgICAgIGRheSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgbWFza3MsXG4gICAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgICAgZGF5VGl0bGUsXG4gICAgICAgICAgICAgIHVwZGF0ZUxheW91dCxcbiAgICAgICAgICAgICAgaGlkZVxuICAgICAgICAgICAgfSkgfHwgaCgnZGl2JywgWy8vIFNob3cgcG9wb3ZlciBoZWFkZXIgb25seSBpZiBmb3JtYXQgaXMgZGVmaW5lZFxuICAgICAgICAgICAgbWFza3MuZGF5UG9wb3ZlciAmJiBoKCdkaXYnLCB7XG4gICAgICAgICAgICAgIGNsYXNzOiBbJ3ZjLWRheS1wb3BvdmVyLWhlYWRlciddXG4gICAgICAgICAgICB9LCBbZGF5VGl0bGVdKSwgYXR0cmlidXRlcy5tYXAoZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gaChQb3BvdmVyUm93LCB7XG4gICAgICAgICAgICAgICAga2V5OiBhdHRyaWJ1dGUua2V5LFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07IC8vIFJlbmRlcmVyIGZvciBjYWxlbmRhciBjb250YWluZXJcblxuXG4gICAgY29uc3QgZ2V0Q29udGFpbmVyR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgJ2RhdGEtaGVscHRleHQnOiAnUHJlc3MgdGhlIGFycm93IGtleXMgdG8gbmF2aWdhdGUgYnkgZGF5LCBIb21lIGFuZCBFbmQgdG8gbmF2aWdhdGUgdG8gd2VlayBlbmRzLCBQYWdlVXAgYW5kIFBhZ2VEb3duIHRvIG5hdmlnYXRlIGJ5IG1vbnRoLCBBbHQrUGFnZVVwIGFuZCBBbHQrUGFnZURvd24gdG8gbmF2aWdhdGUgYnkgeWVhcidcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3M6IFsndmMtY29udGFpbmVyJywgYHZjLSR7X3RoaXMuJHRoZW1lLmNvbG9yfWAsIHtcbiAgICAgICAgICAndmMtaXMtZXhwYW5kZWQnOiBfdGhpcy5pc0V4cGFuZGVkLFxuICAgICAgICAgICd2Yy1pcy1kYXJrJzogX3RoaXMuJHRoZW1lLmlzRGFya1xuICAgICAgICB9XSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBrZXlkb3duOiBfdGhpcy5oYW5kbGVLZXlkb3duLFxuICAgICAgICAgIG1vdXNldXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiAnY29udGFpbmVyJ1xuICAgICAgfSwgW2goJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6IFsndmMtcGFuZS1jb250YWluZXInLCB7XG4gICAgICAgICAgJ2luLXRyYW5zaXRpb24nOiBfdGhpcy5pblRyYW5zaXRpb25cbiAgICAgICAgfV1cbiAgICAgIH0sIFtoKEN1c3RvbVRyYW5zaXRpb24sIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBuYW1lOiBfdGhpcy50cmFuc2l0aW9uTmFtZVxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIGJlZm9yZUVudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pblRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWZ0ZXJFbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW5UcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBbaChHcmlkLCB7XG4gICAgICAgIGNsYXNzOiAnZ3JpZCcsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgcm93czogX3RoaXMucm93cyxcbiAgICAgICAgICBjb2x1bW5zOiBfdGhpcy5jb2x1bW5zLFxuICAgICAgICAgIGNvbHVtbldpZHRoOiAnbWlubWF4KDI1NnB4LCAxZnIpJyxcbiAgICAgICAgICBkaXNhYmxlRm9jdXM6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IHsgLi4uX3RoaXMuJGF0dHJzXG4gICAgICAgIH0sXG4gICAgICAgIGtleTogYXJyYXlIYXNJdGVtcyhfdGhpcy5wYWdlcykgPyBfdGhpcy5wYWdlc1swXS5rZXkgOiAnJ1xuICAgICAgfSwgcGFuZXMpXSksIGgoJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6IFtgdmMtYXJyb3dzLWNvbnRhaW5lciB0aXRsZS0ke190aGlzLnRpdGxlUG9zaXRpb25ffWBdXG4gICAgICB9LCBbZ2V0QXJyb3dCdXR0b24odHJ1ZSksIGdldEFycm93QnV0dG9uKGZhbHNlKV0pLCBfdGhpcy4kc2NvcGVkU2xvdHMuZm9vdGVyICYmIF90aGlzLiRzY29wZWRTbG90cy5mb290ZXIoKV0pLCBnZXREYXlQb3BvdmVyKCldKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGdldENvbnRhaW5lckdyaWQoKTtcbiAgfSxcblxuICBtaXhpbnM6IFttaXhpbnNfcm9vdE1peGluLCBtaXhpbnNfc2FmZVNjb3BlZFNsb3RNaXhpbl0sXG5cbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hhcmVkU3RhdGU6IHRoaXMuc2hhcmVkU3RhdGVcbiAgICB9O1xuICB9LFxuXG4gIHByb3BzOiB7XG4gICAgcm93czoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMVxuICAgIH0sXG4gICAgY29sdW1uczoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMVxuICAgIH0sXG4gICAgc3RlcDogTnVtYmVyLFxuICAgIHRpdGxlUG9zaXRpb246IFN0cmluZyxcbiAgICBpc0V4cGFuZGVkOiBCb29sZWFuLFxuICAgIGZyb21EYXRlOiBEYXRlLFxuICAgIHRvRGF0ZTogRGF0ZSxcbiAgICBmcm9tUGFnZTogT2JqZWN0LFxuICAgIHRvUGFnZTogT2JqZWN0LFxuICAgIG1pblBhZ2U6IE9iamVjdCxcbiAgICBtYXhQYWdlOiBPYmplY3QsXG4gICAgdHJhbnNpdGlvbjogU3RyaW5nLFxuICAgIGF0dHJpYnV0ZXM6IFtPYmplY3QsIEFycmF5XSxcbiAgICBkaXNhYmxlUGFnZVN3aXBlOiBCb29sZWFuXG4gIH0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZXM6IFtdLFxuICAgICAgc3RvcmU6IG51bGwsXG4gICAgICBsYXN0Rm9jdXNlZERheTogbnVsbCxcbiAgICAgIGZvY3VzYWJsZURheTogbmV3IERhdGUoKS5nZXREYXRlKCksXG4gICAgICB0cmFuc2l0aW9uTmFtZTogJycsXG4gICAgICBpblRyYW5zaXRpb246IGZhbHNlLFxuICAgICAgc2hhcmVkU3RhdGU6IHtcbiAgICAgICAgZGF5UG9wb3ZlcklkOiBjcmVhdGVHdWlkKCksXG4gICAgICAgIHRoZW1lOiB7fSxcbiAgICAgICAgbWFza3M6IHt9LFxuICAgICAgICBsb2NhbGU6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHRpdGxlUG9zaXRpb25fKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcE9yRGVmYXVsdCgndGl0bGVQb3NpdGlvbicsICd0aXRsZVBvc2l0aW9uJyk7XG4gICAgfSxcblxuICAgIGZpcnN0UGFnZSgpIHtcbiAgICAgIHJldHVybiBoZWFkX2RlZmF1bHQoKSh0aGlzLnBhZ2VzKTtcbiAgICB9LFxuXG4gICAgbGFzdFBhZ2UoKSB7XG4gICAgICByZXR1cm4gbGFzdF9kZWZhdWx0KCkodGhpcy5wYWdlcyk7XG4gICAgfSxcblxuICAgIG1pblBhZ2VfKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWluUGFnZSB8fCBwYWdlRm9yRGF0ZSh0aGlzLm5vcm1hbGl6ZURhdGUodGhpcy5taW5EYXRlKSk7XG4gICAgfSxcblxuICAgIG1heFBhZ2VfKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF4UGFnZSB8fCBwYWdlRm9yRGF0ZSh0aGlzLm5vcm1hbGl6ZURhdGUodGhpcy5tYXhEYXRlKSk7XG4gICAgfSxcblxuICAgIGNvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucm93cyAqIHRoaXMuY29sdW1ucztcbiAgICB9LFxuXG4gICAgc3RlcF8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGVwIHx8IHRoaXMuY291bnQ7XG4gICAgfSxcblxuICAgIGNhbk1vdmVQcmV2KCkge1xuICAgICAgcmV0dXJuICFwYWdlSXNWYWxpZCh0aGlzLm1pblBhZ2VfKSB8fCBwYWdlSXNBZnRlclBhZ2UodGhpcy5wYWdlc1swXSwgdGhpcy5taW5QYWdlXyk7XG4gICAgfSxcblxuICAgIGNhbk1vdmVOZXh0KCkge1xuICAgICAgcmV0dXJuICFwYWdlSXNWYWxpZCh0aGlzLm1heFBhZ2VfKSB8fCBwYWdlSXNCZWZvcmVQYWdlKHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSwgdGhpcy5tYXhQYWdlXyk7XG4gICAgfVxuXG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgJGxvY2FsZSgpIHtcbiAgICAgIHRoaXMucmVmcmVzaExvY2FsZSgpO1xuICAgICAgdGhpcy5yZWZyZXNoUGFnZXMoe1xuICAgICAgICBwYWdlOiB0aGlzLmZpcnN0UGFnZSxcbiAgICAgICAgaWdub3JlQ2FjaGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbml0U3RvcmUoKTtcbiAgICB9LFxuXG4gICAgJHRoZW1lKCkge1xuICAgICAgdGhpcy5yZWZyZXNoVGhlbWUoKTtcbiAgICAgIHRoaXMuaW5pdFN0b3JlKCk7XG4gICAgfSxcblxuICAgIHRpbWV6b25lKCkge1xuICAgICAgLy8gUmVmcmVzaCBwYWdlcyB0byByZXNldCB0aGUgdGltZSBib3VuZGFyaWVzXG4gICAgICB0aGlzLnJlZnJlc2hQYWdlcyh7XG4gICAgICAgIGlnbm9yZUNhY2hlOiB0cnVlXG4gICAgICB9KTsgLy8gUmVmcmVzaCBhdHRyaWJ1dGVzXG5cbiAgICAgIHRoaXMucmVmcmVzaEF0dHJzKHRoaXMucGFnZXMsIHRoaXMuc3RvcmUubGlzdCwgbnVsbCwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIGZyb21EYXRlKCkge1xuICAgICAgdGhpcy5yZWZyZXNoUGFnZXMoKTtcbiAgICB9LFxuXG4gICAgZnJvbVBhZ2UodmFsKSB7XG4gICAgICBjb25zdCBmaXJzdFBhZ2UgPSB0aGlzLnBhZ2VzICYmIHRoaXMucGFnZXNbMF07XG4gICAgICBpZiAocGFnZUlzRXF1YWxUb1BhZ2UodmFsLCBmaXJzdFBhZ2UpKSByZXR1cm47XG4gICAgICB0aGlzLnJlZnJlc2hQYWdlcygpO1xuICAgIH0sXG5cbiAgICB0b1BhZ2UodmFsKSB7XG4gICAgICBjb25zdCBsYXN0UGFnZSA9IHRoaXMucGFnZXMgJiYgdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHBhZ2VJc0VxdWFsVG9QYWdlKHZhbCwgbGFzdFBhZ2UpKSByZXR1cm47XG4gICAgICB0aGlzLnJlZnJlc2hQYWdlcygpO1xuICAgIH0sXG5cbiAgICBjb3VudCgpIHtcbiAgICAgIHRoaXMucmVmcmVzaFBhZ2VzKCk7XG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZXModmFsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFkZHMsXG4gICAgICAgIGRlbGV0ZXNcbiAgICAgIH0gPSB0aGlzLnN0b3JlLnJlZnJlc2godmFsKTtcbiAgICAgIHRoaXMucmVmcmVzaEF0dHJzKHRoaXMucGFnZXMsIGFkZHMsIGRlbGV0ZXMpO1xuICAgIH0sXG5cbiAgICBwYWdlcyh2YWwpIHtcbiAgICAgIHRoaXMucmVmcmVzaEF0dHJzKHZhbCwgdGhpcy5zdG9yZS5saXN0LCBudWxsLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgZGlzYWJsZWRBdHRyaWJ1dGUoKSB7XG4gICAgICB0aGlzLnJlZnJlc2hEaXNhYmxlZERheXMoKTtcbiAgICB9LFxuXG4gICAgbGFzdEZvY3VzZWREYXkodmFsKSB7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuZm9jdXNhYmxlRGF5ID0gdmFsLmRheTtcbiAgICAgICAgdGhpcy5yZWZyZXNoRm9jdXNhYmxlRGF5cygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpblRyYW5zaXRpb24odmFsKSB7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3RyYW5zaXRpb24tc3RhcnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3RyYW5zaXRpb24tZW5kJyk7XG5cbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblByb21pc2UpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Qcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9LFxuXG4gIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5yZWZyZXNoTG9jYWxlKCk7XG4gICAgdGhpcy5yZWZyZXNoVGhlbWUoKTtcbiAgICB0aGlzLmluaXRTdG9yZSgpO1xuICAgIHRoaXMucmVmcmVzaFBhZ2VzKCk7XG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICghdGhpcy5kaXNhYmxlUGFnZVN3aXBlKSB7XG4gICAgICAvLyBBZGQgc3dpcGUgaGFuZGxlciB0byBtb3ZlIHRvIG5leHQgYW5kIHByZXZpb3VzIHBhZ2VzXG4gICAgICBjb25zdCByZW1vdmVIYW5kbGVycyA9IGFkZEhvcml6b250YWxTd2lwZUhhbmRsZXIodGhpcy4kcmVmcy5jb250YWluZXIsIGZ1bmN0aW9uICh7XG4gICAgICAgIHRvTGVmdCxcbiAgICAgICAgdG9SaWdodFxuICAgICAgfSkge1xuICAgICAgICBpZiAodG9MZWZ0KSB7XG4gICAgICAgICAgX3RoaXMyLm1vdmVOZXh0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9SaWdodCkge1xuICAgICAgICAgIF90aGlzMi5tb3ZlUHJldigpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLiRkZWZhdWx0cy50b3VjaCk7IC8vIENsZWFuIHVwIG9uIGRlc3Ryb3lcblxuICAgICAgdGhpcy4kb25jZSgnYmVmb3JlRGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUhhbmRsZXJzKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHJlZnJlc2hMb2NhbGUoKSB7XG4gICAgICB0aGlzLnNoYXJlZFN0YXRlLmxvY2FsZSA9IHRoaXMuJGxvY2FsZTtcbiAgICAgIHRoaXMuc2hhcmVkU3RhdGUubWFza3MgPSB0aGlzLiRsb2NhbGUubWFza3M7XG4gICAgfSxcblxuICAgIHJlZnJlc2hUaGVtZSgpIHtcbiAgICAgIHRoaXMuc2hhcmVkU3RhdGUudGhlbWUgPSB0aGlzLiR0aGVtZTtcbiAgICB9LFxuXG4gICAgY2FuTW92ZShwYWdlKSB7XG4gICAgICByZXR1cm4gcGFnZUlzQmV0d2VlblBhZ2VzKHBhZ2UsIHRoaXMubWluUGFnZV8sIHRoaXMubWF4UGFnZV8pO1xuICAgIH0sXG5cbiAgICBhc3luYyBtb3ZlUHJldihvcHRzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLm1vdmUoLXRoaXMuc3RlcF8sIG9wdHMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgbW92ZU5leHQob3B0cykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5tb3ZlKHRoaXMuc3RlcF8sIG9wdHMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgbW92ZShhcmcsIG9wdHMpIHtcbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLiRsb2NhbGUudG9QYWdlKGFyZywgdGhpcy5wYWdlc1swXSk7XG5cbiAgICAgIGlmICghcGFnZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWZyZXNoUGFnZXMoeyAuLi5vcHRzLFxuICAgICAgICBwYWdlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZvY3VzRGF0ZShkYXRlLCBvcHRzID0ge30pIHtcbiAgICAgIGNvbnN0IHBhZ2UgPSBwYWdlRm9yRGF0ZShkYXRlKTsgLy8gQ2FsY3VsYXRlIG5ldyBmcm9tUGFnZVxuXG4gICAgICBsZXQgZnJvbVBhZ2UgPSBudWxsO1xuXG4gICAgICBpZiAob3B0cy5wb3NpdGlvbikge1xuICAgICAgICBmcm9tUGFnZSA9IHRoaXMuZ2V0VGFyZ2V0UGFnZVJhbmdlKHBhZ2UsIG9wdHMucG9zaXRpb24pLmZyb21QYWdlO1xuICAgICAgfSBlbHNlIGlmIChwYWdlSXNCZWZvcmVQYWdlKHBhZ2UsIHRoaXMuZmlyc3RQYWdlKSkge1xuICAgICAgICBmcm9tUGFnZSA9IHRoaXMuZ2V0VGFyZ2V0UGFnZVJhbmdlKHBhZ2UsIC0xKS5mcm9tUGFnZTtcbiAgICAgIH0gZWxzZSBpZiAocGFnZUlzQWZ0ZXJQYWdlKHBhZ2UsIHRoaXMubGFzdFBhZ2UpKSB7XG4gICAgICAgIGZyb21QYWdlID0gdGhpcy5nZXRUYXJnZXRQYWdlUmFuZ2UocGFnZSwgMSkuZnJvbVBhZ2U7XG4gICAgICB9IC8vIE1vdmUgdG8gbmV3IGZyb21QYWdlIGlmIGl0J3MgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgb25lXG5cblxuICAgICAgaWYgKGZyb21QYWdlICYmICFwYWdlSXNFcXVhbFRvUGFnZShmcm9tUGFnZSwgdGhpcy5wYWdlc1swXSkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoUGFnZXMoeyAuLi5vcHRzLFxuICAgICAgICAgIHBvc2l0aW9uOiAxLFxuICAgICAgICAgIHBhZ2U6IGZyb21QYWdlXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBTZXQgZm9jdXMgb24gdGhlIGVsZW1lbnQgZm9yIHRoZSBkYXRlXG5cblxuICAgICAgY29uc3QgZm9jdXNhYmxlRWwgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKGAuaWQtJHt0aGlzLiRsb2NhbGUuZ2V0RGF5SWQoZGF0ZSl9LmluLW1vbnRoIC52Yy1mb2N1c2FibGVgKTtcblxuICAgICAgaWYgKGZvY3VzYWJsZUVsKSB7XG4gICAgICAgIGZvY3VzYWJsZUVsLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIHNob3dQYWdlUmFuZ2UocmFuZ2UsIG9wdHMpIHtcbiAgICAgIGxldCBmcm9tUGFnZTtcbiAgICAgIGxldCB0b1BhZ2U7XG5cbiAgICAgIGlmIChfaXNEYXRlKHJhbmdlKSkge1xuICAgICAgICBmcm9tUGFnZSA9IHBhZ2VGb3JEYXRlKHJhbmdlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocmFuZ2UpKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtb250aCxcbiAgICAgICAgICB5ZWFyXG4gICAgICAgIH0gPSByYW5nZTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG9cbiAgICAgICAgfSA9IHJhbmdlO1xuXG4gICAgICAgIGlmIChpc051bWJlcl9kZWZhdWx0KCkobW9udGgpICYmIGlzTnVtYmVyX2RlZmF1bHQoKSh5ZWFyKSkge1xuICAgICAgICAgIGZyb21QYWdlID0gcmFuZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbSB8fCB0bykge1xuICAgICAgICAgIGZyb21QYWdlID0gX2lzRGF0ZShmcm9tKSA/IHBhZ2VGb3JEYXRlKGZyb20pIDogZnJvbTtcbiAgICAgICAgICB0b1BhZ2UgPSBfaXNEYXRlKHRvKSA/IHBhZ2VGb3JEYXRlKHRvKSA6IHRvO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhc3RQYWdlID0gdGhpcy5sYXN0UGFnZTtcbiAgICAgIGxldCBwYWdlID0gZnJvbVBhZ2U7IC8vIE9mZnNldCBwYWdlIGZyb20gdGhlIGRlc2lyZWQgYHRvUGFnZWBcblxuICAgICAgaWYgKHBhZ2VJc0FmdGVyUGFnZSh0b1BhZ2UsIGxhc3RQYWdlKSkge1xuICAgICAgICBwYWdlID0gYWRkUGFnZXModG9QYWdlLCAtKHRoaXMucGFnZXMubGVuZ3RoIC0gMSkpO1xuICAgICAgfSAvLyBCdXQgbm8gZWFybGllciB0aGFuIHRoZSBkZXNpcmVkIGBmcm9tUGFnZWBcblxuXG4gICAgICBpZiAocGFnZUlzQmVmb3JlUGFnZShwYWdlLCBmcm9tUGFnZSkpIHtcbiAgICAgICAgcGFnZSA9IGZyb21QYWdlO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLnJlZnJlc2hQYWdlcyh7IC4uLm9wdHMsXG4gICAgICAgIHBhZ2VcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRUYXJnZXRQYWdlUmFuZ2UocGFnZSwgcG9zaXRpb24pIHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGFnZSB0byBzdGFydCBkaXNwbGF5aW5nIGZyb21cbiAgICAgIGxldCBmcm9tUGFnZSA9IG51bGw7IC8vIDEuIFRyeSB0aGUgcGFnZSBwYXJhbWV0ZXJcblxuICAgICAgaWYgKHBhZ2VJc1ZhbGlkKHBhZ2UpKSB7XG4gICAgICAgIGNvbnN0IHBhZ2VzVG9BZGQgPSBwb3NpdGlvbiA+IDAgPyAxIC0gcG9zaXRpb24gOiAtKHRoaXMuY291bnQgKyBwb3NpdGlvbik7XG4gICAgICAgIGZyb21QYWdlID0gYWRkUGFnZXMocGFnZSwgcGFnZXNUb0FkZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAyLiBUcnkgdGhlIGZyb21QYWdlIHByb3BcbiAgICAgICAgZnJvbVBhZ2UgPSB0aGlzLmZyb21QYWdlIHx8IHBhZ2VGb3JEYXRlKHRoaXMubm9ybWFsaXplRGF0ZSh0aGlzLmZyb21EYXRlKSk7XG5cbiAgICAgICAgaWYgKCFwYWdlSXNWYWxpZChmcm9tUGFnZSkpIHtcbiAgICAgICAgICAvLyAzLiBUcnkgdGhlIHRvUGFnZSBwcm9wXG4gICAgICAgICAgY29uc3QgdG9QYWdlID0gdGhpcy50b1BhZ2UgfHwgcGFnZUZvckRhdGUodGhpcy5ub3JtYWxpemVEYXRlKHRoaXMudG9QYWdlKSk7XG5cbiAgICAgICAgICBpZiAocGFnZUlzVmFsaWQodG9QYWdlKSkge1xuICAgICAgICAgICAgZnJvbVBhZ2UgPSBhZGRQYWdlcyh0b1BhZ2UsIDEgLSB0aGlzLmNvdW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNC4gVHJ5IHRoZSBmaXJzdCBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGZyb21QYWdlID0gdGhpcy5nZXRQYWdlRm9yQXR0cmlidXRlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyA1LiBGYWxsIGJhY2sgdG8gdG9kYXkncyBwYWdlXG5cblxuICAgICAgZnJvbVBhZ2UgPSBwYWdlSXNWYWxpZChmcm9tUGFnZSkgPyBmcm9tUGFnZSA6IHBhZ2VGb3JUaGlzTW9udGgoKTsgLy8gQWRqdXN0IGZyb20gcGFnZSB3aXRoaW4gYWxsb3dlZCBtaW4vbWF4IHBhZ2VzXG5cbiAgICAgIGNvbnN0IHRvUGFnZSA9IGFkZFBhZ2VzKGZyb21QYWdlLCB0aGlzLmNvdW50IC0gMSk7XG5cbiAgICAgIGlmIChwYWdlSXNCZWZvcmVQYWdlKGZyb21QYWdlLCB0aGlzLm1pblBhZ2VfKSkge1xuICAgICAgICBmcm9tUGFnZSA9IHRoaXMubWluUGFnZV87XG4gICAgICB9IGVsc2UgaWYgKHBhZ2VJc0FmdGVyUGFnZSh0b1BhZ2UsIHRoaXMubWF4UGFnZV8pKSB7XG4gICAgICAgIGZyb21QYWdlID0gYWRkUGFnZXModGhpcy5tYXhQYWdlXywgMSAtIHRoaXMuY291bnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmcm9tUGFnZSxcbiAgICAgICAgdG9QYWdlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyByZWZyZXNoUGFnZXMoe1xuICAgICAgcGFnZSxcbiAgICAgIHBvc2l0aW9uID0gMSxcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBpZ25vcmVDYWNoZVxuICAgIH0gPSB7fSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmcm9tUGFnZSxcbiAgICAgICAgICB0b1BhZ2VcbiAgICAgICAgfSA9IF90aGlzMy5nZXRUYXJnZXRQYWdlUmFuZ2UocGFnZSwgcG9zaXRpb24pOyAvLyBDcmVhdGUgdGhlIG5ldyBwYWdlc1xuXG5cbiAgICAgICAgY29uc3QgcGFnZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF90aGlzMy5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgcGFnZXMucHVzaChfdGhpczMuYnVpbGRQYWdlKGFkZFBhZ2VzKGZyb21QYWdlLCBpKSwgaWdub3JlQ2FjaGUpKTtcbiAgICAgICAgfSAvLyBSZWZyZXNoIGRpc2FibGVkIGRheXMgZm9yIG5ldyBwYWdlc1xuXG5cbiAgICAgICAgX3RoaXMzLnJlZnJlc2hEaXNhYmxlZERheXMocGFnZXMpOyAvLyBSZWZyZXNoIGZvY3VzYWJsZSBkYXlzIGZvciBuZXcgcGFnZXNcblxuXG4gICAgICAgIF90aGlzMy5yZWZyZXNoRm9jdXNhYmxlRGF5cyhwYWdlcyk7IC8vIEFzc2lnbiB0aGUgdHJhbnNpdGlvblxuXG5cbiAgICAgICAgX3RoaXMzLnRyYW5zaXRpb25OYW1lID0gX3RoaXMzLmdldFBhZ2VUcmFuc2l0aW9uKF90aGlzMy5wYWdlc1swXSwgcGFnZXNbMF0sIHRyYW5zaXRpb24pOyAvLyBBc3NpZ24gdGhlIG5ldyBwYWdlc1xuXG4gICAgICAgIF90aGlzMy5wYWdlcyA9IHBhZ2VzOyAvLyBFbWl0IHBhZ2UgdXBkYXRlIGV2ZW50c1xuXG4gICAgICAgIF90aGlzMy4kZW1pdCgndXBkYXRlOmZyb20tcGFnZScsIGZyb21QYWdlKTtcblxuICAgICAgICBfdGhpczMuJGVtaXQoJ3VwZGF0ZTp0by1wYWdlJywgdG9QYWdlKTtcblxuICAgICAgICBpZiAoX3RoaXMzLnRyYW5zaXRpb25OYW1lICYmIF90aGlzMy50cmFuc2l0aW9uTmFtZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgX3RoaXMzLnRyYW5zaXRpb25Qcm9taXNlID0ge1xuICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVmcmVzaERpc2FibGVkRGF5cyhwYWdlcykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZ2V0UGFnZURheXMocGFnZXMpLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZC5pc0Rpc2FibGVkID0gISFfdGhpczQuZGlzYWJsZWRBdHRyaWJ1dGUgJiYgX3RoaXM0LmRpc2FibGVkQXR0cmlidXRlLmludGVyc2VjdHNEYXkoZCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVmcmVzaEZvY3VzYWJsZURheXMocGFnZXMpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLmdldFBhZ2VEYXlzKHBhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQuaXNGb2N1c2FibGUgPSBkLmluTW9udGggJiYgZC5kYXkgPT09IF90aGlzNS5mb2N1c2FibGVEYXk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0UGFnZURheXMocGFnZXMgPSB0aGlzLnBhZ2VzKSB7XG4gICAgICByZXR1cm4gcGFnZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgIHJldHVybiBwcmV2LmNvbmNhdChjdXJyLmRheXMpO1xuICAgICAgfSwgW10pO1xuICAgIH0sXG5cbiAgICBnZXRQYWdlVHJhbnNpdGlvbihvbGRQYWdlLCBuZXdQYWdlLCB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uKSB7XG4gICAgICBpZiAodHJhbnNpdGlvbiA9PT0gJ25vbmUnKSByZXR1cm4gdHJhbnNpdGlvbjtcblxuICAgICAgaWYgKHRyYW5zaXRpb24gPT09ICdmYWRlJyB8fCAhdHJhbnNpdGlvbiAmJiB0aGlzLmNvdW50ID4gMSB8fCAhcGFnZUlzVmFsaWQob2xkUGFnZSkgfHwgIXBhZ2VJc1ZhbGlkKG5ld1BhZ2UpKSB7XG4gICAgICAgIHJldHVybiAnZmFkZSc7XG4gICAgICB9IC8vIE1vdmluZyB0byBhIHByZXZpb3VzIHBhZ2VcblxuXG4gICAgICBjb25zdCBtb3ZlUHJldiA9IHBhZ2VJc0JlZm9yZVBhZ2UobmV3UGFnZSwgb2xkUGFnZSk7IC8vIFZlcnRpY2FsIHNsaWRlXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uID09PSAnc2xpZGUtdicpIHtcbiAgICAgICAgcmV0dXJuIG1vdmVQcmV2ID8gJ3NsaWRlLWRvd24nIDogJ3NsaWRlLXVwJztcbiAgICAgIH0gLy8gSG9yaXpvbnRhbCBzbGlkZVxuXG5cbiAgICAgIHJldHVybiBtb3ZlUHJldiA/ICdzbGlkZS1yaWdodCcgOiAnc2xpZGUtbGVmdCc7XG4gICAgfSxcblxuICAgIGdldFBhZ2VGb3JBdHRyaWJ1dGVzKCkge1xuICAgICAgbGV0IHBhZ2UgPSBudWxsO1xuICAgICAgY29uc3QgYXR0ciA9IHRoaXMuc3RvcmUucGluQXR0cjtcblxuICAgICAgaWYgKGF0dHIgJiYgYXR0ci5oYXNEYXRlcykge1xuICAgICAgICBsZXQgW2RhdGVdID0gYXR0ci5kYXRlcztcbiAgICAgICAgZGF0ZSA9IGRhdGUuc3RhcnQgfHwgZGF0ZS5kYXRlO1xuICAgICAgICBwYWdlID0gcGFnZUZvckRhdGUodGhpcy5ub3JtYWxpemVEYXRlKGRhdGUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSxcblxuICAgIGJ1aWxkUGFnZSh7XG4gICAgICBtb250aCxcbiAgICAgIHllYXJcbiAgICB9LCBpZ25vcmVDYWNoZSkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGNvbnN0IGtleSA9IGAke3llYXIudG9TdHJpbmcoKX0tJHttb250aC50b1N0cmluZygpfWA7XG4gICAgICBsZXQgcGFnZSA9IHRoaXMucGFnZXMuZmluZChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC5rZXkgPT09IGtleTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXBhZ2UgfHwgaWdub3JlQ2FjaGUpIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgMTUpO1xuICAgICAgICBjb25zdCBtb250aENvbXBzID0gdGhpcy4kbG9jYWxlLmdldE1vbnRoQ29tcHMobW9udGgsIHllYXIpO1xuICAgICAgICBjb25zdCBwcmV2TW9udGhDb21wcyA9IHRoaXMuJGxvY2FsZS5nZXRQcmV2TW9udGhDb21wcyhtb250aCwgeWVhcik7XG4gICAgICAgIGNvbnN0IG5leHRNb250aENvbXBzID0gdGhpcy4kbG9jYWxlLmdldE5leHRNb250aENvbXBzKG1vbnRoLCB5ZWFyKTtcbiAgICAgICAgcGFnZSA9IHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbW9udGgsXG4gICAgICAgICAgeWVhcixcbiAgICAgICAgICB0aXRsZTogdGhpcy4kbG9jYWxlLmZvcm1hdChkYXRlLCB0aGlzLiRsb2NhbGUubWFza3MudGl0bGUpLFxuICAgICAgICAgIHNob3J0TW9udGhMYWJlbDogdGhpcy4kbG9jYWxlLmZvcm1hdChkYXRlLCAnTU1NJyksXG4gICAgICAgICAgbW9udGhMYWJlbDogdGhpcy4kbG9jYWxlLmZvcm1hdChkYXRlLCAnTU1NTScpLFxuICAgICAgICAgIHNob3J0WWVhckxhYmVsOiB5ZWFyLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgIHllYXJMYWJlbDogeWVhci50b1N0cmluZygpLFxuICAgICAgICAgIG1vbnRoQ29tcHMsXG4gICAgICAgICAgcHJldk1vbnRoQ29tcHMsXG4gICAgICAgICAgbmV4dE1vbnRoQ29tcHMsXG4gICAgICAgICAgY2FuTW92ZTogZnVuY3Rpb24gKHBnKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM2LmNhbk1vdmUocGcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbW92ZTogZnVuY3Rpb24gKHBnKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM2Lm1vdmUocGcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbW92ZVRoaXNNb250aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNi5tb3ZlVGhpc01vbnRoKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb3ZlUHJldk1vbnRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM2Lm1vdmUocHJldk1vbnRoQ29tcHMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbW92ZU5leHRNb250aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNi5tb3ZlKG5leHRNb250aENvbXBzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlZnJlc2g6IHRydWVcbiAgICAgICAgfTsgLy8gQXNzaWduIGRheSBpbmZvXG5cbiAgICAgICAgcGFnZS5kYXlzID0gdGhpcy4kbG9jYWxlLmdldENhbGVuZGFyRGF5cyhwYWdlLCB0aGlzLnRpbWV6b25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSxcblxuICAgIGluaXRTdG9yZSgpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBhdHRyaWJ1dGUgc3RvcmVcbiAgICAgIHRoaXMuc3RvcmUgPSBuZXcgYXR0cmlidXRlU3RvcmVfQXR0cmlidXRlU3RvcmUodGhpcy4kdGhlbWUsIHRoaXMuJGxvY2FsZSwgdGhpcy5hdHRyaWJ1dGVzKTsgLy8gUmVmcmVzaCBhdHRyaWJ1dGVzIGZvciBleGlzdGluZyBwYWdlc1xuXG4gICAgICB0aGlzLnJlZnJlc2hBdHRycyh0aGlzLnBhZ2VzLCB0aGlzLnN0b3JlLmxpc3QsIFtdLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgcmVmcmVzaEF0dHJzKHBhZ2VzID0gW10sIGFkZHMgPSBbXSwgZGVsZXRlcyA9IFtdLCByZXNldCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIGlmICghYXJyYXlIYXNJdGVtcyhwYWdlcykpIHJldHVybjsgLy8gRm9yIGVhY2ggcGFnZS4uLlxuXG4gICAgICBwYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIC8vIEZvciBlYWNoIGRheS4uLlxuICAgICAgICBwLmRheXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGxldCBtYXAgPSB7fTsgLy8gSWYgcmVzZXR0aW5nLi4uXG5cbiAgICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgIGQucmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNBbnkoZC5hdHRyaWJ1dGVzTWFwLCBkZWxldGVzKSkge1xuICAgICAgICAgICAgLy8gRGVsZXRlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZGVsZXRlIGxpc3RcbiAgICAgICAgICAgIG1hcCA9IG9taXRfZGVmYXVsdCgpKGQuYXR0cmlidXRlc01hcCwgZGVsZXRlcyk7IC8vIEZsYWcgZGF5IGZvciByZWZyZXNoXG5cbiAgICAgICAgICAgIGQucmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZXhpc3RpbmcgYXR0cmlidXRlc1xuICAgICAgICAgICAgbWFwID0gZC5hdHRyaWJ1dGVzTWFwIHx8IHt9O1xuICAgICAgICAgIH0gLy8gRm9yIGVhY2ggYXR0cmlidXRlIHRvIGFkZC4uLlxuXG5cbiAgICAgICAgICBhZGRzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIC8vIEFkZCBpdCBpZiBpdCBpbmNsdWRlcyB0aGUgY3VycmVudCBkYXlcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGUgPSBhdHRyLmludGVyc2VjdHNEYXkoZCk7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0F0dHIgPSB7IC4uLmF0dHIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0RGF0ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBtYXBbYXR0ci5rZXldID0gbmV3QXR0cjsgLy8gRmxhZyBkYXkgZm9yIHJlZnJlc2hcblxuICAgICAgICAgICAgICBkLnJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pOyAvLyBSZWFzc2lnbiBkYXkgYXR0cmlidXRlc1xuXG4gICAgICAgICAgaWYgKGQucmVmcmVzaCkge1xuICAgICAgICAgICAgZC5hdHRyaWJ1dGVzTWFwID0gbWFwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gUmVmcmVzaCBwYWdlc1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNy4kcmVmcy5wYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHAucmVmcmVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBoYW5kbGVLZXlkb3duKGUpIHtcbiAgICAgIGNvbnN0IGRheSA9IHRoaXMubGFzdEZvY3VzZWREYXk7XG5cbiAgICAgIGlmIChkYXkgIT0gbnVsbCkge1xuICAgICAgICBkYXkuZXZlbnQgPSBlO1xuICAgICAgICB0aGlzLmhhbmRsZURheUtleWRvd24oZGF5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlRGF5S2V5ZG93bihkYXkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0ZSxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0gPSBkYXk7XG4gICAgICBsZXQgbmV3RGF0ZSA9IG51bGw7XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gTW92ZSB0byBwcmV2aW91cyBkYXlcbiAgICAgICAgICAgIG5ld0RhdGUgPSBhZGREYXlzKGRhdGUsIC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgZGF5XG4gICAgICAgICAgICBuZXdEYXRlID0gYWRkRGF5cyhkYXRlLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRvIHByZXZpb3VzIHdlZWtcbiAgICAgICAgICAgIG5ld0RhdGUgPSBhZGREYXlzKGRhdGUsIC03KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIE1vdmUgdG8gbmV4dCB3ZWVrXG4gICAgICAgICAgICBuZXdEYXRlID0gYWRkRGF5cyhkYXRlLCA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRvIGZpcnN0IHdlZWtkYXkgcG9zaXRpb25cbiAgICAgICAgICAgIG5ld0RhdGUgPSBhZGREYXlzKGRhdGUsIC1kYXkud2Vla2RheVBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRvIGxhc3Qgd2Vla2RheSBwb3NpdGlvblxuICAgICAgICAgICAgbmV3RGF0ZSA9IGFkZERheXMoZGF0ZSwgZGF5LndlZWtkYXlQb3NpdGlvbkZyb21FbmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ1BhZ2VVcCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHByZXZpb3VzIHllYXIgdy8gQWx0L09wdGlvbiBrZXlcbiAgICAgICAgICAgICAgbmV3RGF0ZSA9IGFkZFllYXJzKGRhdGUsIC0xKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE1vdmUgdG8gcHJldmlvdXMgbW9udGhcbiAgICAgICAgICAgICAgbmV3RGF0ZSA9IGFkZE1vbnRocyhkYXRlLCAtMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgeWVhciB3LyBBbHQvT3B0aW9uIGtleVxuICAgICAgICAgICAgICBuZXdEYXRlID0gYWRkWWVhcnMoZGF0ZSwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgbW9udGhcbiAgICAgICAgICAgICAgbmV3RGF0ZSA9IGFkZE1vbnRocyhkYXRlLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3RGF0ZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmZvY3VzRGF0ZShuZXdEYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX0NhbGVuZGFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKENhbGVuZGFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQ2FsZW5kYXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1wb3N0Y3NzJlxudmFyIENhbGVuZGFydnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Bvc3Rjc3NfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImRlNWVcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvQ2FsZW5kYXIudnVlXG52YXIgQ2FsZW5kYXJfcmVuZGVyLCBDYWxlbmRhcl9zdGF0aWNSZW5kZXJGbnNcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBDYWxlbmRhcl9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfQ2FsZW5kYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIENhbGVuZGFyX3JlbmRlcixcbiAgQ2FsZW5kYXJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgQ2FsZW5kYXIgPSAoQ2FsZW5kYXJfY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcImNhY2hlRGlyZWN0b3J5XCI6XCJub2RlX21vZHVsZXMvLmNhY2hlL3Z1ZS1sb2FkZXJcIixcImNhY2hlSWRlbnRpZmllclwiOlwiODc3Mzk3OWUtdnVlLWxvYWRlci10ZW1wbGF0ZVwifSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVGltZVBpY2tlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzFhMzRiYzImc2NvcGVkPXRydWUmXG52YXIgVGltZVBpY2tlcnZ1ZV90eXBlX3RlbXBsYXRlX2lkXzMxYTM0YmMyX3Njb3BlZF90cnVlX3JlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmMtdGltZS1jb250YWluZXJcIixjbGFzczpbeyAndmMtaW52YWxpZCc6ICFfdm0udmFsdWUuaXNWYWxpZCB9XX0sW19jKCdkaXYnLFtfYygnc3ZnJyx7c3RhdGljQ2xhc3M6XCJ2Yy10aW1lLWljb25cIixhdHRyczp7XCJmaWxsXCI6XCJub25lXCIsXCJzdHJva2UtbGluZWNhcFwiOlwicm91bmRcIixcInN0cm9rZS1saW5lam9pblwiOlwicm91bmRcIixcInN0cm9rZS13aWR0aFwiOlwiMlwiLFwidmlld0JveFwiOlwiMCAwIDI0IDI0XCIsXCJzdHJva2VcIjpcImN1cnJlbnRDb2xvclwifX0sW19jKCdwYXRoJyx7YXR0cnM6e1wiZFwiOlwiTTEyIDh2NGwzIDNtNi0zYTkgOSAwIDExLTE4IDAgOSA5IDAgMDExOCAwelwifX0pXSldKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2Yy1kYXRlLXRpbWVcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZjLWRhdGVcIn0sW19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJ2Yy13ZWVrZGF5XCJ9LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS5sb2NhbGUuZm9ybWF0KF92bS5kYXRlLCAnV1dXJykpK1wiIFwiKV0pLF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJ2Yy1tb250aFwifSxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0ubG9jYWxlLmZvcm1hdChfdm0uZGF0ZSwgJ01NTScpKStcIiBcIildKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwidmMtZGF5XCJ9LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS5sb2NhbGUuZm9ybWF0KF92bS5kYXRlLCAnREQnKSkrXCIgXCIpXSksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcInZjLXllYXJcIn0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLmxvY2FsZS5mb3JtYXQoX3ZtLmRhdGUsICdZWVlZJykpK1wiIFwiKV0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmMtdGltZVwifSxbX2MoJ3RpbWUtc2VsZWN0Jyx7YXR0cnM6e1wib3B0aW9uc1wiOl92bS5ob3VyT3B0aW9uc30sbW9kZWw6e3ZhbHVlOihfdm0uaG91cnMpLGNhbGxiYWNrOmZ1bmN0aW9uICgkJHYpIHtfdm0uaG91cnM9X3ZtLl9uKCQkdil9LGV4cHJlc3Npb246XCJob3Vyc1wifX0pLF9jKCdzcGFuJyx7c3RhdGljU3R5bGU6e1wibWFyZ2luXCI6XCIwIDRweFwifX0sW192bS5fdihcIjpcIildKSxfYygndGltZS1zZWxlY3QnLHthdHRyczp7XCJvcHRpb25zXCI6X3ZtLm1pbnV0ZU9wdGlvbnN9LG1vZGVsOnt2YWx1ZTooX3ZtLm1pbnV0ZXMpLGNhbGxiYWNrOmZ1bmN0aW9uICgkJHYpIHtfdm0ubWludXRlcz1fdm0uX24oJCR2KX0sZXhwcmVzc2lvbjpcIm1pbnV0ZXNcIn19KSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2Yy1hbS1wbVwifSxbX2MoJ2J1dHRvbicse2NsYXNzOnsgYWN0aXZlOiBfdm0uaXNBTSB9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0uaXNBTSA9IHRydWV9fX0sW192bS5fdihcIiBBTSBcIildKSxfYygnYnV0dG9uJyx7Y2xhc3M6eyBhY3RpdmU6ICFfdm0uaXNBTSB9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0uaXNBTSA9IGZhbHNlfX19LFtfdm0uX3YoXCIgUE0gXCIpXSldKV0sMSldKV0pfVxudmFyIFRpbWVQaWNrZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zMWEzNGJjMl9zY29wZWRfdHJ1ZV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVGltZVBpY2tlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzFhMzRiYzImc2NvcGVkPXRydWUmXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcIjg3NzM5NzllLXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1RpbWVTZWxlY3QudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI2YTA3YTUxJnNjb3BlZD10cnVlJlxudmFyIFRpbWVTZWxlY3R2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yNmEwN2E1MV9zY29wZWRfdHJ1ZV9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZjLXNlbGVjdFwifSxbX2MoJ3NlbGVjdCcsX3ZtLl9iKHtvbjp7XCJjaGFuZ2VcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0uJGVtaXQoJ2lucHV0JywgJGV2ZW50LnRhcmdldC52YWx1ZSl9fX0sJ3NlbGVjdCcsX3ZtLiRhdHRycyxmYWxzZSksX3ZtLl9sKChfdm0ub3B0aW9ucyksZnVuY3Rpb24ob3B0aW9uKXtyZXR1cm4gX2MoJ29wdGlvbicse2tleTpvcHRpb24udmFsdWUsZG9tUHJvcHM6e1widmFsdWVcIjpvcHRpb24udmFsdWV9fSxbX3ZtLl92KF92bS5fcyhvcHRpb24ubGFiZWwpKV0pfSksMCksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmMtc2VsZWN0LWFycm93XCJ9LFtfYygnc3ZnJyx7YXR0cnM6e1wieG1sbnNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJ2aWV3Qm94XCI6XCIwIDAgMjAgMjBcIn19LFtfYygncGF0aCcse2F0dHJzOntcImRcIjpcIk05LjI5MyAxMi45NWwuNzA3LjcwN0wxNS42NTcgOGwtMS40MTQtMS40MTRMMTAgMTAuODI4IDUuNzU3IDYuNTg2IDQuMzQzIDh6XCJ9fSldKV0pXSl9XG52YXIgVGltZVNlbGVjdHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzI2YTA3YTUxX3Njb3BlZF90cnVlX3N0YXRpY1JlbmRlckZucyA9IFtdXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9UaW1lU2VsZWN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yNmEwN2E1MSZzY29wZWQ9dHJ1ZSZcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL1RpbWVTZWxlY3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBUaW1lU2VsZWN0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgcHJvcHM6IHtcbiAgICBvcHRpb25zOiBBcnJheVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVGltZVNlbGVjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19UaW1lU2VsZWN0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFRpbWVTZWxlY3R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9UaW1lU2VsZWN0LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTI2YTA3YTUxJmxhbmc9cG9zdGNzcyZzY29wZWQ9dHJ1ZSZcbnZhciBUaW1lU2VsZWN0dnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9pZF8yNmEwN2E1MV9sYW5nX3Bvc3Rjc3Nfc2NvcGVkX3RydWVfID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImVlZmJcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVGltZVNlbGVjdC52dWVcblxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIFRpbWVTZWxlY3RfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1RpbWVTZWxlY3R2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIFRpbWVTZWxlY3R2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yNmEwN2E1MV9zY29wZWRfdHJ1ZV9yZW5kZXIsXG4gIFRpbWVTZWxlY3R2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yNmEwN2E1MV9zY29wZWRfdHJ1ZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjI2YTA3YTUxXCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIFRpbWVTZWxlY3QgPSAoVGltZVNlbGVjdF9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL2NvbXBvbmVudHMvVGltZVBpY2tlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBUaW1lUGlja2VydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1RpbWVQaWNrZXInLFxuICBjb21wb25lbnRzOiB7XG4gICAgVGltZVNlbGVjdDogVGltZVNlbGVjdFxuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgbG9jYWxlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdGhlbWU6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvdXJzOiAwLFxuICAgICAgbWludXRlczogMCxcbiAgICAgIG1pbnV0ZUluY3JlbWVudDogMSxcbiAgICAgIGlzQU06IHRydWVcbiAgICB9O1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgZGF0ZSgpIHtcbiAgICAgIGxldCBkYXRlID0gdGhpcy5sb2NhbGUubm9ybWFsaXplRGF0ZSh0aGlzLnZhbHVlKTtcblxuICAgICAgaWYgKHRoaXMudmFsdWUuaG91cnMgPT09IDI0KSB7XG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuXG4gICAgaG91ck9wdGlvbnMoKSB7XG4gICAgICBjb25zdCBvcHRpb25zMTIgPSBbe1xuICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgbGFiZWw6ICcxMidcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgIGxhYmVsOiAnMSdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDIsXG4gICAgICAgIGxhYmVsOiAnMidcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgIGxhYmVsOiAnMydcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDQsXG4gICAgICAgIGxhYmVsOiAnNCdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDUsXG4gICAgICAgIGxhYmVsOiAnNSdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDYsXG4gICAgICAgIGxhYmVsOiAnNidcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDcsXG4gICAgICAgIGxhYmVsOiAnNydcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDgsXG4gICAgICAgIGxhYmVsOiAnOCdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDksXG4gICAgICAgIGxhYmVsOiAnOSdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDEwLFxuICAgICAgICBsYWJlbDogJzEwJ1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogMTEsXG4gICAgICAgIGxhYmVsOiAnMTEnXG4gICAgICB9XTtcbiAgICAgIGNvbnN0IG9wdGlvbnMyNCA9IFt7XG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICBsYWJlbDogJzAwJ1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgbGFiZWw6ICcwMSdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDIsXG4gICAgICAgIGxhYmVsOiAnMDInXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiAzLFxuICAgICAgICBsYWJlbDogJzAzJ1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogNCxcbiAgICAgICAgbGFiZWw6ICcwNCdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDUsXG4gICAgICAgIGxhYmVsOiAnMDUnXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiA2LFxuICAgICAgICBsYWJlbDogJzA2J1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogNyxcbiAgICAgICAgbGFiZWw6ICcwNydcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDgsXG4gICAgICAgIGxhYmVsOiAnMDgnXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiA5LFxuICAgICAgICBsYWJlbDogJzA5J1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogMTAsXG4gICAgICAgIGxhYmVsOiAnMTAnXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiAxMSxcbiAgICAgICAgbGFiZWw6ICcxMSdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDEyLFxuICAgICAgICBsYWJlbDogJzEyJ1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogMTMsXG4gICAgICAgIGxhYmVsOiAnMTMnXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiAxNCxcbiAgICAgICAgbGFiZWw6ICcxNCdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDE1LFxuICAgICAgICBsYWJlbDogJzE1J1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogMTYsXG4gICAgICAgIGxhYmVsOiAnMTYnXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiAxNyxcbiAgICAgICAgbGFiZWw6ICcxNydcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDE4LFxuICAgICAgICBsYWJlbDogJzE4J1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogMTksXG4gICAgICAgIGxhYmVsOiAnMTknXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiAyMCxcbiAgICAgICAgbGFiZWw6ICcyMCdcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IDIxLFxuICAgICAgICBsYWJlbDogJzIxJ1xuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogMjIsXG4gICAgICAgIGxhYmVsOiAnMjInXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiAyMyxcbiAgICAgICAgbGFiZWw6ICcyMydcbiAgICAgIH1dO1xuICAgICAgaWYgKHRoaXMuaXMyNGhyKSByZXR1cm4gb3B0aW9uczI0O1xuICAgICAgcmV0dXJuIG9wdGlvbnMxMjtcbiAgICB9LFxuXG4gICAgbWludXRlT3B0aW9ucygpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBbXTtcbiAgICAgIGxldCBtID0gMDtcblxuICAgICAgd2hpbGUgKG0gPD0gNTkpIHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICB2YWx1ZTogbSxcbiAgICAgICAgICBsYWJlbDogcGFkKG0sIDIpXG4gICAgICAgIH0pO1xuICAgICAgICBtICs9IHRoaXMubWludXRlSW5jcmVtZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB2YWx1ZSgpIHtcbiAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICB9LFxuXG4gICAgaG91cnMoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgfSxcblxuICAgIG1pbnV0ZXMoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgfSxcblxuICAgIGlzQU0oKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgfVxuXG4gIH0sXG5cbiAgY3JlYXRlZCgpIHtcbiAgICB0aGlzLnNldHVwKCk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHByb3RlY3RlZChmbikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuYnVzeSkgcmV0dXJuO1xuICAgICAgdGhpcy5idXN5ID0gdHJ1ZTtcbiAgICAgIGZuKCk7XG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2V0dXAoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5wcm90ZWN0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuaXMyNGhyID0gX3RoaXMyLmxvY2FsZS5pczI0aHIgIT09IHVuZGVmaW5lZCA/IF90aGlzMi5sb2NhbGUuaXMyNGhyIDogZmFsc2U7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaG91cnNcbiAgICAgICAgfSA9IF90aGlzMi52YWx1ZTtcbiAgICAgICAgaWYgKGhvdXJzID09PSAyNCkgaG91cnMgPSAwO1xuICAgICAgICBsZXQgaXNBTSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFfdGhpczIuaXMyNGhyICYmIGhvdXJzID49IDEyKSB7XG4gICAgICAgICAgaG91cnMgLT0gMTI7XG4gICAgICAgICAgaXNBTSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLmhvdXJzID0gaG91cnM7XG4gICAgICAgIF90aGlzMi5taW51dGVzID0gX3RoaXMyLnZhbHVlLm1pbnV0ZXM7XG4gICAgICAgIF90aGlzMi5pc0FNID0gaXNBTTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB1cGRhdGVWYWx1ZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLnByb3RlY3RlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBob3VycyA9IF90aGlzMy5ob3VycztcblxuICAgICAgICBpZiAoIV90aGlzMy5pczI0aHIgJiYgIV90aGlzMy5pc0FNKSB7XG4gICAgICAgICAgaG91cnMgKz0gMTI7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczMuJGVtaXQoJ2lucHV0JywgeyAuLi5fdGhpczMudmFsdWUsXG4gICAgICAgICAgaG91cnMsXG4gICAgICAgICAgbWludXRlczogX3RoaXMzLm1pbnV0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1RpbWVQaWNrZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfVGltZVBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChUaW1lUGlja2VydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvVGltZVBpY2tlci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zMWEzNGJjMiZsYW5nPXBvc3Rjc3Mmc2NvcGVkPXRydWUmXG52YXIgVGltZVBpY2tlcnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfaWRfMzFhMzRiYzJfbGFuZ19wb3N0Y3NzX3Njb3BlZF90cnVlXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNmY4XCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL1RpbWVQaWNrZXIudnVlXG5cblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBUaW1lUGlja2VyX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19UaW1lUGlja2VydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBUaW1lUGlja2VydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzFhMzRiYzJfc2NvcGVkX3RydWVfcmVuZGVyLFxuICBUaW1lUGlja2VydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzFhMzRiYzJfc2NvcGVkX3RydWVfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIzMWEzNGJjMlwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBUaW1lUGlja2VyID0gKFRpbWVQaWNrZXJfY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0RhdGVQaWNrZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgX2RhdGVDb25maWcgPSB7XG4gIHR5cGU6ICdhdXRvJyxcbiAgbWFzazogJ2lzbycsXG4gIC8vIFN0cmluZyBtYXNrIHdoZW4gYHR5cGUgPT09ICdzdHJpbmcnYFxuICB0aW1lQWRqdXN0OiAnJyAvLyAnSEg6TU06U1MnLCAnbm93J1xuXG59O1xuY29uc3QgX3JhbmdlQ29uZmlnID0ge1xuICBzdGFydDogeyAuLi5fZGF0ZUNvbmZpZyxcbiAgICB0aW1lQWRqdXN0OiAnMDA6MDA6MDAnXG4gIH0sXG4gIGVuZDogeyAuLi5fZGF0ZUNvbmZpZyxcbiAgICB0aW1lQWRqdXN0OiAnMjM6NTk6NTknXG4gIH1cbn07XG5jb25zdCBQQVRDSF9LRVlTID0ge1xuICAxOiBbJ3llYXInLCAnbW9udGgnLCAnZGF5JywgJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddLFxuICAyOiBbJ3llYXInLCAnbW9udGgnLCAnZGF5J10sXG4gIDM6IFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ11cbn07XG5jb25zdCBNT0RFX0RBVEUgPSAnZGF0ZSc7XG5jb25zdCBNT0RFX0RBVEVfVElNRSA9ICdkYXRldGltZSc7XG5jb25zdCBNT0RFX1RJTUUgPSAndGltZSc7XG5jb25zdCBQQVRDSF9EQVRFX1RJTUUgPSAxO1xuY29uc3QgUEFUQ0hfREFURSA9IDI7XG5jb25zdCBQQVRDSF9USU1FID0gMztcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIERhdGVQaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnRGF0ZVBpY2tlcicsXG5cbiAgcmVuZGVyKGgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gVGltZXBpY2tlciByZW5kZXJlclxuICAgIGNvbnN0IHRpbWVQaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIV90aGlzLmRhdGVQYXJ0cykgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBwYXJ0cyA9IF90aGlzLmlzUmFuZ2UgPyBfdGhpcy5kYXRlUGFydHMgOiBbX3RoaXMuZGF0ZVBhcnRzWzBdXTtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24gKGRwLCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIGgoVGltZVBpY2tlciwge1xuICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICB2YWx1ZTogZHAsXG4gICAgICAgICAgICBsb2NhbGU6IF90aGlzLiRsb2NhbGUsXG4gICAgICAgICAgICB0aGVtZTogX3RoaXMuJHRoZW1lXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5vblRpbWVJbnB1dChwLCBpZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9OyAvLyBDYWxlbmRhciByZW5kZXJlclxuXG5cbiAgICBjb25zdCBjYWxlbmRhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBoKENhbGVuZGFyLCB7XG4gICAgICAgIGF0dHJzOiB7IC4uLl90aGlzLiRhdHRycyxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBfdGhpcy5hdHRyaWJ1dGVzXyxcbiAgICAgICAgICB0aGVtZTogX3RoaXMuJHRoZW1lLFxuICAgICAgICAgIGxvY2FsZTogX3RoaXMuJGxvY2FsZSxcbiAgICAgICAgICB0aW1lem9uZTogX3RoaXMudGltZXpvbmVcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBtaW5EYXRlOiBfdGhpcy5taW5EYXRlLFxuICAgICAgICAgIG1heERhdGU6IF90aGlzLm1heERhdGUsXG4gICAgICAgICAgZGlzYWJsZWREYXRlczogX3RoaXMuZGlzYWJsZWREYXRlcyxcbiAgICAgICAgICBhdmFpbGFibGVEYXRlczogX3RoaXMuYXZhaWxhYmxlRGF0ZXNcbiAgICAgICAgfSxcbiAgICAgICAgb246IHsgLi4uX3RoaXMuJGxpc3RlbmVycyxcbiAgICAgICAgICBkYXljbGljazogX3RoaXMub25EYXlDbGljayxcbiAgICAgICAgICBkYXlrZXlkb3duOiBfdGhpcy5vbkRheUtleWRvd24sXG4gICAgICAgICAgZGF5bW91c2VlbnRlcjogX3RoaXMub25EYXlNb3VzZUVudGVyXG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlZFNsb3RzOiB7IC4uLl90aGlzLiRzY29wZWRTbG90cyxcbiAgICAgICAgICBmb290ZXI6IF90aGlzLmlzRGF0ZVRpbWUgJiYgdGltZVBpY2tlclxuICAgICAgICB9LFxuICAgICAgICByZWY6ICdjYWxlbmRhcidcbiAgICAgIH0pO1xuICAgIH07IC8vIENvbnRlbnQgcmVuZGVyZXJcblxuXG4gICAgY29uc3QgY29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5pc1RpbWUpIHtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgICBjbGFzczogWyd2Yy1jb250YWluZXInLCBgdmMtJHtfdGhpcy4kdGhlbWUuY29sb3J9YCwge1xuICAgICAgICAgICAgJ3ZjLWlzLWRhcmsnOiBfdGhpcy4kdGhlbWUuaXNEYXJrXG4gICAgICAgICAgfV1cbiAgICAgICAgfSwgW3RpbWVQaWNrZXIoKV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsZW5kYXIoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQgJiYgLy8gQ29udmVydCB0aGlzIHNwYW4gdG8gYSBmcmFnbWVudCB3aGVuIHN1cHBvcnRlZCBpbiBWdWVcbiAgICBoKCdzcGFuJywgWy8vIFNsb3QgY29udGVudFxuICAgIHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQodGhpcy5zbG90QXJncyksIC8vIFBvcG92ZXIgY29udGVudFxuICAgIGgoUG9wb3Zlciwge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaWQ6IHRoaXMuZGF0ZVBpY2tlclBvcG92ZXJJZCxcbiAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgY29udGVudENsYXNzOiBgdmMtY29udGFpbmVyJHt0aGlzLmlzRGFyayA/ICcgdmMtaXMtZGFyaycgOiAnJ31gXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgYmVmb3JlU2hvdzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuJGVtaXQoJ3BvcG92ZXJXaWxsU2hvdycsIGUpO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlclNob3c6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLiRlbWl0KCdwb3BvdmVyRGlkU2hvdycsIGUpO1xuICAgICAgICB9LFxuICAgICAgICBiZWZvcmVIaWRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgncG9wb3ZlcldpbGxIaWRlJywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFmdGVySGlkZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuJGVtaXQoJ3BvcG92ZXJEaWRIaWRlJywgZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzY29wZWRTbG90czoge1xuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBjb250ZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgfSxcbiAgICAgIHJlZjogJ3BvcG92ZXInXG4gICAgfSldKSB8fCBjb250ZW50KCk7XG4gIH0sXG5cbiAgbWl4aW5zOiBbbWl4aW5zX3Jvb3RNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgbW9kZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogTU9ERV9EQVRFXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBtb2RlbENvbmZpZzoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyAuLi5fZGF0ZUNvbmZpZ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNSZXF1aXJlZDogQm9vbGVhbixcbiAgICBpc1JhbmdlOiBCb29sZWFuLFxuICAgIHVwZGF0ZU9uSW5wdXQ6IEJvb2xlYW4sXG4gICAgaW5wdXREZWJvdW5jZTogTnVtYmVyLFxuICAgIHBvcG92ZXI6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ0F0dHJpYnV0ZTogT2JqZWN0LFxuICAgIHNlbGVjdEF0dHJpYnV0ZTogT2JqZWN0LFxuICAgIGF0dHJpYnV0ZXM6IEFycmF5XG4gIH0sXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVfOiBudWxsLFxuICAgICAgZGF0ZVBhcnRzOiBudWxsLFxuICAgICAgYWN0aXZlRGF0ZTogJycsXG4gICAgICBkcmFnVmFsdWU6IG51bGwsXG4gICAgICBpbnB1dFZhbHVlczogWycnLCAnJ10sXG4gICAgICB1cGRhdGVUaW1lb3V0OiBudWxsLFxuICAgICAgd2F0Y2hWYWx1ZTogdHJ1ZSxcbiAgICAgIGRhdGVQaWNrZXJQb3BvdmVySWQ6IGNyZWF0ZUd1aWQoKVxuICAgIH07XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICB1cGRhdGVPbklucHV0XygpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BPckRlZmF1bHQoJ3VwZGF0ZU9uSW5wdXQnLCAnZGF0ZVBpY2tlci51cGRhdGVPbklucHV0Jyk7XG4gICAgfSxcblxuICAgIGlucHV0RGVib3VuY2VfKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcE9yRGVmYXVsdCgnaW5wdXREZWJvdW5jZScsICdkYXRlUGlja2VyLmlucHV0RGVib3VuY2UnKTtcbiAgICB9LFxuXG4gICAgaXNEYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZS50b0xvd2VyQ2FzZSgpID09PSBNT0RFX0RBVEU7XG4gICAgfSxcblxuICAgIGlzRGF0ZVRpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlLnRvTG93ZXJDYXNlKCkgPT09IE1PREVfREFURV9USU1FO1xuICAgIH0sXG5cbiAgICBpc1RpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlLnRvTG93ZXJDYXNlKCkgPT09IE1PREVfVElNRTtcbiAgICB9LFxuXG4gICAgaXNEcmFnZ2luZygpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuZHJhZ1ZhbHVlO1xuICAgIH0sXG5cbiAgICBzbG90QXJncygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBjb25zdCBpbnB1dENvbmZpZyA9IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIG1hc2s6IHRoaXMuJGxvY2FsZS5tYXNrcy5pbnB1dCxcbiAgICAgICAgcGF0Y2g6IFBBVENIX0RBVEVfVElNRSxcbiAgICAgICAgdGltZXpvbmU6IHRoaXMudGltZXpvbmVcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzUmFuZ2UsXG4gICAgICAgIGlzRHJhZ2dpbmcsXG4gICAgICAgIHVwZGF0ZVZhbHVlLFxuICAgICAgICBzaG93UG9wb3ZlcixcbiAgICAgICAgaGlkZVBvcG92ZXIsXG4gICAgICAgIHRvZ2dsZVBvcG92ZXJcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgaW5wdXRWYWx1ZSA9IGlzUmFuZ2UgPyB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLmlucHV0VmFsdWVzWzBdLFxuICAgICAgICBlbmQ6IHRoaXMuaW5wdXRWYWx1ZXNbMV1cbiAgICAgIH0gOiB0aGlzLmlucHV0VmFsdWVzWzBdO1xuICAgICAgY29uc3QgZXZlbnRzID0gW3RydWUsIGZhbHNlXS5tYXAoZnVuY3Rpb24gKGlzU3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbnB1dDogX3RoaXMyLm9uSW5wdXRJbnB1dChpbnB1dENvbmZpZywgaXNTdGFydCksXG4gICAgICAgICAgY2hhbmdlOiBfdGhpczIub25JbnB1dENoYW5nZShpbnB1dENvbmZpZywgaXNTdGFydCksXG4gICAgICAgICAga2V5dXA6IF90aGlzMi5vbklucHV0S2V5dXAsXG4gICAgICAgICAgLi4uZ2V0UG9wb3ZlclRyaWdnZXJFdmVudHMoeyAuLi5fdGhpczIucG9wb3Zlcl8sXG4gICAgICAgICAgICBpZDogX3RoaXMyLmRhdGVQaWNrZXJQb3BvdmVySWQsXG4gICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUuYWN0aW9uID09PSAnc2hvdycgJiYgZS5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpczIub25JbnB1dFNob3coaXNTdGFydCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBjb25zdCBpbnB1dEV2ZW50cyA9IGlzUmFuZ2UgPyB7XG4gICAgICAgIHN0YXJ0OiBldmVudHNbMF0sXG4gICAgICAgIGVuZDogZXZlbnRzWzFdXG4gICAgICB9IDogZXZlbnRzWzBdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgaW5wdXRFdmVudHMsXG4gICAgICAgIGlzRHJhZ2dpbmcsXG4gICAgICAgIHVwZGF0ZVZhbHVlLFxuICAgICAgICBzaG93UG9wb3ZlcixcbiAgICAgICAgaGlkZVBvcG92ZXIsXG4gICAgICAgIHRvZ2dsZVBvcG92ZXIsXG4gICAgICAgIGdldFBvcG92ZXJUcmlnZ2VyRXZlbnRzOiBnZXRQb3BvdmVyVHJpZ2dlckV2ZW50c1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcG9wb3Zlcl8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wT3JEZWZhdWx0KCdwb3BvdmVyJywgJ2RhdGVQaWNrZXIucG9wb3ZlcicsICdtZXJnZScpO1xuICAgIH0sXG5cbiAgICBjYW5IaWRlUG9wb3ZlcigpIHtcbiAgICAgIHJldHVybiAhKHRoaXMucG9wb3Zlci5rZWVwVmlzaWJsZU9uSW5wdXQgfHwgdGhpcy5wb3BvdmVyXy52aXNpYmlsaXR5ICE9PSAndmlzaWJsZScpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RBdHRyaWJ1dGVfKCkge1xuICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKHRoaXMudmFsdWVfKSkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB7XG4gICAgICAgIGtleTogJ3NlbGVjdC1kcmFnJyxcbiAgICAgICAgLi4udGhpcy5zZWxlY3RBdHRyaWJ1dGUsXG4gICAgICAgIGRhdGVzOiB0aGlzLnZhbHVlXyxcbiAgICAgICAgcGluUGFnZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG90LFxuICAgICAgICBiYXIsXG4gICAgICAgIGhpZ2hsaWdodCxcbiAgICAgICAgY29udGVudFxuICAgICAgfSA9IGF0dHJpYnV0ZTtcblxuICAgICAgaWYgKCFkb3QgJiYgIWJhciAmJiAhaGlnaGxpZ2h0ICYmICFjb250ZW50KSB7XG4gICAgICAgIGF0dHJpYnV0ZS5oaWdobGlnaHQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH0sXG5cbiAgICBkcmFnQXR0cmlidXRlXygpIHtcbiAgICAgIGlmICghdGhpcy5pc1JhbmdlIHx8ICF0aGlzLmhhc1ZhbHVlKHRoaXMuZHJhZ1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0cmlidXRlID0ge1xuICAgICAgICBrZXk6ICdzZWxlY3QtZHJhZycsXG4gICAgICAgIC4uLnRoaXMuZHJhZ0F0dHJpYnV0ZSxcbiAgICAgICAgZGF0ZXM6IHRoaXMuZHJhZ1ZhbHVlXG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb3QsXG4gICAgICAgIGJhcixcbiAgICAgICAgaGlnaGxpZ2h0LFxuICAgICAgICBjb250ZW50XG4gICAgICB9ID0gYXR0cmlidXRlO1xuXG4gICAgICBpZiAoIWRvdCAmJiAhYmFyICYmICFoaWdobGlnaHQgJiYgIWNvbnRlbnQpIHtcbiAgICAgICAgYXR0cmlidXRlLmhpZ2hsaWdodCA9IHtcbiAgICAgICAgICBzdGFydEVuZDoge1xuICAgICAgICAgICAgZmlsbE1vZGU6ICdub25lJ1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9LFxuXG4gICAgYXR0cmlidXRlc18oKSB7XG4gICAgICBjb25zdCBhdHRycyA9IGlzQXJyYXlMaWtlT2JqZWN0X2RlZmF1bHQoKSh0aGlzLmF0dHJpYnV0ZXMpID8gWy4uLnRoaXMuYXR0cmlidXRlc10gOiBbXTtcblxuICAgICAgaWYgKHRoaXMuZHJhZ0F0dHJpYnV0ZV8pIHtcbiAgICAgICAgYXR0cnMucHVzaCh0aGlzLmRyYWdBdHRyaWJ1dGVfKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RBdHRyaWJ1dGVfKSB7XG4gICAgICAgIGF0dHJzLnB1c2godGhpcy5zZWxlY3RBdHRyaWJ1dGVfKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH1cblxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzUmFuZ2U6IHtcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcblxuICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pbml0RGF0ZUNvbmZpZygpO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHZhbHVlKCkge1xuICAgICAgaWYgKCF0aGlzLndhdGNoVmFsdWUpIHJldHVybjtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGVWYWx1ZSh0aGlzLnZhbHVlLCB7XG4gICAgICAgIGNvbmZpZzogdGhpcy5tb2RlbENvbmZpZyxcbiAgICAgICAgbm90aWZ5OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0SW5wdXQ6IHRydWUsXG4gICAgICAgIGhpZGVQb3BvdmVyOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHZhbHVlXygpIHtcbiAgICAgIHRoaXMucmVmcmVzaERhdGVQYXJ0cygpO1xuICAgIH0sXG5cbiAgICBkcmFnVmFsdWUoKSB7XG4gICAgICB0aGlzLnJlZnJlc2hEYXRlUGFydHMoKTtcbiAgICB9LFxuXG4gICAgdGltZXpvbmUoKSB7XG4gICAgICB0aGlzLmluaXREYXRlQ29uZmlnKCk7XG4gICAgICB0aGlzLnJlZnJlc2hEYXRlUGFydHMoKTtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGVWYWx1ZSh0aGlzLnZhbHVlXywge1xuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIGZvcm1hdElucHV0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSxcblxuICBjcmVhdGVkKCkge1xuICAgIHRoaXMuZm9yY2VVcGRhdGVWYWx1ZSh0aGlzLnZhbHVlLCB7XG4gICAgICBjb25maWc6IHRoaXMubW9kZWxDb25maWcsXG4gICAgICBub3RpZnk6IGZhbHNlLFxuICAgICAgZm9ybWF0SW5wdXQ6IHRydWUsXG4gICAgICBoaWRlUG9wb3ZlcjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJlZnJlc2hEYXRlUGFydHMoKTtcbiAgfSxcblxuICBtb3VudGVkKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgLy8gSGFuZGxlIGVzY2FwZSBrZXkgcHJlc3Nlc1xuICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMub25Eb2N1bWVudEtleURvd24pOyAvLyBDbGVhciBkcmFnIG9uIGJhY2tncm91bmQgY2xpY2tcblxuICAgIGNvbnN0IG9mZlRhcE9yQ2xpY2tIYW5kbGVyID0gYWRkVGFwT3JDbGlja0hhbmRsZXIoZG9jdW1lbnQsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyhlLnRhcmdldCkgJiYgIWVsZW1lbnRDb250YWlucyhfdGhpczMuJGVsLCBlLnRhcmdldCkpIHtcbiAgICAgICAgX3RoaXMzLmRyYWdWYWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7IC8vIENsZWFuIHVwIGhhbmRsZXJzXG5cbiAgICB0aGlzLiRvbmNlKCdiZWZvcmVEZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIF90aGlzMy5vbkRvY3VtZW50S2V5RG93bik7XG4gICAgICBvZmZUYXBPckNsaWNrSGFuZGxlcigpO1xuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBpbml0RGF0ZUNvbmZpZygpIHtcbiAgICAgIGxldCBjb25maWc7XG4gICAgICBjb25zdCB0aW1lem9uZSA9IHRoaXMudGltZXpvbmU7XG5cbiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB0aW1lem9uZSxcbiAgICAgICAgICAgIC4uLl9yYW5nZUNvbmZpZy5zdGFydCxcbiAgICAgICAgICAgIC4uLih0aGlzLm1vZGVsQ29uZmlnLnN0YXJ0IHx8IHRoaXMubW9kZWxDb25maWcpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIHRpbWV6b25lLFxuICAgICAgICAgICAgLi4uX3JhbmdlQ29uZmlnLmVuZCxcbiAgICAgICAgICAgIC4uLih0aGlzLm1vZGVsQ29uZmlnLmVuZCB8fCB0aGlzLm1vZGVsQ29uZmlnKVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICB0aW1lem9uZSxcbiAgICAgICAgICAuLi5fZGF0ZUNvbmZpZyxcbiAgICAgICAgICAuLi50aGlzLm1vZGVsQ29uZmlnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0ZUNvbmZpZyA9IGNvbmZpZztcbiAgICB9LFxuXG4gICAgZ2V0RGF0ZVBhcnRzKGRhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLiRsb2NhbGUuZ2V0RGF0ZVBhcnRzKGRhdGUsIHRoaXMudGltZXpvbmUpO1xuICAgIH0sXG5cbiAgICBnZXREYXRlRnJvbVBhcnRzKHBhcnRzKSB7XG4gICAgICByZXR1cm4gdGhpcy4kbG9jYWxlLmdldERhdGVGcm9tUGFydHMocGFydHMsIHRoaXMudGltZXpvbmUpO1xuICAgIH0sXG5cbiAgICByZWZyZXNoRGF0ZVBhcnRzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kcmFnVmFsdWUgfHwgdGhpcy52YWx1ZV87XG4gICAgICBjb25zdCBkYXRlUGFydHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuc3RhcnQpIHtcbiAgICAgICAgICBkYXRlUGFydHMucHVzaCh0aGlzLmdldERhdGVQYXJ0cyh2YWx1ZS5zdGFydCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGVQYXJ0cy5wdXNoKHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5lbmQpIHtcbiAgICAgICAgICBkYXRlUGFydHMucHVzaCh0aGlzLmdldERhdGVQYXJ0cyh2YWx1ZS5lbmQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRlUGFydHMucHVzaCh7fSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0ZVBhcnRzLnB1c2godGhpcy5nZXREYXRlUGFydHModmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGVQYXJ0cy5wdXNoKHt9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LmRhdGVQYXJ0cyA9IGRhdGVQYXJ0cztcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBvbkRvY3VtZW50S2V5RG93bihlKSB7XG4gICAgICAvLyBDbGVhciBkcmFnIG9uIGVzY2FwZSBrZXlkb3duXG4gICAgICBpZiAodGhpcy5kcmFnVmFsdWUgJiYgZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIHRoaXMuZHJhZ1ZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25EYXlDbGljayhkYXkpIHtcbiAgICAgIHRoaXMuaGFuZGxlRGF5Q2xpY2soZGF5KTsgLy8gUmUtZW1pdCBldmVudFxuXG4gICAgICB0aGlzLiRlbWl0KCdkYXljbGljaycsIGRheSk7XG4gICAgfSxcblxuICAgIG9uRGF5S2V5ZG93bihkYXkpIHtcbiAgICAgIHN3aXRjaCAoZGF5LmV2ZW50LmtleSkge1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF5Q2xpY2soZGF5KTtcbiAgICAgICAgICAgIGRheS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5oaWRlUG9wb3ZlcigpO1xuICAgICAgICAgIH1cbiAgICAgIH0gLy8gUmUtZW1pdCBldmVudFxuXG5cbiAgICAgIHRoaXMuJGVtaXQoJ2RheWtleWRvd24nLCBkYXkpO1xuICAgIH0sXG5cbiAgICBoYW5kbGVEYXlDbGljayhkYXkpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIHBhdGNoOiBQQVRDSF9EQVRFLFxuICAgICAgICBhZGp1c3RUaW1lOiB0cnVlLFxuICAgICAgICBmb3JtYXRJbnB1dDogdHJ1ZSxcbiAgICAgICAgaGlkZVBvcG92ZXI6IHRoaXMuaXNEYXRlXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgdGhpcy5kcmFnVHJhY2tpbmdWYWx1ZSA9IHsgLi4uZGF5LnJhbmdlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRyYWdUcmFja2luZ1ZhbHVlLmVuZCA9IGRheS5yYW5nZS5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdHMuaXNEcmFnZ2luZyA9ICF0aGlzLmlzRHJhZ2dpbmc7XG4gICAgICAgIG9wdHMuaGlkZVBvcG92ZXIgPSBvcHRzLmhpZGVQb3BvdmVyICYmICFvcHRzLmlzRHJhZ2dpbmc7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5kcmFnVHJhY2tpbmdWYWx1ZSwgb3B0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKGRheS5yYW5nZS5zdGFydCwgb3B0cyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uRGF5TW91c2VFbnRlcihkYXkpIHtcbiAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSByZXR1cm47XG4gICAgICB0aGlzLmRyYWdUcmFja2luZ1ZhbHVlLmVuZCA9IGRheS5yYW5nZS5zdGFydDtcbiAgICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5kcmFnVHJhY2tpbmdWYWx1ZSwge1xuICAgICAgICBwYXRjaDogUEFUQ0hfREFURSxcbiAgICAgICAgYWRqdXN0VGltZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uVGltZUlucHV0KHBhcnRzLCBpZHgpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIHRpbWV6b25lOiB0aGlzLnRpbWV6b25lLFxuICAgICAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgICAgIH0sXG4gICAgICAgIHBhdGNoOiBQQVRDSF9USU1FXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaWR4ID09PSAwID8gcGFydHMgOiB0aGlzLmRhdGVQYXJ0c1swXTtcbiAgICAgICAgY29uc3QgZW5kID0gaWR4ID09PSAwID8gdGhpcy5kYXRlUGFydHNbMV0gOiBwYXJ0cztcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh7XG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZW5kXG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShwYXJ0cywgb3B0cyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uSW5wdXRJbnB1dChjb25maWcsIGlzU3RhcnQpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFfdGhpczUudXBkYXRlT25JbnB1dF8pIHJldHVybjtcbiAgICAgICAgbGV0IGlucHV0VmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcblxuICAgICAgICBfdGhpczUuaW5wdXRWYWx1ZXMuc3BsaWNlKGlzU3RhcnQgPyAwIDogMSwgMSwgaW5wdXRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKF90aGlzNS5pc1JhbmdlKSB7XG4gICAgICAgICAgaW5wdXRWYWx1ZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBfdGhpczUuaW5wdXRWYWx1ZXNbMF0sXG4gICAgICAgICAgICBlbmQ6IF90aGlzNS5pbnB1dFZhbHVlc1sxXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBfdGhpczUudXBkYXRlVmFsdWUoaW5wdXRWYWx1ZSwge1xuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBwYXRjaDogUEFUQ0hfREFURV9USU1FLFxuICAgICAgICAgIGZvcm1hdElucHV0OiBmYWxzZSxcbiAgICAgICAgICBoaWRlUG9wb3ZlcjogZmFsc2UsXG4gICAgICAgICAgZGVib3VuY2U6IF90aGlzNS5pbnB1dERlYm91bmNlX1xuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpczUuYWRqdXN0UGFnZVJhbmdlKGlzU3RhcnQpO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgb25JbnB1dENoYW5nZShjb25maWcsIGlzU3RhcnQpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBjb25maWcsXG4gICAgICAgIGZvcm1hdElucHV0OiB0cnVlLFxuICAgICAgICBoaWRlUG9wb3ZlcjogZmFsc2VcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3QgaW5wdXRWYWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAgIGlmIChfdGhpczYuaXNSYW5nZSkge1xuICAgICAgICAgIF90aGlzNi5pbnB1dFZhbHVlcy5zcGxpY2UoaXNTdGFydCA/IDAgOiAxLCAxLCBpbnB1dFZhbHVlKTtcblxuICAgICAgICAgIF90aGlzNi51cGRhdGVWYWx1ZSh7XG4gICAgICAgICAgICBzdGFydDogX3RoaXM2LmlucHV0VmFsdWVzWzBdLFxuICAgICAgICAgICAgZW5kOiBfdGhpczYuaW5wdXRWYWx1ZXNbMV1cbiAgICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczYuaW5wdXRWYWx1ZXMuc3BsaWNlKDAsIDEsIGlucHV0VmFsdWUpO1xuXG4gICAgICAgICAgX3RoaXM2LnVwZGF0ZVZhbHVlKGlucHV0VmFsdWUsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBvbklucHV0U2hvdyhpc1N0YXJ0KSB7XG4gICAgICB0aGlzLmFkanVzdFBhZ2VSYW5nZShpc1N0YXJ0KTtcbiAgICB9LFxuXG4gICAgb25JbnB1dEtleXVwKGUpIHtcbiAgICAgIC8vIEVzY2FwZSBrZXkgb25seVxuICAgICAgaWYgKGUua2V5ICE9PSAnRXNjYXBlJykgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLnZhbHVlXywge1xuICAgICAgICBmb3JtYXRJbnB1dDogdHJ1ZSxcbiAgICAgICAgaGlkZVBvcG92ZXI6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB1cGRhdGVWYWx1ZSh2YWx1ZSwgb3B0cyA9IHt9KSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudXBkYXRlVGltZW91dCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRlYm91bmNlLFxuICAgICAgICAgIC4uLmFyZ3NcbiAgICAgICAgfSA9IG9wdHM7XG5cbiAgICAgICAgaWYgKGRlYm91bmNlID4gMCkge1xuICAgICAgICAgIF90aGlzNy51cGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczcuZm9yY2VVcGRhdGVWYWx1ZSh2YWx1ZSwgYXJncyk7XG5cbiAgICAgICAgICAgIHJlc29sdmUoX3RoaXM3LnZhbHVlXyk7XG4gICAgICAgICAgfSwgZGVib3VuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzNy5mb3JjZVVwZGF0ZVZhbHVlKHZhbHVlLCBhcmdzKTtcblxuICAgICAgICAgIHJlc29sdmUoX3RoaXM3LnZhbHVlXyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmb3JjZVVwZGF0ZVZhbHVlKHZhbHVlLCB7XG4gICAgICBjb25maWcgPSB0aGlzLmRhdGVDb25maWcsXG4gICAgICBwYXRjaCA9IFBBVENIX0RBVEVfVElNRSxcbiAgICAgIG5vdGlmeSA9IHRydWUsXG4gICAgICBmb3JtYXRJbnB1dCA9IHRydWUsXG4gICAgICBoaWRlUG9wb3ZlciA9IGZhbHNlLFxuICAgICAgYWRqdXN0VGltZSA9IGZhbHNlLFxuICAgICAgaXNEcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZ1xuICAgIH0gPSB7fSkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIC8vIDEuIE5vcm1hbGl6YXRpb25cbiAgICAgIGxldCBub3JtYWxpemVkVmFsdWUgPSB0aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlLCBjb25maWcsIHBhdGNoLCBpc0RyYWdnaW5nKTsgLy8gVGltZSBBZGp1c3RtZW50XG5cbiAgICAgIGlmIChhZGp1c3RUaW1lKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZSA9IHRoaXMuYWRqdXN0VGltZUZvclZhbHVlKG5vcm1hbGl6ZWRWYWx1ZSwgY29uZmlnKTtcbiAgICAgIH0gLy8gMi4gVmFsaWRhdGlvbiAoZGF0ZSBvciByYW5nZSlcblxuXG4gICAgICBpZiAodGhpcy5oYXNWYWx1ZShub3JtYWxpemVkVmFsdWUpICYmIHRoaXMuZGlzYWJsZWRBdHRyaWJ1dGUgJiYgdGhpcy5kaXNhYmxlZEF0dHJpYnV0ZS5pbnRlcnNlY3RzRGF0ZShub3JtYWxpemVkVmFsdWUpKSB7XG4gICAgICAgIGlmIChpc0RyYWdnaW5nKSByZXR1cm47XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgICAgfSAvLyAzLiBBc3NpZ25tZW50XG5cblxuICAgICAgY29uc3QgdmFsdWVLZXkgPSBpc0RyYWdnaW5nID8gJ2RyYWdWYWx1ZScgOiAndmFsdWVfJztcbiAgICAgIGNvbnN0IHZhbHVlQ2hhbmdlZCA9ICF0aGlzLnZhbHVlc0FyZUVxdWFsKHRoaXNbdmFsdWVLZXldLCBub3JtYWxpemVkVmFsdWUpO1xuXG4gICAgICBpZiAodmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLCB2YWx1ZUtleSwgbm9ybWFsaXplZFZhbHVlKTsgLy8gQ2xlYXIgZHJhZyB2YWx1ZSBpZiBuZWVkZWRcblxuICAgICAgICBpZiAoIWlzRHJhZ2dpbmcpIHRoaXMuZHJhZ1ZhbHVlID0gbnVsbDtcbiAgICAgIH0gLy8gNC4gRGVub3JtYWxpemF0aW9uL05vdGlmaWNhdGlvblxuXG5cbiAgICAgIGlmIChub3RpZnkgJiYgdmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgIC8vIDRBLiBEZW5vcm1hbGl6YXRpb25cbiAgICAgICAgY29uc3QgZGVub3JtYWxpemVkVmFsdWUgPSB0aGlzLmRlbm9ybWFsaXplVmFsdWUobm9ybWFsaXplZFZhbHVlLCB0aGlzLmRhdGVDb25maWcpOyAvLyA0Qi4gTm90aWZpY2F0aW9uXG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmlzRHJhZ2dpbmcgPyAnZHJhZycgOiAnaW5wdXQnO1xuICAgICAgICB0aGlzLndhdGNoVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4kZW1pdChldmVudCwgZGVub3JtYWxpemVkVmFsdWUpO1xuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzOC53YXRjaFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIDUuIFNpZGUgZWZmZWN0cyBmb3Igbm9uLWlubGluZSBwaWNrZXJzXG5cblxuICAgICAgaWYgKGZvcm1hdElucHV0KSB0aGlzLmZvcm1hdElucHV0KCk7XG4gICAgICBpZiAoaGlkZVBvcG92ZXIpIHRoaXMuaGlkZVBvcG92ZXIoKTtcbiAgICB9LFxuXG4gICAgaGFzVmFsdWUodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5zdGFydCAmJiB2YWx1ZS5lbmQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgIH0sXG5cbiAgICBub3JtYWxpemVWYWx1ZSh2YWx1ZSwgY29uZmlnLCBwYXRjaCwgaXNEcmFnZ2luZykge1xuICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKHZhbHVlKSkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBwYXRjaEtleXMgPSBQQVRDSF9LRVlTW3BhdGNoXTtcblxuICAgICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMubm9ybWFsaXplRGF0ZSh2YWx1ZS5zdGFydCwgY29uZmlnLnN0YXJ0IHx8IGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMubm9ybWFsaXplRGF0ZSh2YWx1ZS5lbmQsIGNvbmZpZy5lbmQgfHwgY29uZmlnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zb3J0UmFuZ2Uoe1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocGF0Y2ggIT09IFBBVENIX0RBVEVfVElNRSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0UGFydHMgPSB7IC4uLnRoaXMuZGF0ZVBhcnRzWzBdLFxuICAgICAgICAgICAgLi4ucGlja19kZWZhdWx0KCkodGhpcy5nZXREYXRlUGFydHMocmVzdWx0LnN0YXJ0KSwgcGF0Y2hLZXlzKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gdGhpcy5nZXREYXRlRnJvbVBhcnRzKHN0YXJ0UGFydHMpO1xuICAgICAgICAgIGNvbnN0IGVuZFBhcnRzID0geyAuLi50aGlzLmRhdGVQYXJ0c1sxXSxcbiAgICAgICAgICAgIC4uLnBpY2tfZGVmYXVsdCgpKHRoaXMuZ2V0RGF0ZVBhcnRzKHJlc3VsdC5lbmQpLCBwYXRjaEtleXMpXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXN1bHQuZW5kID0gdGhpcy5nZXREYXRlRnJvbVBhcnRzKGVuZFBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0RyYWdnaW5nID8gcmVzdWx0IDogdGhpcy5zb3J0UmFuZ2UocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubm9ybWFsaXplRGF0ZSh2YWx1ZSwgY29uZmlnKTtcbiAgICAgIGlmIChwYXRjaCA9PT0gUEFUQ0hfREFURV9USU1FKSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmVzdWx0ID0geyAuLi50aGlzLmRhdGVQYXJ0c1swXSxcbiAgICAgICAgLi4ucGlja19kZWZhdWx0KCkodGhpcy5nZXREYXRlUGFydHMocmVzdWx0KSwgcGF0Y2hLZXlzKVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLmdldERhdGVGcm9tUGFydHMocmVzdWx0KTtcbiAgICB9LFxuXG4gICAgYWRqdXN0VGltZUZvclZhbHVlKHZhbHVlLCBjb25maWcpIHtcbiAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKHZhbHVlKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnQ6IHRoaXMuJGxvY2FsZS5hZGp1c3RUaW1lRm9yRGF0ZSh2YWx1ZS5zdGFydCwgY29uZmlnLnN0YXJ0IHx8IGNvbmZpZyksXG4gICAgICAgICAgZW5kOiB0aGlzLiRsb2NhbGUuYWRqdXN0VGltZUZvckRhdGUodmFsdWUuZW5kLCBjb25maWcuZW5kIHx8IGNvbmZpZylcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuJGxvY2FsZS5hZGp1c3RUaW1lRm9yRGF0ZSh2YWx1ZSwgY29uZmlnKTtcbiAgICB9LFxuXG4gICAgc29ydFJhbmdlKHJhbmdlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmRcbiAgICAgIH0gPSByYW5nZTtcblxuICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnQ6IGVuZCxcbiAgICAgICAgICBlbmQ6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGRlbm9ybWFsaXplVmFsdWUodmFsdWUsIGNvbmZpZykge1xuICAgICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUodmFsdWUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydDogdGhpcy4kbG9jYWxlLmRlbm9ybWFsaXplRGF0ZSh2YWx1ZS5zdGFydCwgY29uZmlnLnN0YXJ0IHx8IGNvbmZpZyksXG4gICAgICAgICAgZW5kOiB0aGlzLiRsb2NhbGUuZGVub3JtYWxpemVEYXRlKHZhbHVlLmVuZCwgY29uZmlnLmVuZCB8fCBjb25maWcpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiRsb2NhbGUuZGVub3JtYWxpemVEYXRlKHZhbHVlLCBjb25maWcpO1xuICAgIH0sXG5cbiAgICB2YWx1ZXNBcmVFcXVhbChhLCBiKSB7XG4gICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgIGNvbnN0IGFIYXNWYWx1ZSA9IHRoaXMuaGFzVmFsdWUoYSk7XG4gICAgICAgIGNvbnN0IGJIYXNWYWx1ZSA9IHRoaXMuaGFzVmFsdWUoYik7XG4gICAgICAgIGlmICghYUhhc1ZhbHVlICYmICFiSGFzVmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoYUhhc1ZhbHVlICE9PSBiSGFzVmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGRhdGVzQXJlRXF1YWwoYS5zdGFydCwgYi5zdGFydCkgJiYgZGF0ZXNBcmVFcXVhbChhLmVuZCwgYi5lbmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0ZXNBcmVFcXVhbChhLCBiKTtcbiAgICB9LFxuXG4gICAgZm9ybWF0SW5wdXQoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIG1hc2s6IF90aGlzOS4kbG9jYWxlLm1hc2tzLmlucHV0LFxuICAgICAgICAgIHRpbWV6b25lOiBfdGhpczkudGltZXpvbmVcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IF90aGlzOS5kZW5vcm1hbGl6ZVZhbHVlKF90aGlzOS5kcmFnVmFsdWUgfHwgX3RoaXM5LnZhbHVlXywgb3B0cyk7XG5cbiAgICAgICAgaWYgKF90aGlzOS5pc1JhbmdlKSB7XG4gICAgICAgICAgX3RoaXM5LmlucHV0VmFsdWVzID0gW3ZhbHVlICYmIHZhbHVlLnN0YXJ0LCB2YWx1ZSAmJiB2YWx1ZS5lbmRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzOS5pbnB1dFZhbHVlcyA9IFt2YWx1ZSwgJyddO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2hvd1BvcG92ZXIob3B0cyA9IHt9KSB7XG4gICAgICBwb3BvdmVyc19zaG93UG9wb3Zlcih7XG4gICAgICAgIHJlZjogdGhpcy4kZWwsXG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGlzSW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgIGlkOiB0aGlzLmRhdGVQaWNrZXJQb3BvdmVySWRcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBoaWRlUG9wb3ZlcihvcHRzID0ge30pIHtcbiAgICAgIHBvcG92ZXJzX2hpZGVQb3BvdmVyKHsgLi4ub3B0cyxcbiAgICAgICAgaWQ6IHRoaXMuZGF0ZVBpY2tlclBvcG92ZXJJZFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVBvcG92ZXIob3B0cykge1xuICAgICAgcG9wb3ZlcnNfdG9nZ2xlUG9wb3Zlcih7XG4gICAgICAgIHJlZjogdGhpcy4kZWwsXG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGlzSW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgIGlkOiB0aGlzLmRhdGVQaWNrZXJQb3BvdmVySWRcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhZGp1c3RQYWdlUmFuZ2UoaXNTdGFydCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyID0gX3RoaXMxMC4kcmVmcy5jYWxlbmRhcjtcblxuICAgICAgICBjb25zdCBwYWdlID0gX3RoaXMxMC5nZXRQYWdlRm9yVmFsdWUoaXNTdGFydCk7XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBpc1N0YXJ0ID8gMSA6IC0xO1xuXG4gICAgICAgIGlmIChwYWdlICYmIGNhbGVuZGFyICYmICFwYWdlSXNCZXR3ZWVuUGFnZXMocGFnZSwgY2FsZW5kYXIuZmlyc3RQYWdlLCBjYWxlbmRhci5sYXN0UGFnZSkpIHtcbiAgICAgICAgICBjYWxlbmRhci5tb3ZlKHBhZ2UsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2ZhZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRQYWdlRm9yVmFsdWUoaXNTdGFydCkge1xuICAgICAgaWYgKHRoaXMuaGFzVmFsdWUodGhpcy52YWx1ZV8pKSB7XG4gICAgICAgIHJldHVybiBwYWdlRm9yRGF0ZSh0aGlzLmlzUmFuZ2UgPyB0aGlzLnZhbHVlX1tpc1N0YXJ0ID8gJ3N0YXJ0JyA6ICdlbmQnXSA6IHRoaXMudmFsdWVfKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9EYXRlUGlja2VyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX0RhdGVQaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoRGF0ZVBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9EYXRlUGlja2VyLnZ1ZVxudmFyIERhdGVQaWNrZXJfcmVuZGVyLCBEYXRlUGlja2VyX3N0YXRpY1JlbmRlckZuc1xuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBEYXRlUGlja2VyX2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19EYXRlUGlja2VydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBEYXRlUGlja2VyX3JlbmRlcixcbiAgRGF0ZVBpY2tlcl9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBEYXRlUGlja2VyID0gKERhdGVQaWNrZXJfY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogQzovUHJvamVjdHMvdi1jYWxlbmRhci9ub2RlX21vZHVsZXMvQHZ1ZS9jbGktc2VydmljZS9saWIvY29tbWFuZHMvYnVpbGQvZW50cnktbGliLmpzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZW50cnlfbGliID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoRGF0ZVBpY2tlcik7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmYmE1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2I1YVwiKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImZjNmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ0YWRcIik7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxZDgwXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImZkYmNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmRiZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTMwXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICYmICFTeW1ib2wuc2hhbVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmZmQ2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM3MjlcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjEzMTBcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KVtcImRlZmF1bHRcIl07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGUtcGlja2VyLnVtZC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLFFBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/v-calendar/lib/components/date-picker.umd.js\n");

/***/ })

}]);